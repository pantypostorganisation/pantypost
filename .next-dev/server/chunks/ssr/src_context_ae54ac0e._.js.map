{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/gerom/OneDrive/Documents/pantypost/src/context/AuthContext.tsx"],"sourcesContent":["'use client';\r\n\r\nimport React, {\r\n  createContext,\r\n  useContext,\r\n  useEffect,\r\n  useState,\r\n  ReactNode,\r\n  useCallback,\r\n  useRef,\r\n} from 'react';\r\nimport { usePathname, useRouter } from 'next/navigation';\r\nimport { apiConfig } from '@/config/environment';\r\nimport { z } from 'zod';\r\nimport { sanitizeUsername } from '@/utils/security/sanitization';\r\n\r\n// ==================== TYPES ====================\r\n\r\nexport interface User {\r\n  id: string;\r\n  username: string;\r\n  role: 'buyer' | 'seller' | 'admin';\r\n  email?: string;\r\n  profilePicture?: string;\r\n  isVerified: boolean;\r\n  tier?: 'Tease' | 'Flirt' | 'Obsession' | 'Desire' | 'Goddess';\r\n  subscriberCount?: number;\r\n  totalSales?: number;\r\n  rating?: number;\r\n  reviewCount?: number;\r\n  createdAt: string;\r\n  lastActive: string;\r\n  bio?: string;\r\n  isBanned?: boolean;\r\n  banReason?: string;\r\n  banExpiresAt?: string;\r\n  verificationStatus: 'pending' | 'verified' | 'rejected' | 'unverified';\r\n  verificationRequestedAt?: string;\r\n  verificationRejectionReason?: string;\r\n  verificationDocs?: any;\r\n}\r\n\r\ninterface AuthTokens {\r\n  token: string;\r\n  refreshToken: string;\r\n  expiresAt: number; // Unix timestamp (ms)\r\n}\r\n\r\ninterface AuthContextType {\r\n  user: User | null;\r\n  isAuthReady: boolean;\r\n  login: (\r\n    username: string,\r\n    password: string,\r\n    role?: 'buyer' | 'seller' | 'admin'\r\n  ) => Promise<boolean>;\r\n  logout: () => Promise<void>;\r\n  updateUser: (updates: Partial<User>) => Promise<void>;\r\n  isLoggedIn: boolean;\r\n  loading: boolean;\r\n  error: string | null;\r\n  clearError: () => void;\r\n  refreshSession: () => Promise<void>;\r\n  getAuthToken: () => string | null;\r\n  apiClient: ApiClient;\r\n  token: string | null; // compatibility\r\n}\r\n\r\n// ==================== SCHEMAS ====================\r\n\r\nconst LoginPayloadSchema = z.object({\r\n  username: z.string().min(1).max(60),\r\n  password: z.string().min(1),\r\n  role: z.enum(['buyer', 'seller', 'admin']).optional(),\r\n});\r\n\r\ntype LoginPayload = z.infer<typeof LoginPayloadSchema>;\r\n\r\n// ==================== HELPERS ====================\r\n\r\nfunction safeNow(): number {\r\n  try {\r\n    return Date.now();\r\n  } catch {\r\n    return new Date().getTime();\r\n  }\r\n}\r\n\r\n/**\r\n * Safely parse JSON; return null if empty/invalid.\r\n */\r\nasync function safeParseJson<T>(resp: Response): Promise<T | null> {\r\n  try {\r\n    const text = await resp.text();\r\n    if (!text) return null;\r\n    return JSON.parse(text) as T;\r\n  } catch {\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Derive absolute expiry from `expiresIn` (seconds or ms).\r\n * Fallback to defaultMs when not provided.\r\n */\r\nfunction deriveExpiry(expiresIn: unknown, defaultMs: number): number {\r\n  const now = safeNow();\r\n  if (typeof expiresIn === 'number' && Number.isFinite(expiresIn)) {\r\n    // Heuristic: values <= 24*60*60*100 (i.e., less than 1 day if treated as ms)\r\n    // are likely seconds; multiply by 1000. Otherwise assume ms.\r\n    const asMs = expiresIn < 86_400 ? expiresIn * 1000 : expiresIn;\r\n    return now + asMs;\r\n  }\r\n  return now + defaultMs;\r\n}\r\n\r\n// ==================== API CLIENT ====================\r\n\r\nclass ApiClient {\r\n  private baseURL: string;\r\n  private authContext: {\r\n    getTokens: () => AuthTokens | null;\r\n    setTokens: (tokens: AuthTokens | null) => void;\r\n    onTokenRefresh?: () => Promise<void>;\r\n  };\r\n  private refreshPromise: Promise<AuthTokens | null> | null = null;\r\n\r\n  constructor(\r\n    baseURL: string,\r\n    authContext: {\r\n      getTokens: () => AuthTokens | null;\r\n      setTokens: (tokens: AuthTokens | null) => void;\r\n      onTokenRefresh?: () => Promise<void>;\r\n    }\r\n  ) {\r\n    this.baseURL = baseURL.replace(/\\/+$/, ''); // strip trailing slashes\r\n    this.authContext = authContext;\r\n  }\r\n\r\n  /**\r\n   * Build full API URL - handles both relative and absolute endpoints\r\n   */\r\n  private buildUrl(endpoint: string): string {\r\n    // If endpoint already starts with http/https, return as is\r\n    if (endpoint.startsWith('http://') || endpoint.startsWith('https://')) {\r\n      return endpoint;\r\n    }\r\n\r\n    // Ensure endpoint starts with /\r\n    const path = endpoint.startsWith('/') ? endpoint : `/${endpoint}`;\r\n\r\n    // If baseURL already ends with /api, don't add it again\r\n    if (this.baseURL.endsWith('/api')) {\r\n      return `${this.baseURL}${path}`;\r\n    }\r\n\r\n    // Otherwise, add /api prefix to the path\r\n    return `${this.baseURL}/api${path}`;\r\n  }\r\n\r\n  private async refreshTokens(): Promise<AuthTokens | null> {\r\n    // Prevent multiple simultaneous refresh attempts\r\n    if (this.refreshPromise) {\r\n      return this.refreshPromise;\r\n    }\r\n\r\n    const tokens = this.authContext.getTokens();\r\n    if (!tokens?.refreshToken) {\r\n      return null;\r\n    }\r\n\r\n    this.refreshPromise = (async () => {\r\n      try {\r\n        const response = await fetch(this.buildUrl('/auth/refresh'), {\r\n          method: 'POST',\r\n          headers: { 'Content-Type': 'application/json' },\r\n          body: JSON.stringify({ refreshToken: tokens.refreshToken }),\r\n        });\r\n\r\n        // Gracefully parse JSON (may be empty on some implementations)\r\n        const data = await safeParseJson<any>(response);\r\n\r\n        if (response.ok && data?.success && data?.data) {\r\n          const expiresAt = deriveExpiry(\r\n            // try both common fields\r\n            data.data.expiresIn ?? data.data.tokenExpiresIn,\r\n            30 * 60 * 1000 // fallback 30 minutes\r\n          );\r\n\r\n          const newTokens: AuthTokens = {\r\n            token: data.data.token,\r\n            refreshToken: data.data.refreshToken || tokens.refreshToken,\r\n            expiresAt,\r\n          };\r\n\r\n          this.authContext.setTokens(newTokens);\r\n\r\n          // Fire token update event for WebSocket\r\n          if (typeof window !== 'undefined') {\r\n            window.dispatchEvent(\r\n              new CustomEvent('auth-token-updated', {\r\n                detail: { token: newTokens.token },\r\n              })\r\n            );\r\n          }\r\n\r\n          // Call the refresh callback if provided\r\n          if (this.authContext.onTokenRefresh) {\r\n            await this.authContext.onTokenRefresh();\r\n          }\r\n\r\n          return newTokens;\r\n        }\r\n\r\n        // If refresh failed, clear tokens\r\n        throw new Error('Invalid refresh response');\r\n      } catch (error) {\r\n        console.error('Token refresh failed:', error);\r\n        this.authContext.setTokens(null);\r\n\r\n        if (typeof window !== 'undefined') {\r\n          window.dispatchEvent(new CustomEvent('auth-token-cleared'));\r\n        }\r\n\r\n        return null;\r\n      } finally {\r\n        this.refreshPromise = null;\r\n      }\r\n    })();\r\n\r\n    return this.refreshPromise;\r\n  }\r\n\r\n  private async getValidToken(): Promise<string | null> {\r\n    const tokens = this.authContext.getTokens();\r\n\r\n    if (!tokens) {\r\n      return null;\r\n    }\r\n\r\n    // Check if token is expired or about to expire (5 minutes buffer)\r\n    const isExpiringSoon = tokens.expiresAt <= safeNow() + 5 * 60 * 1000;\r\n\r\n    if (isExpiringSoon) {\r\n      const newTokens = await this.refreshTokens();\r\n      return newTokens?.token || null;\r\n    }\r\n\r\n    return tokens.token;\r\n  }\r\n\r\n  async request<T = any>(\r\n    endpoint: string,\r\n    options: RequestInit = {}\r\n  ): Promise<{ success: boolean; data?: T; error?: any }> {\r\n    const token = await this.getValidToken();\r\n\r\n    // Create headers as a plain object first\r\n    const headerObj: Record<string, string> = {\r\n      'Content-Type': 'application/json',\r\n    };\r\n\r\n    // Add existing headers from options\r\n    if (options.headers) {\r\n      const existingHeaders =\r\n        options.headers instanceof Headers\r\n          ? Object.fromEntries(options.headers.entries())\r\n          : Array.isArray(options.headers)\r\n          ? Object.fromEntries(options.headers)\r\n          : (options.headers as Record<string, string>);\r\n\r\n      Object.assign(headerObj, existingHeaders);\r\n    }\r\n\r\n    // Add auth token if available\r\n    if (token) {\r\n      headerObj['Authorization'] = `Bearer ${token}`;\r\n    }\r\n\r\n    const url = this.buildUrl(endpoint);\r\n\r\n    const doFetch = async () => {\r\n      const resp = await fetch(url, { ...options, headers: headerObj });\r\n      const json = await safeParseJson<any>(resp);\r\n\r\n      // If server returns our standard shape, just return it as-is\r\n      if (json && typeof json.success === 'boolean') {\r\n        return json;\r\n      }\r\n\r\n      // Otherwise normalize a minimal shape\r\n      if (resp.ok) {\r\n        return { success: true, data: json as T };\r\n      }\r\n      return {\r\n        success: false,\r\n        error: {\r\n          code: resp.status || 'HTTP_ERROR',\r\n          message: json?.error?.message || resp.statusText || 'Request failed',\r\n        },\r\n      };\r\n    };\r\n\r\n    try {\r\n      const result = await doFetch();\r\n\r\n      // Handle 401 Unauthorized - try to refresh token once\r\n      if (!result.success && (result as any)?.error?.code === 401 && token) {\r\n        const newTokens = await this.refreshTokens();\r\n        if (newTokens) {\r\n          headerObj['Authorization'] = `Bearer ${newTokens.token}`;\r\n          const retry = await doFetch();\r\n          return retry;\r\n        }\r\n      }\r\n\r\n      return result;\r\n    } catch (error) {\r\n      console.error('API request failed:', error);\r\n      return {\r\n        success: false,\r\n        error: {\r\n          code: 'NETWORK_ERROR',\r\n          message: 'Network request failed',\r\n        },\r\n      };\r\n    }\r\n  }\r\n\r\n  // Convenience methods\r\n  get<T = any>(endpoint: string, options?: RequestInit) {\r\n    return this.request<T>(endpoint, { ...options, method: 'GET' });\r\n  }\r\n\r\n  post<T = any>(endpoint: string, body?: any, options?: RequestInit) {\r\n    return this.request<T>(endpoint, {\r\n      ...options,\r\n      method: 'POST',\r\n      body: body ? JSON.stringify(body) : undefined,\r\n    });\r\n  }\r\n\r\n  patch<T = any>(endpoint: string, body?: any, options?: RequestInit) {\r\n    return this.request<T>(endpoint, {\r\n      ...options,\r\n      method: 'PATCH',\r\n      body: body ? JSON.stringify(body) : undefined,\r\n    });\r\n  }\r\n\r\n  delete<T = any>(endpoint: string, options?: RequestInit) {\r\n    return this.request<T>(endpoint, { ...options, method: 'DELETE' });\r\n  }\r\n}\r\n\r\n// ==================== AUTH CONTEXT ====================\r\n\r\nconst AuthContext = createContext<AuthContextType | undefined>(undefined);\r\n\r\n// Get API base URL from environment config\r\nconst API_BASE_URL =\r\n  apiConfig?.baseUrl || process.env.NEXT_PUBLIC_API_URL || 'http://localhost:5000';\r\n\r\n// Enhanced Token storage with WebSocket event support\r\nclass TokenStorage {\r\n  private memoryTokens: AuthTokens | null = null;\r\n\r\n  constructor() {\r\n    // Try to restore from sessionStorage on initialization\r\n    if (typeof window !== 'undefined') {\r\n      try {\r\n        const stored = sessionStorage.getItem('auth_tokens');\r\n        if (stored) {\r\n          this.memoryTokens = JSON.parse(stored);\r\n          // Fire initial token event if we have tokens\r\n          if (this.memoryTokens?.token) {\r\n            setTimeout(() => {\r\n              window.dispatchEvent(\r\n                new CustomEvent('auth-token-updated', {\r\n                  detail: { token: this.memoryTokens!.token },\r\n                })\r\n              );\r\n            }, 100);\r\n          }\r\n        }\r\n      } catch (error) {\r\n        console.error('Failed to restore tokens:', error);\r\n      }\r\n    }\r\n  }\r\n\r\n  setTokens(tokens: AuthTokens | null) {\r\n    this.memoryTokens = tokens;\r\n\r\n    if (typeof window !== 'undefined') {\r\n      if (tokens) {\r\n        try {\r\n          sessionStorage.setItem('auth_tokens', JSON.stringify(tokens));\r\n          // Fire token update event\r\n          window.dispatchEvent(\r\n            new CustomEvent('auth-token-updated', {\r\n              detail: { token: tokens.token },\r\n            })\r\n          );\r\n        } catch (error) {\r\n          console.error('Failed to store tokens:', error);\r\n        }\r\n      } else {\r\n        sessionStorage.removeItem('auth_tokens');\r\n        // Fire token cleared event\r\n        window.dispatchEvent(new CustomEvent('auth-token-cleared'));\r\n      }\r\n    }\r\n  }\r\n\r\n  getTokens(): AuthTokens | null {\r\n    return this.memoryTokens;\r\n  }\r\n\r\n  clear() {\r\n    this.memoryTokens = null;\r\n    if (typeof window !== 'undefined') {\r\n      sessionStorage.removeItem('auth_tokens');\r\n      // Fire token cleared event\r\n      window.dispatchEvent(new CustomEvent('auth-token-cleared'));\r\n    }\r\n  }\r\n}\r\n\r\nexport function AuthProvider({ children }: { children: ReactNode }) {\r\n  const [user, setUser] = useState<User | null>(null);\r\n  const [isAuthReady, setIsAuthReady] = useState(false);\r\n  const [loading, setLoading] = useState(false);\r\n  const [error, setError] = useState<string | null>(null);\r\n  const pathname = usePathname();\r\n  const router = useRouter();\r\n\r\n  // Token storage instance\r\n  const tokenStorageRef = useRef(new TokenStorage());\r\n\r\n  // API client instance with auth context\r\n  const apiClientRef = useRef<ApiClient | null>(null);\r\n\r\n  // Refresh session - fetch current user\r\n  const refreshSession = useCallback(async () => {\r\n    const tokens = tokenStorageRef.current.getTokens();\r\n    if (!tokens?.token) {\r\n      setUser(null);\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const response = await apiClientRef.current!.get<User>('/auth/me');\r\n\r\n      if (response.success && response.data) {\r\n        setUser(response.data);\r\n      } else {\r\n        setUser(null);\r\n        tokenStorageRef.current.clear();\r\n      }\r\n    } catch (error) {\r\n      console.error('Failed to refresh session:', error);\r\n      setUser(null);\r\n      tokenStorageRef.current.clear();\r\n    }\r\n  }, []);\r\n\r\n  // Initialize API client\r\n  if (!apiClientRef.current) {\r\n    apiClientRef.current = new ApiClient(API_BASE_URL, {\r\n      getTokens: () => tokenStorageRef.current.getTokens(),\r\n      setTokens: (tokens) => tokenStorageRef.current.setTokens(tokens),\r\n      onTokenRefresh: async () => {\r\n        // Refresh user data after token refresh\r\n        await refreshSession();\r\n      },\r\n    });\r\n  }\r\n\r\n  // Clear error\r\n  const clearError = useCallback(() => {\r\n    setError(null);\r\n  }, []);\r\n\r\n  // Get auth token\r\n  const getAuthToken = useCallback(() => {\r\n    const tokens = tokenStorageRef.current.getTokens();\r\n    return tokens?.token || null;\r\n  }, []);\r\n\r\n  // Initialize auth state on mount\r\n  useEffect(() => {\r\n    const initAuth = async () => {\r\n      console.log('[Auth] Initializing...');\r\n      console.log('[Auth] API_BASE_URL:', API_BASE_URL);\r\n\r\n      try {\r\n        await refreshSession();\r\n      } catch (error) {\r\n        console.error('[Auth] Init error:', error);\r\n      } finally {\r\n        setIsAuthReady(true);\r\n        console.log('[Auth] Ready');\r\n      }\r\n    };\r\n\r\n    initAuth();\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, []); // refreshSession is stable here; intentional single-run\r\n\r\n  const login = useCallback(\r\n    async (\r\n      username: string,\r\n      password: string,\r\n      role: 'buyer' | 'seller' | 'admin' = 'buyer'\r\n    ): Promise<boolean> => {\r\n      console.log('[Auth] Login attempt:', { username, role, hasPassword: !!password });\r\n\r\n      setLoading(true);\r\n      setError(null);\r\n\r\n      try {\r\n        // Validate & sanitize inputs\r\n        const parsed = LoginPayloadSchema.safeParse({ username, password, role });\r\n        if (!parsed.success) {\r\n          setError('Please enter a valid username and password.');\r\n          setLoading(false);\r\n          return false;\r\n        }\r\n\r\n        const cleanUsername = sanitizeUsername\r\n          ? sanitizeUsername(parsed.data.username)\r\n          : parsed.data.username.trim();\r\n\r\n        const payload: LoginPayload = {\r\n          username: cleanUsername,\r\n          password: parsed.data.password,\r\n          role: parsed.data.role, // optional on backend; we pass it if present\r\n        };\r\n\r\n        // Use the API client which handles URL construction properly\r\n        const response = await apiClientRef.current!.post('/auth/login', payload);\r\n\r\n        console.log('[Auth] Login response:', {\r\n          success: response.success,\r\n          hasUser: !!response.data?.user,\r\n        });\r\n\r\n        if (response.success && response.data) {\r\n          // Calculate token expiration (prefer backend hints)\r\n          const expiresAt =\r\n            deriveExpiry(\r\n              // try common fields the backend might send\r\n              response.data.expiresIn ?? response.data.tokenExpiresIn,\r\n              7 * 24 * 60 * 60 * 1000 // fallback 7 days\r\n            );\r\n\r\n          const tokens: AuthTokens = {\r\n            token: response.data.token,\r\n            refreshToken: response.data.refreshToken,\r\n            expiresAt,\r\n          };\r\n\r\n          // Store tokens securely (fires auth-token-updated)\r\n          tokenStorageRef.current.setTokens(tokens);\r\n\r\n          // Set user state\r\n          setUser(response.data.user);\r\n\r\n          console.log('[Auth] Login successful');\r\n          setLoading(false);\r\n          return true;\r\n        } else {\r\n          const errorMessage = (response as any)?.error?.message || 'Login failed';\r\n          setError(errorMessage);\r\n          setLoading(false);\r\n          return false;\r\n        }\r\n      } catch (error) {\r\n        console.error('[Auth] Login error:', error);\r\n        setError('Network error. Please check your connection and try again.');\r\n        setLoading(false);\r\n        return false;\r\n      }\r\n    },\r\n    []\r\n  );\r\n\r\n  const logout = useCallback(async () => {\r\n    console.log('[Auth] Logging out...');\r\n\r\n    try {\r\n      const token = getAuthToken();\r\n      if (token) {\r\n        // Even if the server returns 204, our client handles it safely\r\n        await apiClientRef.current!.post('/auth/logout');\r\n      }\r\n    } catch (error) {\r\n      console.error('[Auth] Logout API error:', error);\r\n    }\r\n\r\n    // Clear local state regardless of API response (fires auth-token-cleared)\r\n    tokenStorageRef.current.clear();\r\n    setUser(null);\r\n    setError(null);\r\n\r\n    // Redirect to login page\r\n    router.push('/login');\r\n\r\n    console.log('[Auth] Logout complete');\r\n  }, [getAuthToken, router]);\r\n\r\n  // Update user function\r\n  const updateUser = useCallback(\r\n    async (updates: Partial<User>) => {\r\n      if (!user) {\r\n        setError('No user to update');\r\n        return;\r\n      }\r\n\r\n      try {\r\n        const response = await apiClientRef.current!.patch<User>(\r\n          `/users/${user.username}/profile`,\r\n          updates\r\n        );\r\n\r\n        if (response.success && response.data) {\r\n          setUser(response.data);\r\n        } else {\r\n          setError(response.error?.message || 'Failed to update user');\r\n        }\r\n      } catch (error: any) {\r\n        console.error('Update user error:', error);\r\n        setError(error.message || 'Failed to update user');\r\n      }\r\n    },\r\n    [user]\r\n  );\r\n\r\n  const contextValue: AuthContextType = {\r\n    user,\r\n    isAuthReady,\r\n    login,\r\n    logout,\r\n    updateUser,\r\n    isLoggedIn: !!user,\r\n    loading,\r\n    error,\r\n    clearError,\r\n    refreshSession,\r\n    getAuthToken,\r\n    apiClient: apiClientRef.current!,\r\n    token: getAuthToken(), // compatibility; use getAuthToken() for up-to-date value\r\n  };\r\n\r\n  return <AuthContext.Provider value={contextValue}>{children}</AuthContext.Provider>;\r\n}\r\n\r\nexport function useAuth() {\r\n  const context = useContext(AuthContext);\r\n  if (context === undefined) {\r\n    throw new Error('useAuth must be used within an AuthProvider');\r\n  }\r\n  return context;\r\n}\r\n\r\n// Export getAuthToken globally for WebSocket access\r\nexport const getGlobalAuthToken = (): string | null => {\r\n  if (typeof window === 'undefined') return null;\r\n\r\n  try {\r\n    const stored = sessionStorage.getItem('auth_tokens');\r\n    if (stored) {\r\n      const tokens = JSON.parse(stored);\r\n      return tokens?.token || null;\r\n    }\r\n  } catch (error) {\r\n    console.error('Failed to get global auth token:', error);\r\n  }\r\n\r\n  return null;\r\n};\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 489, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/gerom/OneDrive/Documents/pantypost/src/context/ToastContext.tsx"],"sourcesContent":["// src/context/ToastContext.tsx\r\n'use client';\r\n\r\nimport React, { createContext, useContext, useState, useCallback, useEffect, useRef } from 'react';\r\nimport { X, CheckCircle, AlertCircle, Info, AlertTriangle, Loader2 } from 'lucide-react';\r\nimport { AnimatePresence, motion } from 'framer-motion';\r\n\r\n// Toast types\r\nexport type ToastType = 'success' | 'error' | 'info' | 'warning' | 'loading';\r\n\r\nexport interface Toast {\r\n  id: string;\r\n  type: ToastType;\r\n  title: string;\r\n  message?: string;\r\n  duration?: number;\r\n  action?: {\r\n    label: string;\r\n    onClick: () => void;\r\n  };\r\n  dismissible?: boolean;\r\n  persistent?: boolean;\r\n}\r\n\r\ninterface ToastContextType {\r\n  toasts: Toast[];\r\n  showToast: (toast: Omit<Toast, 'id'>) => string;\r\n  updateToast: (id: string, updates: Partial<Toast>) => void;\r\n  removeToast: (id: string) => void;\r\n  clearToasts: () => void;\r\n  // Convenience methods\r\n  success: (title: string, message?: string) => string;\r\n  error: (title: string, message?: string) => string;\r\n  info: (title: string, message?: string) => string;\r\n  warning: (title: string, message?: string) => string;\r\n  loading: (title: string, message?: string) => string;\r\n  promise: <T>(\r\n    promise: Promise<T>,\r\n    messages: {\r\n      loading: string;\r\n      success: string | ((data: T) => string);\r\n      error: string | ((error: any) => string);\r\n    }\r\n  ) => Promise<T>;\r\n}\r\n\r\nconst ToastContext = createContext<ToastContextType | undefined>(undefined);\r\n\r\n// Default durations by type\r\nconst DEFAULT_DURATIONS: Record<ToastType, number> = {\r\n  success: 4000,\r\n  error: 6000,\r\n  info: 5000,\r\n  warning: 5000,\r\n  loading: 0, // No auto-dismiss for loading\r\n};\r\n\r\n// Toast icons\r\nconst TOAST_ICONS: Record<ToastType, React.FC<{ className?: string }>> = {\r\n  success: CheckCircle,\r\n  error: AlertCircle,\r\n  info: Info,\r\n  warning: AlertTriangle,\r\n  loading: Loader2,\r\n};\r\n\r\n// Toast colors\r\nconst TOAST_COLORS: Record<ToastType, { bg: string; border: string; icon: string }> = {\r\n  success: {\r\n    bg: 'bg-green-900/20',\r\n    border: 'border-green-700',\r\n    icon: 'text-green-400',\r\n  },\r\n  error: {\r\n    bg: 'bg-red-900/20',\r\n    border: 'border-red-700',\r\n    icon: 'text-red-400',\r\n  },\r\n  info: {\r\n    bg: 'bg-blue-900/20',\r\n    border: 'border-blue-700',\r\n    icon: 'text-blue-400',\r\n  },\r\n  warning: {\r\n    bg: 'bg-yellow-900/20',\r\n    border: 'border-yellow-700',\r\n    icon: 'text-yellow-400',\r\n  },\r\n  loading: {\r\n    bg: 'bg-gray-900/20',\r\n    border: 'border-gray-700',\r\n    icon: 'text-[#ff950e]',\r\n  },\r\n};\r\n\r\nexport function ToastProvider({ children }: { children: React.ReactNode }) {\r\n  const [toasts, setToasts] = useState<Toast[]>([]);\r\n  const timersRef = useRef<Map<string, NodeJS.Timeout>>(new Map());\r\n\r\n  // Generate unique ID\r\n  const generateId = () => `toast_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n\r\n  // Show toast\r\n  const showToast = useCallback((toast: Omit<Toast, 'id'>): string => {\r\n    const id = generateId();\r\n    const newToast: Toast = {\r\n      ...toast,\r\n      id,\r\n      duration: toast.duration ?? DEFAULT_DURATIONS[toast.type],\r\n      dismissible: toast.dismissible ?? true,\r\n    };\r\n\r\n    setToasts(prev => [...prev, newToast]);\r\n\r\n    // Auto-dismiss if duration is set and not persistent\r\n    if (newToast.duration && !newToast.persistent) {\r\n      const timer = setTimeout(() => {\r\n        removeToast(id);\r\n      }, newToast.duration);\r\n      timersRef.current.set(id, timer);\r\n    }\r\n\r\n    return id;\r\n  }, []);\r\n\r\n  // Update toast\r\n  const updateToast = useCallback((id: string, updates: Partial<Toast>) => {\r\n    setToasts(prev =>\r\n      prev.map(toast =>\r\n        toast.id === id\r\n          ? { ...toast, ...updates }\r\n          : toast\r\n      )\r\n    );\r\n\r\n    // Handle duration updates\r\n    if (updates.duration !== undefined) {\r\n      const existingTimer = timersRef.current.get(id);\r\n      if (existingTimer) {\r\n        clearTimeout(existingTimer);\r\n        timersRef.current.delete(id);\r\n      }\r\n\r\n      if (updates.duration && !updates.persistent) {\r\n        const timer = setTimeout(() => {\r\n          removeToast(id);\r\n        }, updates.duration);\r\n        timersRef.current.set(id, timer);\r\n      }\r\n    }\r\n  }, []);\r\n\r\n  // Remove toast\r\n  const removeToast = useCallback((id: string) => {\r\n    // Clear any existing timer\r\n    const timer = timersRef.current.get(id);\r\n    if (timer) {\r\n      clearTimeout(timer);\r\n      timersRef.current.delete(id);\r\n    }\r\n\r\n    setToasts(prev => prev.filter(toast => toast.id !== id));\r\n  }, []);\r\n\r\n  // Clear all toasts\r\n  const clearToasts = useCallback(() => {\r\n    // Clear all timers\r\n    timersRef.current.forEach(timer => clearTimeout(timer));\r\n    timersRef.current.clear();\r\n    \r\n    setToasts([]);\r\n  }, []);\r\n\r\n  // Convenience methods\r\n  const success = useCallback((title: string, message?: string) => \r\n    showToast({ type: 'success', title, message }), [showToast]);\r\n  \r\n  const error = useCallback((title: string, message?: string) => \r\n    showToast({ type: 'error', title, message }), [showToast]);\r\n  \r\n  const info = useCallback((title: string, message?: string) => \r\n    showToast({ type: 'info', title, message }), [showToast]);\r\n  \r\n  const warning = useCallback((title: string, message?: string) => \r\n    showToast({ type: 'warning', title, message }), [showToast]);\r\n  \r\n  const loading = useCallback((title: string, message?: string) => \r\n    showToast({ type: 'loading', title, message, persistent: true }), [showToast]);\r\n\r\n  // Promise handler\r\n  const promise = useCallback(async <T,>(\r\n    promise: Promise<T>,\r\n    messages: {\r\n      loading: string;\r\n      success: string | ((data: T) => string);\r\n      error: string | ((error: any) => string);\r\n    }\r\n  ): Promise<T> => {\r\n    const id = loading(messages.loading);\r\n\r\n    try {\r\n      const result = await promise;\r\n      const successMessage = typeof messages.success === 'function' \r\n        ? messages.success(result) \r\n        : messages.success;\r\n      \r\n      updateToast(id, { \r\n        type: 'success', \r\n        title: successMessage,\r\n        message: undefined,\r\n        duration: DEFAULT_DURATIONS.success,\r\n        persistent: false,\r\n      });\r\n      \r\n      return result;\r\n    } catch (error) {\r\n      const errorMessage = typeof messages.error === 'function' \r\n        ? messages.error(error) \r\n        : messages.error;\r\n      \r\n      updateToast(id, { \r\n        type: 'error', \r\n        title: errorMessage,\r\n        message: error instanceof Error ? error.message : undefined,\r\n        duration: DEFAULT_DURATIONS.error,\r\n        persistent: false,\r\n      });\r\n      \r\n      throw error;\r\n    }\r\n  }, [loading, updateToast]);\r\n\r\n  // Cleanup timers on unmount\r\n  useEffect(() => {\r\n    return () => {\r\n      timersRef.current.forEach(timer => clearTimeout(timer));\r\n      timersRef.current.clear();\r\n    };\r\n  }, []);\r\n\r\n  const value: ToastContextType = {\r\n    toasts,\r\n    showToast,\r\n    updateToast,\r\n    removeToast,\r\n    clearToasts,\r\n    success,\r\n    error,\r\n    info,\r\n    warning,\r\n    loading,\r\n    promise,\r\n  };\r\n\r\n  return (\r\n    <ToastContext.Provider value={value}>\r\n      {children}\r\n      <ToastContainer />\r\n    </ToastContext.Provider>\r\n  );\r\n}\r\n\r\n// Toast Container Component\r\nfunction ToastContainer() {\r\n  const context = useContext(ToastContext);\r\n  if (!context) return null;\r\n\r\n  const { toasts, removeToast } = context;\r\n\r\n  return (\r\n    <div className=\"fixed top-4 right-4 z-50 pointer-events-none\">\r\n      <AnimatePresence mode=\"popLayout\">\r\n        {toasts.map(toast => (\r\n          <ToastItem\r\n            key={toast.id}\r\n            toast={toast}\r\n            onRemove={() => removeToast(toast.id)}\r\n          />\r\n        ))}\r\n      </AnimatePresence>\r\n    </div>\r\n  );\r\n}\r\n\r\n// Individual Toast Component\r\nfunction ToastItem({ toast, onRemove }: { toast: Toast; onRemove: () => void }) {\r\n  const Icon = TOAST_ICONS[toast.type];\r\n  const colors = TOAST_COLORS[toast.type];\r\n\r\n  return (\r\n    <motion.div\r\n      initial={{ opacity: 0, y: -20, scale: 0.95 }}\r\n      animate={{ opacity: 1, y: 0, scale: 1 }}\r\n      exit={{ opacity: 0, scale: 0.95 }}\r\n      transition={{ duration: 0.2 }}\r\n      className=\"pointer-events-auto mb-3\"\r\n    >\r\n      <div className={`\r\n        ${colors.bg} ${colors.border}\r\n        border rounded-lg shadow-lg p-4\r\n        max-w-sm min-w-[300px]\r\n        backdrop-blur-sm\r\n      `}>\r\n        <div className=\"flex items-start gap-3\">\r\n          <Icon className={`w-5 h-5 ${colors.icon} flex-shrink-0 ${\r\n            toast.type === 'loading' ? 'animate-spin' : ''\r\n          }`} />\r\n          \r\n          <div className=\"flex-1\">\r\n            <h3 className=\"text-sm font-semibold text-white\">\r\n              {toast.title}\r\n            </h3>\r\n            {toast.message && (\r\n              <p className=\"text-xs text-gray-400 mt-1\">\r\n                {toast.message}\r\n              </p>\r\n            )}\r\n            {toast.action && (\r\n              <button\r\n                onClick={toast.action.onClick}\r\n                className=\"text-xs text-[#ff950e] hover:text-[#ff7a00] mt-2 font-medium\"\r\n              >\r\n                {toast.action.label}\r\n              </button>\r\n            )}\r\n          </div>\r\n          \r\n          {toast.dismissible && (\r\n            <button\r\n              onClick={onRemove}\r\n              className=\"text-gray-400 hover:text-white transition-colors\"\r\n            >\r\n              <X className=\"w-4 h-4\" />\r\n            </button>\r\n          )}\r\n        </div>\r\n      </div>\r\n    </motion.div>\r\n  );\r\n}\r\n\r\n// Hook to use toast\r\nexport function useToast() {\r\n  const context = useContext(ToastContext);\r\n  if (!context) {\r\n    throw new Error('useToast must be used within a ToastProvider');\r\n  }\r\n  return context;\r\n}\r\n\r\n// Helper function for API errors\r\nexport function toastApiError(error: any, fallbackMessage = 'An error occurred') {\r\n  const context = useContext(ToastContext);\r\n  if (!context) return;\r\n\r\n  let message = fallbackMessage;\r\n  \r\n  if (error?.response?.data?.error?.message) {\r\n    message = error.response.data.error.message;\r\n  } else if (error?.message) {\r\n    message = error.message;\r\n  }\r\n\r\n  context.error('Error', message);\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 878, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/gerom/OneDrive/Documents/pantypost/src/context/BanContext.tsx"],"sourcesContent":["'use client';\r\n\r\nimport {\r\n  createContext,\r\n  useContext,\r\n  useState,\r\n  useEffect,\r\n  ReactNode,\r\n  useCallback,\r\n  useRef,\r\n} from 'react';\r\nimport { storageService } from '@/services';\r\nimport { banService } from '@/services/ban.service';\r\nimport { usersService } from '@/services/users.service';\r\nimport { sanitizeStrict, sanitizeUsername } from '@/utils/security/sanitization';\r\nimport { z } from 'zod';\r\nimport { useAuth } from './AuthContext';\r\nimport { isAdmin } from '@/utils/security/permissions';\r\n\r\n// ================== Types ==================\r\nexport type BanType = 'temporary' | 'permanent';\r\nexport type BanReason =\r\n  | 'harassment'\r\n  | 'spam'\r\n  | 'inappropriate_content'\r\n  | 'scam'\r\n  | 'underage'\r\n  | 'payment_fraud'\r\n  | 'other';\r\nexport type AppealStatus = 'pending' | 'under_review' | 'approved' | 'rejected' | 'escalated';\r\n\r\nexport type UserBan = {\r\n  id: string;\r\n  username: string;\r\n  banType: BanType;\r\n  reason: BanReason;\r\n  customReason?: string;\r\n  startTime: string; // ISO\r\n  endTime?: string; // ISO for temporary\r\n  remainingHours?: number; // derived\r\n  bannedBy: string; // admin username\r\n  active: boolean;\r\n  appealable: boolean;\r\n  appealSubmitted?: boolean;\r\n  appealText?: string;\r\n  appealDate?: string;\r\n  appealStatus?: AppealStatus;\r\n  appealEvidence?: string[]; // base64 images\r\n  notes?: string;\r\n  reportIds?: string[];\r\n  ipAddress?: string;\r\n  expirationTimer?: ReturnType<typeof setTimeout>;\r\n};\r\n\r\nexport type BanHistory = {\r\n  id: string;\r\n  username: string;\r\n  action:\r\n    | 'banned'\r\n    | 'unbanned'\r\n    | 'appeal_submitted'\r\n    | 'appeal_approved'\r\n    | 'appeal_rejected'\r\n    | 'appeal_escalated';\r\n  details: string;\r\n  timestamp: string;\r\n  adminUsername: string;\r\n  metadata?: Record<string, any>;\r\n};\r\n\r\nexport type AppealReview = {\r\n  reviewId: string;\r\n  banId: string;\r\n  reviewerAdmin: string;\r\n  reviewNotes: string;\r\n  decision: 'approve' | 'reject' | 'escalate';\r\n  reviewDate: string;\r\n  escalationReason?: string;\r\n};\r\n\r\nexport type IPBan = {\r\n  ipAddress: string;\r\n  bannedUsernames: string[];\r\n  banDate: string;\r\n  expiryDate?: string;\r\n  reason: string;\r\n};\r\n\r\n// ================== Constants ==================\r\nconst STORAGE_KEYS = {\r\n  BANS: 'panty_user_bans',\r\n  HISTORY: 'panty_ban_history',\r\n  REVIEWS: 'panty_appeal_reviews',\r\n  IP_BANS: 'panty_ip_bans',\r\n} as const;\r\n\r\n/**\r\n * Reserved usernames that should never be bannable (system/service accounts).\r\n * NOTE: Not human admins; real admin checks use role via isAdmin(user).\r\n */\r\nconst RESERVED_USERNAMES = ['system', 'platform', 'admin', 'administrator', 'moderator', 'mod'] as const;\r\n\r\n/** Exact-match, case-insensitive protection for reserved accounts */\r\nconst isProtectedUsername = (username: string): boolean => {\r\n  const clean = (username || '').toLowerCase().trim();\r\n  return RESERVED_USERNAMES.includes(clean as (typeof RESERVED_USERNAMES)[number]);\r\n};\r\n\r\n// Ask backend for role (defensive, in case caller doesn’t pass role)\r\nconst checkUserRole = async (\r\n  username: string\r\n): Promise<'buyer' | 'seller' | 'admin' | null> => {\r\n  try {\r\n    const result = await usersService.getUser(username);\r\n    if (result.success && result.data?.role) return result.data.role;\r\n    return null;\r\n  } catch (err) {\r\n    console.error('[BanContext] Error checking user role:', err);\r\n    return null;\r\n  }\r\n};\r\n\r\ntype BanContextType = {\r\n  bans: UserBan[];\r\n  banHistory: BanHistory[];\r\n  appealReviews: AppealReview[];\r\n  ipBans: IPBan[];\r\n\r\n  // Enhanced ban management\r\n  banUser: (\r\n    username: string,\r\n    hours: number | 'permanent',\r\n    reason: BanReason,\r\n    customReason?: string,\r\n    adminUsername?: string,\r\n    reportIds?: string[],\r\n    notes?: string,\r\n    targetUserRole?: 'buyer' | 'seller' | 'admin'\r\n  ) => Promise<boolean>;\r\n  unbanUser: (username: string, adminUsername?: string, reason?: string) => Promise<boolean>;\r\n  isUserBanned: (username: string) => UserBan | null;\r\n  getBanInfo: (username: string) => UserBan | null;\r\n\r\n  // Ban queries\r\n  getActiveBans: () => UserBan[];\r\n  getExpiredBans: () => UserBan[];\r\n  getUserBanHistory: (username: string) => UserBan[];\r\n\r\n  // Appeals\r\n  submitAppeal: (username: string, appealText: string, evidence?: File[]) => Promise<boolean>;\r\n  reviewAppeal: (\r\n    banId: string,\r\n    decision: 'approve' | 'reject' | 'escalate',\r\n    reviewNotes: string,\r\n    adminUsername: string\r\n  ) => boolean;\r\n  approveAppeal: (banId: string, adminUsername: string) => boolean;\r\n  rejectAppeal: (banId: string, adminUsername: string, reason?: string) => boolean;\r\n  escalateAppeal: (banId: string, adminUsername: string, escalationReason: string) => boolean;\r\n\r\n  // IP management\r\n  banUserIP: (username: string, ipAddress: string, reason: string) => boolean;\r\n  isIPBanned: (ipAddress: string) => boolean;\r\n\r\n  // Utilities\r\n  updateExpiredBans: () => void;\r\n  scheduleExpiration: (ban: UserBan) => void;\r\n  clearExpirationTimer: (banId: string) => void;\r\n  getBanStats: () => {\r\n    totalActiveBans: number;\r\n    temporaryBans: number;\r\n    permanentBans: number;\r\n    pendingAppeals: number;\r\n    recentBans24h: number;\r\n    bansByReason: Record<BanReason, number>;\r\n    appealStats: {\r\n      totalAppeals: number;\r\n      pendingAppeals: number;\r\n      approvedAppeals: number;\r\n      rejectedAppeals: number;\r\n    };\r\n  };\r\n\r\n  // Validation\r\n  validateBanInput: (\r\n    username: string,\r\n    hours: number | 'permanent',\r\n    reason: BanReason,\r\n    targetUserRole?: 'buyer' | 'seller' | 'admin'\r\n  ) => Promise<{ valid: boolean; error?: string }>;\r\n\r\n  // Force refresh\r\n  refreshBanData: () => Promise<void>;\r\n};\r\n\r\nconst BanContext = createContext<BanContextType | undefined>(undefined);\r\n\r\n// ================== Validation Schemas ==================\r\nconst banReasonSchema = z.enum([\r\n  'harassment',\r\n  'spam',\r\n  'inappropriate_content',\r\n  'scam',\r\n  'underage',\r\n  'payment_fraud',\r\n  'other',\r\n]);\r\n\r\nconst banDurationSchema = z.union([z.literal('permanent'), z.number().positive().max(8760)]);\r\nconst appealTextSchema = z.string().min(10).max(1000);\r\nconst customReasonSchema = z.string().min(5).max(500);\r\nconst banNotesSchema = z.string().max(1000);\r\n\r\n// Simple IPv4, conservative; adjust if you need IPv6\r\nconst ipAddressSchema = z.string().regex(/^(?:\\d{1,3}\\.){3}\\d{1,3}$/);\r\n\r\n// ---- Conservative mock data detector/scrubber ----\r\nconst isMockString = (val?: string) => {\r\n  if (!val) return false;\r\n  const v = String(val).trim().toLowerCase();\r\n  const patterns = [\r\n    'spammer',\r\n    'scammer',\r\n    'troublemaker',\r\n    'oldbanner',\r\n    'mock',\r\n    'sample',\r\n    'demo',\r\n    'test',\r\n    'lorem',\r\n    'ipsum',\r\n    'john_doe',\r\n    'jane_doe',\r\n  ];\r\n  return patterns.some((p) => v.includes(p));\r\n};\r\n\r\nconst isMockBan = (b: UserBan) => {\r\n  return (\r\n    isMockString(b.username) ||\r\n    isMockString(b.bannedBy) ||\r\n    isMockString(b.customReason) ||\r\n    isMockString(b.notes) ||\r\n    (b.id && (b.id.startsWith('mock_') || b.id.includes('sample') || b.id.includes('test')))\r\n  );\r\n};\r\n\r\nconst isMockHistory = (h: BanHistory) => {\r\n  return (\r\n    isMockString(h.username) ||\r\n    isMockString(h.details) ||\r\n    isMockString(h.adminUsername) ||\r\n    (h.id && (h.id.startsWith('mock_') || h.id.includes('sample') || h.id.includes('test')))\r\n  );\r\n};\r\n\r\nconst scrubMocks = async (\r\n  bans: UserBan[],\r\n  history: BanHistory[],\r\n  reviews: AppealReview[],\r\n  ipBans: IPBan[]\r\n) => {\r\n  const cleanBans = bans.filter((b) => !isMockBan(b));\r\n  const cleanHistory = history.filter((h) => !isMockHistory(h));\r\n  const cleanReviews = reviews.filter(\r\n    (r) =>\r\n      !(\r\n        r.reviewId?.startsWith?.('mock_') ||\r\n        isMockString(r.reviewerAdmin) ||\r\n        isMockString(r.reviewNotes)\r\n      )\r\n  );\r\n  const cleanIPBans = ipBans.filter((ip) => !(ip.ipAddress?.startsWith?.('0.0.0') || isMockString(ip.reason)));\r\n\r\n  const removed = {\r\n    bans: bans.length - cleanBans.length,\r\n    history: history.length - cleanHistory.length,\r\n    reviews: reviews.length - cleanReviews.length,\r\n    ipBans: ipBans.length - cleanIPBans.length,\r\n  };\r\n\r\n  if (removed.bans || removed.history || removed.reviews || removed.ipBans) {\r\n    console.warn('[BanContext] Removed mock/dev data from storage:', removed);\r\n    await storageService.setItem(STORAGE_KEYS.BANS, cleanBans);\r\n    await storageService.setItem(STORAGE_KEYS.HISTORY, cleanHistory);\r\n    await storageService.setItem(STORAGE_KEYS.REVIEWS, cleanReviews);\r\n    await storageService.setItem(STORAGE_KEYS.IP_BANS, cleanIPBans);\r\n  }\r\n\r\n  return { cleanBans, cleanHistory, cleanReviews, cleanIPBans };\r\n};\r\n// --------------------------------------------------\r\n\r\n// Image compression for appeal evidence (defensive checks)\r\nconst compressImage = (file: File): Promise<string> =>\r\n  new Promise((resolve, reject) => {\r\n    try {\r\n      if (!file || !file.type.startsWith('image/')) {\r\n        return reject(new Error('Invalid file type'));\r\n      }\r\n      // Limit ~5MB files to avoid memory issues\r\n      if (typeof file.size === 'number' && file.size > 5 * 1024 * 1024) {\r\n        console.warn('[BanContext] Evidence file is large; compressing aggressively');\r\n      }\r\n\r\n      const reader = new FileReader();\r\n      reader.onload = (event) => {\r\n        const img = new Image();\r\n        img.onload = () => {\r\n          const canvas = document.createElement('canvas');\r\n          const ctx = canvas.getContext('2d');\r\n          const maxDimension = 800;\r\n          let { width, height } = img;\r\n\r\n          if (width > height) {\r\n            if (width > maxDimension) {\r\n              height = (height * maxDimension) / width;\r\n              width = maxDimension;\r\n            }\r\n          } else {\r\n            if (height > maxDimension) {\r\n              width = (width * maxDimension) / height;\r\n              height = maxDimension;\r\n            }\r\n          }\r\n\r\n          canvas.width = width;\r\n          canvas.height = height;\r\n          ctx?.drawImage(img, 0, 0, width, height);\r\n          resolve(canvas.toDataURL('image/jpeg', 0.7));\r\n        };\r\n        img.onerror = () => reject(new Error('Image load failed'));\r\n        img.src = event.target?.result as string;\r\n      };\r\n      reader.onerror = () => reject(new Error('File read failed'));\r\n      reader.readAsDataURL(file);\r\n    } catch (e) {\r\n      reject(e);\r\n    }\r\n  });\r\n\r\n// ================== Provider ==================\r\nexport const BanProvider: React.FC<{ children: ReactNode }> = ({ children }) => {\r\n  const [bans, setBans] = useState<UserBan[]>([]);\r\n  const [banHistory, setBanHistory] = useState<BanHistory[]>([]);\r\n  const [appealReviews, setAppealReviews] = useState<AppealReview[]>([]);\r\n  const [ipBans, setIPBans] = useState<IPBan[]>([]);\r\n  const [isInitialized, setIsInitialized] = useState(false);\r\n\r\n  const { user } = useAuth();\r\n\r\n  // Track active timers to prevent leaks\r\n  const activeTimers = useRef<Map<string, ReturnType<typeof setTimeout>>>(new Map());\r\n\r\n  // Saving guard\r\n  const isSavingRef = useRef(false);\r\n\r\n  // Dev override to allow non-admin actions locally when explicitly enabled\r\n  const canAdminAct = useCallback(\r\n    (action: string): boolean => {\r\n      const devBypass = process.env.NEXT_PUBLIC_ALLOW_LOCAL_BAN === '1';\r\n      if (devBypass && user) {\r\n        console.warn(`[BanContext] Dev override enabled for action: ${action} by ${user.username}`);\r\n        return true;\r\n      }\r\n      return !!(user && isAdmin(user));\r\n    },\r\n    [user]\r\n  );\r\n\r\n  // Force refresh function\r\n  const refreshBanData = useCallback(async () => {\r\n    console.log('[BanContext] Force refreshing ban data...');\r\n    setIsInitialized(false);\r\n    await loadData(true);\r\n  }, []);\r\n\r\n  // Load from storage using service\r\n  const loadData = useCallback(\r\n    async (forceRefresh = false) => {\r\n      if (typeof window === 'undefined') return;\r\n      if (isInitialized && !forceRefresh) return;\r\n\r\n      try {\r\n        console.log('[BanContext] Loading ban data...', { forceRefresh });\r\n\r\n        const storedBans = await storageService.getItem<UserBan[]>(STORAGE_KEYS.BANS, []);\r\n        const storedHistory = await storageService.getItem<BanHistory[]>(STORAGE_KEYS.HISTORY, []);\r\n        const storedAppealReviews = await storageService.getItem<AppealReview[]>(\r\n          STORAGE_KEYS.REVIEWS,\r\n          []\r\n        );\r\n        const storedIPBans = await storageService.getItem<IPBan[]>(STORAGE_KEYS.IP_BANS, []);\r\n\r\n        // Scrub any clear mock remnants\r\n        const { cleanBans, cleanHistory, cleanReviews, cleanIPBans } = await scrubMocks(\r\n          storedBans || [],\r\n          storedHistory || [],\r\n          storedAppealReviews || [],\r\n          storedIPBans || []\r\n        );\r\n\r\n        // Auto-expire any temporary bans already past endTime\r\n        const now = new Date();\r\n        const updatedBans = cleanBans.map((ban) => {\r\n          if (ban.active && ban.banType === 'temporary' && ban.endTime) {\r\n            if (now >= new Date(ban.endTime)) {\r\n              console.log(`[BanContext] Auto-expiring ban for ${ban.username}`);\r\n              return { ...ban, active: false };\r\n            }\r\n          }\r\n          return ban;\r\n        });\r\n\r\n        setBans(updatedBans);\r\n        setBanHistory(cleanHistory);\r\n        setAppealReviews(cleanReviews);\r\n        setIPBans(cleanIPBans);\r\n\r\n        // Persist only if any changed\r\n        const anyExpiredChanged =\r\n          updatedBans.length === cleanBans.length &&\r\n          updatedBans.some((b, i) => b.active !== cleanBans[i]?.active);\r\n        if (anyExpiredChanged) {\r\n          isSavingRef.current = true;\r\n          await storageService.setItem(STORAGE_KEYS.BANS, updatedBans);\r\n          isSavingRef.current = false;\r\n        }\r\n\r\n        // Schedule expiration for active temporary bans\r\n        updatedBans.forEach((ban) => {\r\n          if (ban.active && ban.banType === 'temporary' && ban.endTime) {\r\n            scheduleExpiration(ban);\r\n          }\r\n        });\r\n\r\n        console.log('[BanContext] Data loaded:', {\r\n          activeBans: updatedBans.filter((b) => b.active).length,\r\n          totalBans: updatedBans.length,\r\n        });\r\n\r\n        setIsInitialized(true);\r\n      } catch (error) {\r\n        console.error('[BanContext] Error loading ban data:', error);\r\n        setIsInitialized(true);\r\n      }\r\n    },\r\n    [isInitialized]\r\n  );\r\n\r\n  useEffect(() => {\r\n    loadData();\r\n  }, [loadData]);\r\n\r\n  // Persistors (guarded to avoid loops)\r\n  useEffect(() => {\r\n    if (typeof window !== 'undefined' && isInitialized && !isSavingRef.current) {\r\n      isSavingRef.current = true;\r\n      storageService.setItem(STORAGE_KEYS.BANS, bans).finally(() => {\r\n        isSavingRef.current = false;\r\n      });\r\n    }\r\n  }, [bans, isInitialized]);\r\n\r\n  useEffect(() => {\r\n    if (typeof window !== 'undefined' && isInitialized && !isSavingRef.current) {\r\n      storageService.setItem(STORAGE_KEYS.HISTORY, banHistory);\r\n    }\r\n  }, [banHistory, isInitialized]);\r\n\r\n  useEffect(() => {\r\n    if (typeof window !== 'undefined' && isInitialized && !isSavingRef.current) {\r\n      storageService.setItem(STORAGE_KEYS.REVIEWS, appealReviews);\r\n    }\r\n  }, [appealReviews, isInitialized]);\r\n\r\n  useEffect(() => {\r\n    if (typeof window !== 'undefined' && isInitialized && !isSavingRef.current) {\r\n      storageService.setItem(STORAGE_KEYS.IP_BANS, ipBans);\r\n    }\r\n  }, [ipBans, isInitialized]);\r\n\r\n  // Cleanup timers on unmount\r\n  useEffect(() => {\r\n    return () => {\r\n      activeTimers.current.forEach((t) => clearTimeout(t));\r\n      activeTimers.current.clear();\r\n    };\r\n  }, []);\r\n\r\n  // ---------- Validation (async because we may look up role) ----------\r\n  const validateBanInput = useCallback(\r\n    async (\r\n      username: string,\r\n      hours: number | 'permanent',\r\n      reason: BanReason,\r\n      targetUserRole?: 'buyer' | 'seller' | 'admin'\r\n    ): Promise<{ valid: boolean; error?: string }> => {\r\n      const sanitized = sanitizeUsername(username);\r\n      if (!sanitized) return { valid: false, error: 'Invalid username format' };\r\n\r\n      // Avoid banning reserved/system accounts\r\n      if (isProtectedUsername(sanitized)) {\r\n        return { valid: false, error: 'This account is protected and cannot be banned' };\r\n      }\r\n\r\n      // Block admins\r\n      if (targetUserRole === 'admin') {\r\n        return { valid: false, error: 'Admin accounts cannot be banned' };\r\n      }\r\n      if (!targetUserRole) {\r\n        const role = await checkUserRole(sanitized);\r\n        if (role === 'admin') return { valid: false, error: 'Admin accounts cannot be banned' };\r\n      }\r\n\r\n      const dur = banDurationSchema.safeParse(hours);\r\n      if (!dur.success) return { valid: false, error: 'Invalid ban duration (max 1 year)' };\r\n\r\n      const reasonOk = banReasonSchema.safeParse(reason);\r\n      if (!reasonOk.success) return { valid: false, error: 'Invalid ban reason' };\r\n\r\n      return { valid: true };\r\n    },\r\n    []\r\n  );\r\n\r\n  // ---------- History helper ----------\r\n  const addBanHistory = useCallback(\r\n    (\r\n      action: BanHistory['action'],\r\n      username: string,\r\n      details: string,\r\n      adminUsername: string,\r\n      metadata?: Record<string, any>\r\n    ) => {\r\n      const historyEntry: BanHistory = {\r\n        id: Date.now().toString() + Math.random().toString(36).slice(2, 11),\r\n        username: sanitizeUsername(username) || username,\r\n        action,\r\n        details: sanitizeStrict(details),\r\n        timestamp: new Date().toISOString(),\r\n        adminUsername: sanitizeUsername(adminUsername) || adminUsername,\r\n        metadata,\r\n      };\r\n      setBanHistory((prev) => [...prev, historyEntry]);\r\n    },\r\n    []\r\n  );\r\n\r\n  // ---------- Unban first (used by scheduler) ----------\r\n  const clearExpirationTimer = useCallback((banId: string) => {\r\n    const t = activeTimers.current.get(banId);\r\n    if (t) {\r\n      clearTimeout(t);\r\n      activeTimers.current.delete(banId);\r\n    }\r\n  }, []);\r\n\r\n  const unbanUser = useCallback(\r\n    async (username: string, adminUsername?: string, reason?: string): Promise<boolean> => {\r\n      // Admin-only\r\n      if (!canAdminAct('unban')) {\r\n        console.warn('[BanContext] Unban blocked: admin privileges required');\r\n        return false;\r\n      }\r\n\r\n      try {\r\n        const cleanUsername = sanitizeUsername(username) || username;\r\n        const cleanAdmin = sanitizeUsername(adminUsername || user?.username || 'system')!;\r\n        const cleanReason = reason ? sanitizeStrict(reason) : 'Ban lifted by admin';\r\n\r\n        const banToUnban = bans.find((b) => b.username === cleanUsername && b.active);\r\n        if (!banToUnban) {\r\n          console.warn('[BanContext] No active ban found for', cleanUsername);\r\n          return false;\r\n        }\r\n\r\n        // stop any scheduled expiration\r\n        clearExpirationTimer(banToUnban.id);\r\n\r\n        const updated = bans.map((b) => (b.id === banToUnban.id ? { ...b, active: false } : b));\r\n\r\n        // Persist first to avoid race\r\n        isSavingRef.current = true;\r\n        await storageService.setItem(STORAGE_KEYS.BANS, updated);\r\n        isSavingRef.current = false;\r\n\r\n        setBans(updated);\r\n        addBanHistory('unbanned', cleanUsername, cleanReason, cleanAdmin);\r\n\r\n        // UI event\r\n        if (typeof window !== 'undefined') {\r\n          window.dispatchEvent(\r\n            new CustomEvent('banUpdated', {\r\n              detail: { banId: banToUnban.id, username: cleanUsername, action: 'unbanned' },\r\n            })\r\n          );\r\n        }\r\n\r\n        console.log('[BanContext] User unbanned:', cleanUsername);\r\n        return true;\r\n      } catch (err) {\r\n        console.error('[BanContext] Error unbanning user:', err);\r\n        isSavingRef.current = false;\r\n        return false;\r\n      }\r\n    },\r\n    [bans, addBanHistory, clearExpirationTimer, canAdminAct, user?.username]\r\n  );\r\n\r\n  // ---------- Scheduler ----------\r\n  const scheduleExpiration = useCallback(\r\n    (ban: UserBan) => {\r\n      if (ban.banType === 'permanent' || !ban.endTime || !ban.active) return;\r\n\r\n      const ms = new Date(ban.endTime).getTime() - Date.now();\r\n      if (ms <= 0) return;\r\n\r\n      console.log(\r\n        `[BanContext] Scheduling expiration for ${ban.username} in ~${Math.round(\r\n          ms / 60000\r\n        )} minutes`\r\n      );\r\n\r\n      const t = setTimeout(async () => {\r\n        console.log(`[BanContext] Auto-expiring ban for ${ban.username}`);\r\n        await unbanUser(ban.username, 'system', 'Automatic expiration');\r\n\r\n        if (typeof window !== 'undefined') {\r\n          window.dispatchEvent(\r\n            new CustomEvent('banExpired', { detail: { banId: ban.id, username: ban.username } })\r\n          );\r\n        }\r\n\r\n        activeTimers.current.delete(ban.id);\r\n      }, ms);\r\n\r\n      activeTimers.current.set(ban.id, t);\r\n    },\r\n    [unbanUser]\r\n  );\r\n\r\n  // ---------- Ban user ----------\r\n  const banUser = useCallback(\r\n    async (\r\n      username: string,\r\n      hours: number | 'permanent',\r\n      reason: BanReason,\r\n      customReason?: string,\r\n      adminUsername?: string,\r\n      reportIds: string[] = [],\r\n      notes?: string,\r\n      targetUserRole?: 'buyer' | 'seller' | 'admin'\r\n    ): Promise<boolean> => {\r\n      // Admin-only\r\n      if (!canAdminAct('ban')) {\r\n        console.warn('[BanContext] Ban blocked: admin privileges required');\r\n        if (typeof window !== 'undefined') {\r\n          alert('Only admins can ban users.');\r\n        }\r\n        return false;\r\n      }\r\n\r\n      console.log('[BanContext] Attempting to ban user:', {\r\n        username,\r\n        hours,\r\n        reason,\r\n        targetUserRole,\r\n      });\r\n\r\n      const validation = await validateBanInput(username, hours, reason, targetUserRole);\r\n      if (!validation.valid) {\r\n        console.error('[BanContext] Ban validation failed:', validation.error);\r\n        if (\r\n          validation.error === 'Admin accounts cannot be banned' ||\r\n          validation.error === 'This account is protected and cannot be banned'\r\n        ) {\r\n          if (typeof window !== 'undefined') alert(validation.error);\r\n        }\r\n        return false;\r\n      }\r\n\r\n      // Sanitize inputs\r\n      const cleanUsername = sanitizeUsername(username) || username;\r\n      const cleanAdmin = sanitizeUsername(adminUsername || user?.username || 'system')!;\r\n      const cleanNotes = notes ? sanitizeStrict(notes) : undefined;\r\n\r\n      let cleanCustomReason: string | undefined;\r\n      if (customReason) {\r\n        const cr = customReasonSchema.safeParse(customReason);\r\n        if (!cr.success) {\r\n          console.error('[BanContext] Custom reason too short/long');\r\n          return false;\r\n        }\r\n        cleanCustomReason = sanitizeStrict(cr.data);\r\n      }\r\n\r\n      // Lock to avoid duplicate bans\r\n      const lockKey = `ban_user_${cleanUsername}`;\r\n      const existingLock = await storageService.getItem<any>(lockKey, null);\r\n      if (existingLock) {\r\n        try {\r\n          const age = Date.now() - (existingLock.timestamp || 0);\r\n          if (age < 30_000) {\r\n            console.warn(`[BanContext] Ban already in progress for ${cleanUsername}`);\r\n            return false;\r\n          }\r\n        } catch {\r\n          // ignore bad lock\r\n        }\r\n      }\r\n      await storageService.setItem(lockKey, {\r\n        timestamp: Date.now(),\r\n        adminUser: cleanAdmin,\r\n      });\r\n\r\n      try {\r\n        // Already banned?\r\n        const already = bans.find((b) => b.username === cleanUsername && b.active);\r\n        if (already) {\r\n          console.warn(`[BanContext] ${cleanUsername} is already banned`);\r\n          return false;\r\n        }\r\n\r\n        // Save to DB (best-effort)\r\n        const apiResponse = await banService.createBan({\r\n          username: cleanUsername,\r\n          reason: cleanCustomReason || reason,\r\n          customReason: cleanCustomReason,\r\n          duration: hours,\r\n          notes: cleanNotes,\r\n          relatedReportIds: reportIds,\r\n          bannedBy: cleanAdmin,\r\n        });\r\n        if (!apiResponse.success) {\r\n          console.warn('[BanContext] MongoDB save failed; continuing with local cache', apiResponse.error);\r\n        }\r\n\r\n        const now = new Date();\r\n        const banId = Date.now().toString() + Math.random().toString(36).slice(2, 11);\r\n        const end =\r\n          hours === 'permanent'\r\n            ? undefined\r\n            : new Date(now.getTime() + (hours as number) * 60 * 60 * 1000).toISOString();\r\n\r\n        const newBan: UserBan = {\r\n          id: banId,\r\n          username: cleanUsername,\r\n          banType: hours === 'permanent' ? 'permanent' : 'temporary',\r\n          reason,\r\n          customReason: cleanCustomReason,\r\n          startTime: now.toISOString(),\r\n          endTime: end,\r\n          remainingHours: hours === 'permanent' ? undefined : (hours as number),\r\n          bannedBy: cleanAdmin,\r\n          active: true,\r\n          appealable: true,\r\n          notes: cleanNotes,\r\n          reportIds: reportIds,\r\n          appealStatus: undefined,\r\n        };\r\n\r\n        setBans((prev) => [...prev, newBan]);\r\n\r\n        if (newBan.banType === 'temporary' && newBan.endTime) {\r\n          scheduleExpiration(newBan);\r\n        }\r\n\r\n        const durationText = hours === 'permanent' ? 'permanently' : `for ${hours} hours`;\r\n        addBanHistory(\r\n          'banned',\r\n          cleanUsername,\r\n          `Banned ${durationText} for ${reason}${cleanCustomReason ? `: ${cleanCustomReason}` : ''}`,\r\n          cleanAdmin,\r\n          { banId, mongoSaved: apiResponse.success }\r\n        );\r\n\r\n        console.log('[BanContext] Ban created successfully', { mongoSaved: apiResponse.success });\r\n        return true;\r\n      } catch (error) {\r\n        console.error('[BanContext] Error banning user:', error);\r\n        return false;\r\n      } finally {\r\n        await storageService.removeItem(lockKey);\r\n      }\r\n    },\r\n    [bans, addBanHistory, scheduleExpiration, validateBanInput, canAdminAct, user?.username]\r\n  );\r\n\r\n  // ---------- Appeals ----------\r\n  const submitAppeal = useCallback(\r\n    async (username: string, appealText: string, evidence?: File[]): Promise<boolean> => {\r\n      try {\r\n        // Allow the banned user themselves OR an admin acting on their behalf\r\n        const requester = user?.username;\r\n        const isSelf = requester && sanitizeUsername(requester) === sanitizeUsername(username);\r\n        if (!isSelf && !canAdminAct('submitAppeal')) {\r\n          console.warn('[BanContext] Appeal submission blocked: not the user or admin');\r\n          return false;\r\n        }\r\n\r\n        const cleanUsername = sanitizeUsername(username) || username;\r\n        const appealValidation = appealTextSchema.safeParse(appealText);\r\n        if (!appealValidation.success) {\r\n          console.error('[BanContext] Invalid appeal text:', appealValidation.error);\r\n          return false;\r\n        }\r\n        const cleanAppealText = sanitizeStrict(appealValidation.data);\r\n\r\n        let appealEvidence: string[] = [];\r\n        if (evidence && evidence.length > 0) {\r\n          try {\r\n            // Only first 3 images\r\n            const trimmed = evidence.slice(0, 3);\r\n            appealEvidence = await Promise.all(trimmed.map((f) => compressImage(f)));\r\n          } catch (err) {\r\n            console.error('[BanContext] Evidence processing failed:', err);\r\n          }\r\n        }\r\n\r\n        setBans((prev) =>\r\n          prev.map((ban) =>\r\n            ban.username === cleanUsername && ban.active && ban.appealable\r\n              ? {\r\n                  ...ban,\r\n                  appealSubmitted: true,\r\n                  appealText: cleanAppealText,\r\n                  appealDate: new Date().toISOString(),\r\n                  appealStatus: 'pending' as AppealStatus,\r\n                  appealEvidence,\r\n                }\r\n              : ban\r\n          )\r\n        );\r\n\r\n        addBanHistory(\r\n          'appeal_submitted',\r\n          cleanUsername,\r\n          `Appeal submitted: \"${cleanAppealText.substring(0, 100)}${\r\n            cleanAppealText.length > 100 ? '...' : ''\r\n          }\"`,\r\n          cleanUsername,\r\n          { evidenceCount: appealEvidence.length }\r\n        );\r\n\r\n        return true;\r\n      } catch (err) {\r\n        console.error('[BanContext] Error submitting appeal:', err);\r\n        return false;\r\n      }\r\n    },\r\n    [addBanHistory, canAdminAct, user?.username]\r\n  );\r\n\r\n  const reviewAppeal = useCallback(\r\n    (\r\n      banId: string,\r\n      decision: 'approve' | 'reject' | 'escalate',\r\n      reviewNotes: string,\r\n      adminUsername: string\r\n    ): boolean => {\r\n      // Admin-only\r\n      if (!canAdminAct('reviewAppeal')) {\r\n        console.warn('[BanContext] Review appeal blocked: admin privileges required');\r\n        return false;\r\n      }\r\n\r\n      try {\r\n        const cleanNotes = sanitizeStrict(reviewNotes);\r\n        const cleanAdmin = sanitizeUsername(adminUsername || user?.username || 'system')!;\r\n\r\n        const review: AppealReview = {\r\n          reviewId: Date.now().toString() + Math.random().toString(36).slice(2, 11),\r\n          banId,\r\n          reviewerAdmin: cleanAdmin,\r\n          reviewNotes: cleanNotes,\r\n          decision,\r\n          reviewDate: new Date().toISOString(),\r\n          escalationReason: decision === 'escalate' ? cleanNotes : undefined,\r\n        };\r\n\r\n        setAppealReviews((prev) => [...prev, review]);\r\n\r\n        const ban = bans.find((b) => b.id === banId);\r\n        if (!ban) return false;\r\n\r\n        if (decision === 'approve') return approveAppeal(banId, cleanAdmin);\r\n        if (decision === 'reject') return rejectAppeal(banId, cleanAdmin, cleanNotes);\r\n        if (decision === 'escalate') return escalateAppeal(banId, cleanAdmin, cleanNotes);\r\n\r\n        return true;\r\n      } catch (err) {\r\n        console.error('[BanContext] Error reviewing appeal:', err);\r\n        return false;\r\n      }\r\n    },\r\n    [bans, canAdminAct, user?.username]\r\n  );\r\n\r\n  const approveAppeal = useCallback(\r\n    (banId: string, adminUsername: string): boolean => {\r\n      // Admin-only\r\n      if (!canAdminAct('approveAppeal')) return false;\r\n\r\n      try {\r\n        const ban = bans.find((b) => b.id === banId);\r\n        if (!ban) return false;\r\n\r\n        setBans((prev) =>\r\n          prev.map((b) => (b.id === banId ? { ...b, active: false, appealStatus: 'approved' } : b))\r\n        );\r\n\r\n        clearExpirationTimer(banId);\r\n        addBanHistory('appeal_approved', ban.username, 'Appeal approved and ban lifted', adminUsername);\r\n        return true;\r\n      } catch (err) {\r\n        console.error('[BanContext] Error approving appeal:', err);\r\n        return false;\r\n      }\r\n    },\r\n    [bans, addBanHistory, clearExpirationTimer, canAdminAct]\r\n  );\r\n\r\n  const rejectAppeal = useCallback(\r\n    (banId: string, adminUsername: string, reason?: string): boolean => {\r\n      // Admin-only\r\n      if (!canAdminAct('rejectAppeal')) return false;\r\n\r\n      try {\r\n        const ban = bans.find((b) => b.id === banId);\r\n        if (!ban) return false;\r\n\r\n        setBans((prev) =>\r\n          prev.map((b) =>\r\n            b.id === banId\r\n              ? {\r\n                  ...b,\r\n                  appealSubmitted: false,\r\n                  appealText: undefined,\r\n                  appealable: false,\r\n                  appealStatus: 'rejected',\r\n                }\r\n              : b\r\n          )\r\n        );\r\n\r\n        addBanHistory('appeal_rejected', ban.username, reason || 'Appeal rejected', adminUsername);\r\n        return true;\r\n      } catch (err) {\r\n        console.error('[BanContext] Error rejecting appeal:', err);\r\n        return false;\r\n      }\r\n    },\r\n    [bans, addBanHistory, canAdminAct]\r\n  );\r\n\r\n  const escalateAppeal = useCallback(\r\n    (banId: string, adminUsername: string, escalationReason: string): boolean => {\r\n      // Admin-only\r\n      if (!canAdminAct('escalateAppeal')) return false;\r\n\r\n      try {\r\n        const ban = bans.find((b) => b.id === banId);\r\n        if (!ban) return false;\r\n\r\n        setBans((prev) =>\r\n          prev.map((b) => (b.id === banId ? { ...b, appealStatus: 'escalated' } : b))\r\n        );\r\n\r\n        addBanHistory(\r\n          'appeal_escalated',\r\n          ban.username,\r\n          `Appeal escalated: ${sanitizeStrict(escalationReason)}`,\r\n          adminUsername\r\n        );\r\n        return true;\r\n      } catch (err) {\r\n        console.error('[BanContext] Error escalating appeal:', err);\r\n        return false;\r\n      }\r\n    },\r\n    [bans, addBanHistory, canAdminAct]\r\n  );\r\n\r\n  // ---------- IP banning ----------\r\n  const banUserIP = useCallback(\r\n    (username: string, ipAddress: string, reason: string): boolean => {\r\n      // Admin-only\r\n      if (!canAdminAct('banUserIP')) {\r\n        console.warn('[BanContext] IP ban blocked: admin privileges required');\r\n        return false;\r\n      }\r\n\r\n      try {\r\n        const cleanUsername = sanitizeUsername(username) || username;\r\n        const ipValidation = ipAddressSchema.safeParse(ipAddress);\r\n        if (!ipValidation.success) {\r\n          console.error('[BanContext] Invalid IP address format');\r\n          return false;\r\n        }\r\n        const cleanReason = sanitizeStrict(reason);\r\n\r\n        const ipBan: IPBan = {\r\n          ipAddress: ipValidation.data,\r\n          bannedUsernames: [cleanUsername],\r\n          banDate: new Date().toISOString(),\r\n          expiryDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(), // 30 days\r\n          reason: cleanReason,\r\n        };\r\n\r\n        setIPBans((prev) => {\r\n          const existing = prev.find((b) => b.ipAddress === ipValidation.data);\r\n          if (existing) {\r\n            return prev.map((b) =>\r\n              b.ipAddress === ipValidation.data\r\n                ? { ...b, bannedUsernames: [...new Set([...b.bannedUsernames, cleanUsername])] }\r\n                : b\r\n            );\r\n          }\r\n          return [...prev, ipBan];\r\n        });\r\n\r\n        return true;\r\n      } catch (err) {\r\n        console.error('[BanContext] Error banning IP:', err);\r\n        return false;\r\n      }\r\n    },\r\n    [canAdminAct]\r\n  );\r\n\r\n  const isIPBanned = useCallback(\r\n    (ipAddress: string): boolean => {\r\n      const now = new Date();\r\n      return ipBans.some(\r\n        (ban) => ban.ipAddress === ipAddress && (!ban.expiryDate || new Date(ban.expiryDate) > now)\r\n      );\r\n    },\r\n    [ipBans]\r\n  );\r\n\r\n  // ---------- Queries ----------\r\n  const isUserBanned = useCallback(\r\n    (username: string): UserBan | null => {\r\n      const cleanUsername = sanitizeUsername(username) || username;\r\n      const activeBan = bans.find((b) => b.username === cleanUsername && b.active);\r\n      if (!activeBan) return null;\r\n\r\n      if (activeBan.banType === 'temporary' && activeBan.endTime) {\r\n        const now = new Date();\r\n        const end = new Date(activeBan.endTime);\r\n        if (now >= end) {\r\n          // Auto unban expired\r\n          unbanUser(cleanUsername, 'system', 'Temporary ban expired');\r\n          return null;\r\n        }\r\n        const remainingMs = end.getTime() - now.getTime();\r\n        activeBan.remainingHours = Math.max(0, Math.ceil(remainingMs / 3_600_000));\r\n      }\r\n\r\n      return activeBan;\r\n    },\r\n    [bans, unbanUser]\r\n  );\r\n\r\n  const getBanInfo = useCallback((username: string): UserBan | null => {\r\n    return isUserBanned(username);\r\n  }, [isUserBanned]);\r\n\r\n  const getActiveBans = useCallback((): UserBan[] => {\r\n    const active = bans.filter((b) => b.active).map((b) => {\r\n      if (b.banType === 'temporary' && b.endTime) {\r\n        const now = new Date();\r\n        const end = new Date(b.endTime);\r\n        const remainingMs = end.getTime() - now.getTime();\r\n        b.remainingHours = Math.max(0, Math.ceil(remainingMs / 3_600_000));\r\n      }\r\n      return b;\r\n    });\r\n\r\n    console.log('[BanContext] Getting active bans:', {\r\n      total: bans.length,\r\n      active: active.length,\r\n      usernames: active.map((b) => b.username),\r\n    });\r\n\r\n    return active;\r\n  }, [bans]);\r\n\r\n  const getExpiredBans = useCallback((): UserBan[] => {\r\n    return bans.filter((b) => !b.active);\r\n  }, [bans]);\r\n\r\n  const getUserBanHistory = useCallback(\r\n    (username: string): UserBan[] => bans.filter((b) => b.username === username),\r\n    [bans]\r\n  );\r\n\r\n  const updateExpiredBans = useCallback(() => {\r\n    const now = new Date();\r\n    let changed = false;\r\n\r\n    setBans((prev) =>\r\n      prev.map((b) => {\r\n        if (b.active && b.banType === 'temporary' && b.endTime) {\r\n          if (now >= new Date(b.endTime)) {\r\n            clearExpirationTimer(b.id);\r\n            changed = true;\r\n            addBanHistory('unbanned', b.username, 'Temporary ban expired automatically', 'system');\r\n            return { ...b, active: false };\r\n          }\r\n        }\r\n        return b;\r\n      })\r\n    );\r\n\r\n    if (changed) console.log('[BanContext] Expired bans updated');\r\n  }, [addBanHistory, clearExpirationTimer]);\r\n\r\n  const getBanStats = useCallback(() => {\r\n    const active = getActiveBans();\r\n    const now = new Date();\r\n    const hours24Ago = new Date(now.getTime() - 24 * 60 * 60 * 1000);\r\n\r\n    const bansByReason: Record<BanReason, number> = {\r\n      harassment: 0,\r\n      spam: 0,\r\n      inappropriate_content: 0,\r\n      scam: 0,\r\n      underage: 0,\r\n      payment_fraud: 0,\r\n      other: 0,\r\n    };\r\n    active.forEach((b) => {\r\n      bansByReason[b.reason]++;\r\n    });\r\n\r\n    const allAppeals = bans.filter((b) => b.appealSubmitted);\r\n    const appealStats = {\r\n      totalAppeals: allAppeals.length,\r\n      pendingAppeals: allAppeals.filter((b) => b.appealStatus === 'pending').length,\r\n      approvedAppeals: banHistory.filter((h) => h.action === 'appeal_approved').length,\r\n      rejectedAppeals: banHistory.filter((h) => h.action === 'appeal_rejected').length,\r\n    };\r\n\r\n    const stats = {\r\n      totalActiveBans: active.length,\r\n      temporaryBans: active.filter((b) => b.banType === 'temporary').length,\r\n      permanentBans: active.filter((b) => b.banType === 'permanent').length,\r\n      pendingAppeals: active.filter((b) => b.appealSubmitted && b.appealStatus === 'pending').length,\r\n      recentBans24h: bans.filter((b) => new Date(b.startTime) >= hours24Ago).length,\r\n      bansByReason,\r\n      appealStats,\r\n    };\r\n\r\n    console.log('[BanContext] Ban stats:', stats);\r\n    return stats;\r\n  }, [getActiveBans, bans, banHistory]);\r\n\r\n  return (\r\n    <BanContext.Provider\r\n      value={{\r\n        bans,\r\n        banHistory,\r\n        appealReviews,\r\n        ipBans,\r\n        banUser,\r\n        unbanUser,\r\n        isUserBanned,\r\n        getBanInfo,\r\n        getActiveBans,\r\n        getExpiredBans,\r\n        getUserBanHistory,\r\n        submitAppeal,\r\n        reviewAppeal,\r\n        approveAppeal,\r\n        rejectAppeal,\r\n        escalateAppeal,\r\n        banUserIP,\r\n        isIPBanned,\r\n        updateExpiredBans,\r\n        scheduleExpiration,\r\n        clearExpirationTimer,\r\n        getBanStats,\r\n        validateBanInput,\r\n        refreshBanData,\r\n      }}\r\n    >\r\n      {children}\r\n    </BanContext.Provider>\r\n  );\r\n};\r\n\r\nexport const useBans = () => {\r\n  const ctx = useContext(BanContext);\r\n  if (!ctx) {\r\n    throw new Error('useBans must be used within a BanProvider');\r\n  }\r\n  return ctx;\r\n};\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1747, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/gerom/OneDrive/Documents/pantypost/src/context/WebSocketContext.tsx"],"sourcesContent":["// src/context/WebSocketContext.tsx\r\n\r\n'use client';\r\n\r\nimport React, { createContext, useContext, useEffect, useState, useCallback, useRef } from 'react';\r\nimport { useAuth, getGlobalAuthToken } from '@/context/AuthContext';\r\nimport { authService } from '@/services';\r\nimport { \r\n  createWebSocketService, \r\n  getWebSocketService, \r\n  destroyWebSocketService \r\n} from '@/services/websocket.service';\r\nimport { \r\n  WebSocketEvent, \r\n  WebSocketState, \r\n  WebSocketHandler,\r\n  TypingData,\r\n  OnlineStatusData,\r\n  RealtimeNotification\r\n} from '@/types/websocket';\r\nimport { apiConfig, websocketConfig } from '@/config/environment';\r\n\r\ninterface WebSocketContextType {\r\n  // Connection state\r\n  isConnected: boolean;\r\n  connectionState: WebSocketState;\r\n  \r\n  // Core methods\r\n  connect: () => void;\r\n  disconnect: () => void;\r\n  \r\n  // Event subscription\r\n  subscribe: <T = any>(event: WebSocketEvent | string, handler: WebSocketHandler<T>) => () => void;\r\n  \r\n  // Sending events\r\n  sendMessage: (event: WebSocketEvent | string, data: any) => void;\r\n  \r\n  // Typing indicators\r\n  sendTyping: (conversationId: string, isTyping: boolean) => void;\r\n  typingUsers: Map<string, TypingData>;\r\n  \r\n  // Online status\r\n  onlineUsers: Set<string>;\r\n  updateOnlineStatus: (isOnline: boolean) => void;\r\n  \r\n  // Notifications\r\n  notifications: RealtimeNotification[];\r\n  markNotificationRead: (notificationId: string) => void;\r\n  clearNotifications: () => void;\r\n}\r\n\r\nconst WebSocketContext = createContext<WebSocketContextType | undefined>(undefined);\r\n\r\nexport const useWebSocket = () => {\r\n  const context = useContext(WebSocketContext);\r\n  // Return null instead of throwing to allow components to handle missing context gracefully\r\n  return context || null;\r\n};\r\n\r\nexport const WebSocketProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {\r\n  const { user, getAuthToken } = useAuth();\r\n  const [isConnected, setIsConnected] = useState(false);\r\n  const [connectionState, setConnectionState] = useState<WebSocketState>(WebSocketState.DISCONNECTED);\r\n  const [typingUsers, setTypingUsers] = useState<Map<string, TypingData>>(new Map());\r\n  const [onlineUsers, setOnlineUsers] = useState<Set<string>>(new Set());\r\n  const [notifications, setNotifications] = useState<RealtimeNotification[]>([]);\r\n  \r\n  const typingTimers = useRef<Map<string, NodeJS.Timeout>>(new Map());\r\n  const wsService = useRef(getWebSocketService());\r\n  const currentToken = useRef<string | null>(null);\r\n  const hasInitialized = useRef(false);\r\n  const pendingSubscriptions = useRef<Array<{ event: string; handler: WebSocketHandler }>>([]); // Store pending subscriptions\r\n\r\n  // Listen for auth token events from AuthContext\r\n  useEffect(() => {\r\n    if (typeof window === 'undefined') return;\r\n\r\n    const handleTokenUpdate = (event: CustomEvent) => {\r\n      const newToken = event.detail?.token;\r\n      console.log('[WebSocket] Auth token updated:', !!newToken);\r\n      \r\n      if (newToken !== currentToken.current) {\r\n        currentToken.current = newToken;\r\n        \r\n        // Reconnect with new token if we have a user and WebSocket is enabled\r\n        if (user && websocketConfig.enabled && wsService.current) {\r\n          console.log('[WebSocket] Reconnecting with new token...');\r\n          wsService.current.disconnect();\r\n          setTimeout(() => {\r\n            initializeWebSocket();\r\n          }, 1000);\r\n        }\r\n      }\r\n    };\r\n\r\n    const handleTokenClear = () => {\r\n      console.log('[WebSocket] Auth token cleared');\r\n      currentToken.current = null;\r\n      \r\n      // Disconnect WebSocket when token is cleared\r\n      if (wsService.current) {\r\n        wsService.current.disconnect();\r\n      }\r\n      \r\n      setIsConnected(false);\r\n      setConnectionState(WebSocketState.DISCONNECTED);\r\n      setOnlineUsers(new Set());\r\n      setTypingUsers(new Map());\r\n    };\r\n\r\n    // Listen for auth events from AuthContext\r\n    window.addEventListener('auth-token-updated', handleTokenUpdate as EventListener);\r\n    window.addEventListener('auth-token-cleared', handleTokenClear);\r\n\r\n    return () => {\r\n      window.removeEventListener('auth-token-updated', handleTokenUpdate as EventListener);\r\n      window.removeEventListener('auth-token-cleared', handleTokenClear);\r\n    };\r\n  }, [user]);\r\n\r\n  // Improved WebSocket initialization\r\n  const initializeWebSocket = useCallback(async (): Promise<(() => void) | undefined> => {\r\n    if (!user || !websocketConfig.enabled) {\r\n      console.log('[WebSocket] User not available or WebSocket disabled');\r\n      return undefined;\r\n    }\r\n\r\n    // Try multiple ways to get the auth token\r\n    let token = currentToken.current;\r\n    \r\n    if (!token) {\r\n      token = getAuthToken();\r\n    }\r\n    \r\n    if (!token && typeof window !== 'undefined') {\r\n      token = getGlobalAuthToken();\r\n    }\r\n    \r\n    if (!token) {\r\n      console.log('[WebSocket] No auth token available');\r\n      return undefined;\r\n    }\r\n\r\n    console.log('[WebSocket] Initializing with token:', !!token);\r\n    currentToken.current = token;\r\n    \r\n    try {\r\n      // Use WebSocket URL from config\r\n      const wsUrl = websocketConfig.url || apiConfig.baseUrl.replace('/api', '').replace('http', 'ws');\r\n      \r\n      // Create WebSocket service if it doesn't exist\r\n      if (!wsService.current) {\r\n        wsService.current = createWebSocketService({\r\n          url: wsUrl,\r\n          auth: { token },\r\n          autoConnect: true,\r\n          reconnect: true,\r\n          reconnectAttempts: 5,\r\n          reconnectDelay: 3000\r\n        });\r\n      }\r\n\r\n      // Subscribe to connection events\r\n      const unsubConnect = wsService.current.on(WebSocketEvent.CONNECT, () => {\r\n        setIsConnected(true);\r\n        setConnectionState(WebSocketState.CONNECTED);\r\n        console.log('[WebSocket] Connected');\r\n        \r\n        // Process any pending subscriptions\r\n        if (pendingSubscriptions.current.length > 0) {\r\n          console.log('[WebSocket] Processing', pendingSubscriptions.current.length, 'pending subscriptions');\r\n          const pending = [...pendingSubscriptions.current];\r\n          pendingSubscriptions.current = [];\r\n          \r\n          pending.forEach(({ event, handler }) => {\r\n            if (wsService.current) {\r\n              wsService.current.on(event as WebSocketEvent, handler);\r\n            }\r\n          });\r\n        }\r\n        \r\n        // Send initial online status\r\n        updateOnlineStatus(true);\r\n      });\r\n\r\n      const unsubDisconnect = wsService.current.on(WebSocketEvent.DISCONNECT, () => {\r\n        setIsConnected(false);\r\n        setConnectionState(WebSocketState.DISCONNECTED);\r\n        setOnlineUsers(new Set());\r\n        setTypingUsers(new Map());\r\n        console.log('[WebSocket] Disconnected');\r\n      });\r\n\r\n      const unsubError = wsService.current.on(WebSocketEvent.ERROR, (error) => {\r\n        setConnectionState(WebSocketState.ERROR);\r\n        console.error('[WebSocket] Error:', error);\r\n      });\r\n\r\n      // Subscribe to app events\r\n      const unsubTyping = wsService.current.on<TypingData>(\r\n        WebSocketEvent.MESSAGE_TYPING, \r\n        handleTypingUpdate\r\n      );\r\n\r\n      const unsubUserOnline = wsService.current.on<OnlineStatusData>(\r\n        WebSocketEvent.USER_ONLINE,\r\n        handleUserOnline\r\n      );\r\n\r\n      const unsubUserOffline = wsService.current.on<OnlineStatusData>(\r\n        WebSocketEvent.USER_OFFLINE,\r\n        handleUserOffline\r\n      );\r\n\r\n      const unsubNotification = wsService.current.on<RealtimeNotification>(\r\n        WebSocketEvent.NOTIFICATION_NEW,\r\n        handleNewNotification\r\n      );\r\n\r\n      // Subscribe to message events\r\n      const unsubMessageNew = wsService.current.on('message:new' as WebSocketEvent, (data: any) => {\r\n        console.log('[WebSocket Context] New message received:', data);\r\n        if (typeof window !== 'undefined') {\r\n          window.dispatchEvent(new CustomEvent('message:new', { detail: data }));\r\n        }\r\n      });\r\n\r\n      const unsubMessageRead = wsService.current.on('message:read' as WebSocketEvent, (data: any) => {\r\n        console.log('[WebSocket Context] Message read event:', data);\r\n        if (typeof window !== 'undefined') {\r\n          window.dispatchEvent(new CustomEvent('message:read', { detail: data }));\r\n        }\r\n      });\r\n\r\n      // Subscribe to order events\r\n      const unsubOrderCreated = wsService.current.on('order:created' as WebSocketEvent, (data: any) => {\r\n        console.log('[WebSocket Context] Order created event received:', data);\r\n        if (typeof window !== 'undefined') {\r\n          window.dispatchEvent(new CustomEvent('order:created', { detail: data }));\r\n        }\r\n      });\r\n\r\n      const unsubOrderNew = wsService.current.on('order:new' as WebSocketEvent, (data: any) => {\r\n        console.log('[WebSocket Context] Order new event received:', data);\r\n        if (typeof window !== 'undefined') {\r\n          window.dispatchEvent(new CustomEvent('order:new', { detail: data }));\r\n        }\r\n      });\r\n\r\n      // Subscribe to auction events\r\n      const unsubAuctionWon = wsService.current.on('auction:won' as WebSocketEvent, (data: any) => {\r\n        console.log('[WebSocket Context] Auction won event received:', data);\r\n        if (typeof window !== 'undefined') {\r\n          window.dispatchEvent(new CustomEvent('auction:won', { detail: data }));\r\n        }\r\n      });\r\n\r\n      const unsubAuctionEnded = wsService.current.on('auction:ended' as WebSocketEvent, (data: any) => {\r\n        console.log('[WebSocket Context] Auction ended event received:', data);\r\n        if (typeof window !== 'undefined') {\r\n          window.dispatchEvent(new CustomEvent('auction:ended', { detail: data }));\r\n        }\r\n      });\r\n\r\n      const unsubListingSold = wsService.current.on('listing:sold' as WebSocketEvent, (data: any) => {\r\n        console.log('[WebSocket Context] Listing sold event received:', data);\r\n        if (typeof window !== 'undefined') {\r\n          window.dispatchEvent(new CustomEvent('listing:sold', { detail: data }));\r\n        }\r\n      });\r\n\r\n      // Subscribe to wallet balance updates\r\n      const unsubWalletUpdate = wsService.current.on('wallet:balance_update' as WebSocketEvent, (data: any) => {\r\n        console.log('[WebSocket Context] Wallet balance update:', data);\r\n        if (typeof window !== 'undefined') {\r\n          window.dispatchEvent(new CustomEvent('wallet:balance_update', { detail: data }));\r\n        }\r\n      });\r\n\r\n      const unsubWalletTransaction = wsService.current.on('wallet:transaction' as WebSocketEvent, (data: any) => {\r\n        console.log('[WebSocket Context] Wallet transaction:', data);\r\n        if (typeof window !== 'undefined') {\r\n          window.dispatchEvent(new CustomEvent('wallet:transaction', { detail: data }));\r\n        }\r\n      });\r\n\r\n      // Subscribe to notification events\r\n      const unsubNotificationNew = wsService.current.on('notification:new' as WebSocketEvent, (data: any) => {\r\n        console.log('[WebSocket Context] New notification:', data);\r\n        if (typeof window !== 'undefined') {\r\n          window.dispatchEvent(new CustomEvent('notification:new', { detail: data }));\r\n        }\r\n      });\r\n\r\n      const unsubNotificationCleared = wsService.current.on('notification:cleared' as WebSocketEvent, (data: any) => {\r\n        console.log('[WebSocket Context] Notification cleared:', data);\r\n        if (typeof window !== 'undefined') {\r\n          window.dispatchEvent(new CustomEvent('notification:cleared', { detail: data }));\r\n        }\r\n      });\r\n\r\n      const unsubNotificationAllCleared = wsService.current.on('notification:all_cleared' as WebSocketEvent, (data: any) => {\r\n        console.log('[WebSocket Context] All notifications cleared:', data);\r\n        if (typeof window !== 'undefined') {\r\n          window.dispatchEvent(new CustomEvent('notification:all_cleared', { detail: data }));\r\n        }\r\n      });\r\n\r\n      const unsubNotificationRestored = wsService.current.on('notification:restored' as WebSocketEvent, (data: any) => {\r\n        console.log('[WebSocket Context] Notification restored:', data);\r\n        if (typeof window !== 'undefined') {\r\n          window.dispatchEvent(new CustomEvent('notification:restored', { detail: data }));\r\n        }\r\n      });\r\n\r\n      const unsubNotificationDeleted = wsService.current.on('notification:deleted' as WebSocketEvent, (data: any) => {\r\n        console.log('[WebSocket Context] Notification deleted:', data);\r\n        if (typeof window !== 'undefined') {\r\n          window.dispatchEvent(new CustomEvent('notification:deleted', { detail: data }));\r\n        }\r\n      });\r\n\r\n      // Connect\r\n      wsService.current.connect();\r\n\r\n      // Store cleanup functions\r\n      return () => {\r\n        unsubConnect();\r\n        unsubDisconnect();\r\n        unsubError();\r\n        unsubTyping();\r\n        unsubUserOnline();\r\n        unsubUserOffline();\r\n        unsubNotification();\r\n        unsubMessageNew();\r\n        unsubMessageRead();\r\n        unsubOrderCreated();\r\n        unsubOrderNew();\r\n        unsubAuctionWon();\r\n        unsubAuctionEnded();\r\n        unsubListingSold();\r\n        unsubWalletUpdate();\r\n        unsubWalletTransaction();\r\n        unsubNotificationNew();\r\n        unsubNotificationCleared();\r\n        unsubNotificationAllCleared();\r\n        unsubNotificationRestored();\r\n        unsubNotificationDeleted();\r\n      };\r\n    } catch (error) {\r\n      console.error('[WebSocket] Initialization error:', error);\r\n      setConnectionState(WebSocketState.ERROR);\r\n      return undefined;\r\n    }\r\n  }, [user, getAuthToken]);\r\n\r\n  // Initialize WebSocket connection when user is available\r\n  useEffect(() => {\r\n    let cleanup: (() => void) | undefined;\r\n\r\n    const init = async () => {\r\n      if (!hasInitialized.current && user && websocketConfig.enabled) {\r\n        hasInitialized.current = true;\r\n        cleanup = await initializeWebSocket();\r\n      }\r\n    };\r\n\r\n    if (user && websocketConfig.enabled) {\r\n      init();\r\n    } else if (wsService.current?.isConnected()) {\r\n      // Disconnect if no user or WebSocket disabled\r\n      wsService.current.disconnect();\r\n      hasInitialized.current = false;\r\n    }\r\n\r\n    return () => {\r\n      cleanup?.();\r\n      hasInitialized.current = false;\r\n    };\r\n  }, [user, initializeWebSocket]);\r\n\r\n  // Cleanup on unmount\r\n  useEffect(() => {\r\n    return () => {\r\n      typingTimers.current.forEach(timer => clearTimeout(timer));\r\n      if (wsService.current?.isConnected()) {\r\n        wsService.current.disconnect();\r\n      }\r\n      destroyWebSocketService();\r\n    };\r\n  }, []);\r\n\r\n  // Handle typing updates\r\n  const handleTypingUpdate = useCallback((data: TypingData) => {\r\n    const key = `${data.conversationId}-${data.userId}`;\r\n    \r\n    if (data.isTyping) {\r\n      setTypingUsers(prev => new Map(prev).set(key, data));\r\n      \r\n      // Clear existing timer\r\n      const existingTimer = typingTimers.current.get(key);\r\n      if (existingTimer) {\r\n        clearTimeout(existingTimer);\r\n      }\r\n      \r\n      // Set new timer to remove typing indicator after 3 seconds\r\n      const timer = setTimeout(() => {\r\n        setTypingUsers(prev => {\r\n          const newMap = new Map(prev);\r\n          newMap.delete(key);\r\n          return newMap;\r\n        });\r\n        typingTimers.current.delete(key);\r\n      }, 3000);\r\n      \r\n      typingTimers.current.set(key, timer);\r\n    } else {\r\n      setTypingUsers(prev => {\r\n        const newMap = new Map(prev);\r\n        newMap.delete(key);\r\n        return newMap;\r\n      });\r\n      \r\n      const timer = typingTimers.current.get(key);\r\n      if (timer) {\r\n        clearTimeout(timer);\r\n        typingTimers.current.delete(key);\r\n      }\r\n    }\r\n  }, []);\r\n\r\n  // Handle user online\r\n  const handleUserOnline = useCallback((data: OnlineStatusData) => {\r\n    setOnlineUsers(prev => new Set(prev).add(data.userId));\r\n  }, []);\r\n\r\n  // Handle user offline\r\n  const handleUserOffline = useCallback((data: OnlineStatusData) => {\r\n    setOnlineUsers(prev => {\r\n      const newSet = new Set(prev);\r\n      newSet.delete(data.userId);\r\n      return newSet;\r\n    });\r\n  }, []);\r\n\r\n  // Handle new notification\r\n  const handleNewNotification = useCallback((notification: RealtimeNotification) => {\r\n    setNotifications(prev => [notification, ...prev].slice(0, 50)); // Keep last 50\r\n  }, []);\r\n\r\n  // Public methods\r\n  const connect = useCallback(() => {\r\n    if (!currentToken.current) {\r\n      currentToken.current = getAuthToken() || getGlobalAuthToken();\r\n    }\r\n    wsService.current?.connect();\r\n  }, [getAuthToken]);\r\n\r\n  const disconnect = useCallback(() => {\r\n    wsService.current?.disconnect();\r\n  }, []);\r\n\r\n  // FIXED: Subscribe method that queues subscriptions if service not ready\r\n  const subscribe = useCallback(<T = any>(\r\n    event: WebSocketEvent | string, \r\n    handler: WebSocketHandler<T>\r\n  ): (() => void) => {\r\n    if (!wsService.current) {\r\n      console.log('[WebSocket] Service not initialized - queueing subscription for:', event);\r\n      // Queue the subscription for later\r\n      pendingSubscriptions.current.push({ event, handler });\r\n      \r\n      // Return a cleanup function that removes from pending if not yet processed\r\n      return () => {\r\n        const index = pendingSubscriptions.current.findIndex(\r\n          sub => sub.event === event && sub.handler === handler\r\n        );\r\n        if (index !== -1) {\r\n          pendingSubscriptions.current.splice(index, 1);\r\n        }\r\n      };\r\n    }\r\n    \r\n    // Service is ready, subscribe immediately\r\n    return wsService.current.on<T>(event as WebSocketEvent, handler);\r\n  }, []);\r\n\r\n  const sendMessage = useCallback((event: WebSocketEvent | string, data: any) => {\r\n    if (!wsService.current?.isConnected()) {\r\n      console.warn('[WebSocket] Not connected, cannot send message');\r\n      return;\r\n    }\r\n    wsService.current.send(event, data);\r\n  }, []);\r\n\r\n  const sendTyping = useCallback((conversationId: string, isTyping: boolean) => {\r\n    if (!user) return;\r\n    \r\n    sendMessage(WebSocketEvent.MESSAGE_TYPING, {\r\n      userId: user.id,\r\n      username: user.username,\r\n      conversationId,\r\n      isTyping\r\n    });\r\n  }, [user, sendMessage]);\r\n\r\n  const updateOnlineStatus = useCallback((isOnline: boolean) => {\r\n    if (!user) return;\r\n    \r\n    sendMessage(\r\n      isOnline ? WebSocketEvent.USER_ONLINE : WebSocketEvent.USER_OFFLINE,\r\n      { userId: user.id, isOnline }\r\n    );\r\n  }, [user, sendMessage]);\r\n\r\n  const markNotificationRead = useCallback((notificationId: string) => {\r\n    setNotifications(prev => \r\n      prev.map(n => n.id === notificationId ? { ...n, read: true } : n)\r\n    );\r\n    sendMessage(WebSocketEvent.NOTIFICATION_READ, { notificationId });\r\n  }, [sendMessage]);\r\n\r\n  const clearNotifications = useCallback(() => {\r\n    setNotifications([]);\r\n  }, []);\r\n\r\n  const value: WebSocketContextType = {\r\n    isConnected,\r\n    connectionState,\r\n    connect,\r\n    disconnect,\r\n    subscribe,\r\n    sendMessage,\r\n    sendTyping,\r\n    typingUsers,\r\n    onlineUsers,\r\n    updateOnlineStatus,\r\n    notifications,\r\n    markNotificationRead,\r\n    clearNotifications\r\n  };\r\n\r\n  return (\r\n    <WebSocketContext.Provider value={value}>\r\n      {children}\r\n    </WebSocketContext.Provider>\r\n  );\r\n};"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2164, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/gerom/OneDrive/Documents/pantypost/src/context/WalletContext.tsx"],"sourcesContent":["// src/context/WalletContext.tsx\r\n\"use client\";\r\n\r\nimport {\r\n  createContext,\r\n  useContext,\r\n  useState,\r\n  useEffect,\r\n  ReactNode,\r\n  useCallback,\r\n  useRef,\r\n} from \"react\";\r\nimport { v4 as uuidv4 } from 'uuid';\r\nimport { sanitizeStrict, sanitizeUsername, sanitizeCurrency } from '@/utils/security/sanitization';\r\nimport { getRateLimiter, RATE_LIMITS } from '@/utils/security/rate-limiter';\r\nimport { financialSchemas } from '@/utils/validation/schemas';\r\nimport { z } from 'zod';\r\nimport { useWebSocket } from '@/context/WebSocketContext';\r\nimport { WebSocketEvent } from '@/types/websocket';\r\nimport { useAuth } from '@/context/AuthContext';\r\nimport { securityService } from '@/services/security.service';\r\n\r\n// Import shared types\r\nimport type { Order, DeliveryAddress, Listing, CustomRequestPurchase, DepositLog } from '@/types/order';\r\n\r\n// Re-export types for backward compatibility\r\nexport type { Order, DeliveryAddress, Listing, CustomRequestPurchase, DepositLog };\r\n\r\n// Debug mode helper\r\nconst DEBUG_MODE = process.env.NEXT_PUBLIC_DEBUG === 'true';\r\nconst debugLog = (...args: any[]) => {\r\n  if (DEBUG_MODE) {\r\n    console.log('[WalletContext]', ...args);\r\n  }\r\n};\r\n\r\ntype Withdrawal = {\r\n  amount: number;\r\n  date: string;\r\n  status?: 'pending' | 'completed' | 'failed';\r\n  method?: string;\r\n};\r\n\r\ntype AdminAction = {\r\n  id?: string;\r\n  _id?: string;\r\n  type: 'credit' | 'debit';\r\n  amount: number;\r\n  targetUser?: string;\r\n  username?: string;\r\n  adminUser?: string;\r\n  reason: string;\r\n  date: string;\r\n  role?: 'buyer' | 'seller';\r\n  metadata?: any;\r\n};\r\n\r\n// Validation schemas for wallet operations\r\nconst walletOperationSchemas = {\r\n  transactionAmount: z.number().positive().min(0.01).max(100000),\r\n  balanceAmount: z.number().min(0).max(100000),\r\n  username: z.string().min(3).max(30).regex(/^[a-zA-Z0-9_-]+$/),\r\n  reason: z.string().min(1).max(500),\r\n  withdrawalAmount: z.number().positive().min(10).max(10000),\r\n  tipAmount: z.number().positive().min(1).max(500),\r\n  depositMethod: z.enum(['credit_card', 'bank_transfer', 'crypto', 'admin_credit']),\r\n};\r\n\r\n// Enhanced deduplication manager with configurable expiry\r\nclass DeduplicationManager {\r\n  private processedEvents: Map<string, number> = new Map();\r\n  private cleanupInterval: NodeJS.Timeout | null = null;\r\n  private expiryMs: number;\r\n\r\n  constructor(expiryMs: number = 30000) {\r\n    this.expiryMs = expiryMs;\r\n    this.startCleanup();\r\n  }\r\n\r\n  private startCleanup() {\r\n    this.cleanupInterval = setInterval(() => {\r\n      const now = Date.now();\r\n      const expiredKeys: string[] = [];\r\n      \r\n      this.processedEvents.forEach((timestamp, key) => {\r\n        if (now - timestamp > this.expiryMs) {\r\n          expiredKeys.push(key);\r\n        }\r\n      });\r\n      \r\n      expiredKeys.forEach(key => this.processedEvents.delete(key));\r\n    }, 10000); // Cleanup every 10 seconds\r\n  }\r\n\r\n  isDuplicate(eventType: string, data: any): boolean {\r\n    // Create composite key based on event type\r\n    let key: string;\r\n    \r\n    if (eventType === 'balance_update') {\r\n      key = `${eventType}_${data.username}_${data.balance || data.newBalance}_${data.timestamp || Date.now()}`;\r\n    } else if (eventType === 'transaction') {\r\n      key = `${eventType}_${data.id || data.transactionId}_${data.from}_${data.to}_${data.amount}`;\r\n    } else if (eventType === 'order_created') {\r\n      key = `${eventType}_${data.id || data._id}_${data.buyer}_${data.seller}`;\r\n    } else {\r\n      key = `${eventType}_${JSON.stringify(data)}`;\r\n    }\r\n    \r\n    if (this.processedEvents.has(key)) {\r\n      return true;\r\n    }\r\n    \r\n    this.processedEvents.set(key, Date.now());\r\n    return false;\r\n  }\r\n\r\n  destroy() {\r\n    if (this.cleanupInterval) {\r\n      clearInterval(this.cleanupInterval);\r\n      this.cleanupInterval = null;\r\n    }\r\n    this.processedEvents.clear();\r\n  }\r\n}\r\n\r\n// Helper function to check if user is admin\r\nconst isAdminUser = (username: string): boolean => {\r\n  return username === 'oakley' || \r\n         username === 'gerome' || \r\n         username === 'platform' ||\r\n         username === 'admin';\r\n};\r\n\r\n// Transaction throttle manager\r\nclass ThrottleManager {\r\n  private lastCallTimes: Map<string, number> = new Map();\r\n  \r\n  shouldThrottle(key: string, minIntervalMs: number = 3000): boolean {\r\n    const now = Date.now();\r\n    const lastCall = this.lastCallTimes.get(key) || 0;\r\n    \r\n    if (now - lastCall < minIntervalMs) {\r\n      return true;\r\n    }\r\n    \r\n    this.lastCallTimes.set(key, now);\r\n    return false;\r\n  }\r\n  \r\n  clear() {\r\n    this.lastCallTimes.clear();\r\n  }\r\n}\r\n\r\n// Transaction lock manager for preventing race conditions\r\nclass TransactionLockManager {\r\n  private locks: Map<string, Promise<any>> = new Map();\r\n\r\n  async acquireLock<T>(key: string, operation: () => Promise<T>): Promise<T> {\r\n    const existingLock = this.locks.get(key);\r\n    if (existingLock) {\r\n      await existingLock;\r\n    }\r\n\r\n    let result: T;\r\n    const lockPromise = operation()\r\n      .then(res => {\r\n        result = res;\r\n        return res;\r\n      })\r\n      .finally(() => {\r\n        this.locks.delete(key);\r\n      });\r\n\r\n    this.locks.set(key, lockPromise);\r\n    await lockPromise;\r\n    return result!;\r\n  }\r\n\r\n  isLocked(key: string): boolean {\r\n    return this.locks.has(key);\r\n  }\r\n}\r\n\r\ntype WalletContextType = {\r\n  // Loading state\r\n  isLoading: boolean;\r\n  isInitialized: boolean;\r\n  initializationError: string | null;\r\n  \r\n  // Balances (cached from API)\r\n  buyerBalances: { [username: string]: number };\r\n  adminBalance: number;\r\n  sellerBalances: { [username: string]: number };\r\n  \r\n  // Balance operations\r\n  setBuyerBalance: (username: string, balance: number) => Promise<void>;\r\n  getBuyerBalance: (username: string) => number;\r\n  setAdminBalance: (balance: number) => Promise<void>;\r\n  setSellerBalance: (seller: string, balance: number) => Promise<void>;\r\n  getSellerBalance: (seller: string) => number;\r\n  \r\n  // Purchase operations\r\n  purchaseListing: (listing: Listing, buyerUsername: string) => Promise<boolean>;\r\n  purchaseCustomRequest: (customRequest: CustomRequestPurchase) => Promise<boolean>;\r\n  subscribeToSellerWithPayment: (buyer: string, seller: string, amount: number) => Promise<boolean>;\r\n  unsubscribeFromSeller: (buyer: string, seller: string) => Promise<boolean>;\r\n  \r\n  // Order management\r\n  orderHistory: Order[];\r\n  addOrder: (order: Order) => Promise<void>;\r\n  \r\n  // Withdrawals\r\n  sellerWithdrawals: { [username: string]: Withdrawal[] };\r\n  adminWithdrawals: Withdrawal[];\r\n  addSellerWithdrawal: (username: string, amount: number) => Promise<void>;\r\n  addAdminWithdrawal: (amount: number) => Promise<void>;\r\n  \r\n  // Legacy wallet interface\r\n  wallet: { [username: string]: number };\r\n  updateWallet: (username: string, amount: number, orderToFulfil?: Order) => void;\r\n  \r\n  // Tips and notifications\r\n  sendTip: (buyer: string, seller: string, amount: number, message?: string) => Promise<boolean>;\r\n  setAddSellerNotificationCallback?: (fn: (seller: string, message: string) => void) => void;\r\n  \r\n  // Admin actions\r\n  adminCreditUser: (username: string, role: 'buyer' | 'seller', amount: number, reason: string) => Promise<boolean>;\r\n  adminDebitUser: (username: string, role: 'buyer' | 'seller', amount: number, reason: string) => Promise<boolean>;\r\n  adminActions: AdminAction[];\r\n  \r\n  // Order updates\r\n  updateOrderAddress: (orderId: string, address: DeliveryAddress) => Promise<void>;\r\n  updateShippingStatus: (orderId: string, status: 'pending' | 'processing' | 'shipped') => Promise<void>;\r\n  \r\n  // Deposits\r\n  depositLogs: DepositLog[];\r\n  addDeposit: (username: string, amount: number, method: DepositLog['method'], notes?: string) => Promise<boolean>;\r\n  getDepositsForUser: (username: string) => DepositLog[];\r\n  getTotalDeposits: () => number;\r\n  getDepositsByTimeframe: (timeframe: 'today' | 'week' | 'month' | 'year' | 'all') => DepositLog[];\r\n  \r\n  // Auction methods\r\n  holdBidFunds: (listingId: string, bidder: string, amount: number, auctionTitle: string) => Promise<boolean>;\r\n  refundBidFunds: (bidder: string, listingId: string) => Promise<boolean>;\r\n  finalizeAuctionPurchase: (listing: Listing, winnerUsername: string, winningBid: number) => Promise<boolean>;\r\n  placeBid: (listingId: string, bidder: string, amount: number) => Promise<boolean>;\r\n  chargeIncrementalBid: (listingId: string, bidder: string, previousBid: number, newBid: number, listingTitle: string) => Promise<boolean>;\r\n  getAuctionBidders: (listingId: string) => Promise<string[]>;\r\n  cleanupAuctionTracking: (listingId: string, winner?: string) => Promise<void>;\r\n  \r\n  // Enhanced features\r\n  checkSuspiciousActivity: (username: string) => Promise<{ suspicious: boolean; reasons: string[] }>;\r\n  reconcileBalance: (username: string, role: 'buyer' | 'seller' | 'admin') => Promise<any>;\r\n  getTransactionHistory: (username?: string, limit?: number) => Promise<any[]>;\r\n  \r\n  // Admin-specific methods\r\n  refreshAdminData: () => Promise<void>;\r\n  getPlatformTransactions: (limit?: number, page?: number) => Promise<any[]>;\r\n  getAnalyticsData: (timeFilter?: string) => Promise<any>;\r\n  \r\n  // Data management\r\n  reloadData: () => Promise<void>;\r\n};\r\n\r\nexport const WalletContext = createContext<WalletContextType | undefined>(undefined);\r\n\r\nexport function WalletProvider({ children }: { children: ReactNode }) {\r\n  const { user, getAuthToken, apiClient } = useAuth();\r\n  const webSocketContext = useWebSocket();\r\n  \r\n  // Extract properties from WebSocket context safely\r\n  const sendMessage = webSocketContext?.sendMessage;\r\n  const subscribe = webSocketContext?.subscribe;\r\n  const isConnected = webSocketContext?.isConnected || false;\r\n  \r\n  // State management - these will be populated from API\r\n  const [buyerBalances, setBuyerBalancesState] = useState<{ [username: string]: number }>({});\r\n  const [adminBalance, setAdminBalanceState] = useState<number>(0);\r\n  const [sellerBalances, setSellerBalancesState] = useState<{ [username: string]: number }>({});\r\n  const [orderHistory, setOrderHistory] = useState<Order[]>([]);\r\n  const [sellerWithdrawals, setSellerWithdrawals] = useState<{ [username: string]: Withdrawal[] }>({});\r\n  const [adminWithdrawals, setAdminWithdrawals] = useState<Withdrawal[]>([]);\r\n  const [adminActions, setAdminActions] = useState<AdminAction[]>([]);\r\n  const [depositLogs, setDepositLogs] = useState<DepositLog[]>([]);\r\n  const [addSellerNotification, setAddSellerNotification] = useState<((seller: string, message: string) => void) | null>(null);\r\n  \r\n  // Loading and initialization state\r\n  const [isLoading, setIsLoading] = useState(true);\r\n  const [isInitialized, setIsInitialized] = useState(false);\r\n  const [initializationError, setInitializationError] = useState<string | null>(null);\r\n  \r\n  // Refs\r\n  const initializingRef = useRef(false);\r\n  const rateLimiter = useRef(getRateLimiter());\r\n  const transactionLock = useRef(new TransactionLockManager());\r\n  const deduplicationManager = useRef(new DeduplicationManager(30000)); // 30 second expiry\r\n  const throttleManager = useRef(new ThrottleManager());\r\n  \r\n  // FIX: Add refs to track last fetched data for deduplication\r\n  const lastFiredBalanceRef = useRef<{ balance: number; timestamp: number } | null>(null);\r\n  const lastPlatformBalanceFetch = useRef<{ balance: number; timestamp: number } | null>(null);\r\n  const lastAdminActionsFetch = useRef<number>(0);\r\n\r\n  const setAddSellerNotificationCallback = (fn: (seller: string, message: string) => void) => {\r\n    setAddSellerNotification(() => fn);\r\n  };\r\n\r\n  // Cleanup on unmount\r\n  useEffect(() => {\r\n    return () => {\r\n      deduplicationManager.current.destroy();\r\n      throttleManager.current.clear();\r\n    };\r\n  }, []);\r\n\r\n  // FIX: Enhanced fireAdminBalanceUpdateEvent with deduplication\r\n  const fireAdminBalanceUpdateEvent = useCallback((balance: number) => {\r\n    if (typeof window !== 'undefined') {\r\n      // Deduplicate: Don't fire if same balance was fired within 1 second\r\n      const now = Date.now();\r\n      if (lastFiredBalanceRef.current) {\r\n        const { balance: lastBalance, timestamp: lastTime } = lastFiredBalanceRef.current;\r\n        if (lastBalance === balance && (now - lastTime) < 1000) {\r\n          debugLog('Skipping duplicate admin balance event:', balance);\r\n          return;\r\n        }\r\n      }\r\n      \r\n      debugLog('Firing admin balance update event:', balance);\r\n      lastFiredBalanceRef.current = { balance, timestamp: now };\r\n      \r\n      window.dispatchEvent(new CustomEvent('wallet:admin-balance-updated', {\r\n        detail: { balance, timestamp: now }\r\n      }));\r\n    }\r\n  }, []);\r\n\r\n  // Helper function to validate amounts\r\n  const validateTransactionAmount = (amount: number): number => {\r\n    const validation = walletOperationSchemas.transactionAmount.safeParse(amount);\r\n    if (!validation.success) {\r\n      throw new Error('Invalid transaction amount: ' + validation.error.errors[0]?.message);\r\n    }\r\n    return sanitizeCurrency(validation.data);\r\n  };\r\n\r\n  const validateUsername = (username: string): string => {\r\n    const validation = walletOperationSchemas.username.safeParse(username);\r\n    if (!validation.success) {\r\n      throw new Error('Invalid username: ' + validation.error.errors[0]?.message);\r\n    }\r\n    return sanitizeUsername(validation.data);\r\n  };\r\n\r\n  // Check rate limit\r\n  const checkRateLimit = (operation: string, identifier?: string): void => {\r\n    const rateLimitConfig = RATE_LIMITS[operation as keyof typeof RATE_LIMITS] || RATE_LIMITS.API_CALL;\r\n    const result = rateLimiter.current.check(operation, { ...rateLimitConfig, identifier });\r\n    \r\n    if (!result.allowed) {\r\n      throw new Error(`Rate limit exceeded. Please wait ${result.waitTime} seconds before trying again.`);\r\n    }\r\n  };\r\n\r\n  // CRITICAL FIX: Fetch actual orders from /orders endpoint\r\n  const fetchOrderHistory = useCallback(async (username: string) => {\r\n    try {\r\n      debugLog('Fetching orders for:', username);\r\n      \r\n      // Use the orders endpoint with buyer parameter\r\n      const response = await apiClient.get<any>(`/orders?buyer=${username}`);\r\n      \r\n      debugLog('Orders response:', response);\r\n      \r\n      if (response.success && response.data) {\r\n        // The orders should already be in the correct format\r\n        setOrderHistory(response.data);\r\n        debugLog('Order history updated:', response.data.length, 'orders');\r\n      }\r\n    } catch (error) {\r\n      console.error('[WalletContext] Failed to fetch order history:', error);\r\n    }\r\n  }, [apiClient]);\r\n\r\n  // Also fetch transactions for transaction history (keep this separate)\r\n  const fetchTransactionHistory = useCallback(async (username: string) => {\r\n    try {\r\n      debugLog('Fetching transactions for:', username);\r\n      \r\n      // For admin users, fetch platform transactions\r\n      const queryUsername = isAdminUser(username) ? 'platform' : username;\r\n      \r\n      const response = await apiClient.get<any>(`/wallet/transactions/${queryUsername}`);\r\n      \r\n      debugLog('Transactions response:', response);\r\n      \r\n      // Don't try to convert transactions to orders anymore\r\n      // Transactions and orders are separate things\r\n      \r\n    } catch (error) {\r\n      console.error('[WalletContext] Failed to fetch transaction history:', error);\r\n    }\r\n  }, [apiClient]);\r\n\r\n  // CRITICAL FIX: Fetch admin platform wallet balance with proper throttling\r\n  const fetchAdminPlatformBalance = useCallback(async (): Promise<number> => {\r\n    if (!user || (user.role !== 'admin' && !isAdminUser(user.username))) {\r\n      debugLog('Not admin user, skipping platform balance fetch');\r\n      return 0;\r\n    }\r\n\r\n    // CRITICAL FIX: Throttle platform balance fetches to prevent infinite loop\r\n    const now = Date.now();\r\n    if (lastPlatformBalanceFetch.current) {\r\n      const { balance: lastBalance, timestamp: lastTime } = lastPlatformBalanceFetch.current;\r\n      // If we fetched within the last 5 seconds, return cached value\r\n      if ((now - lastTime) < 5000) {\r\n        debugLog('Returning cached platform balance (throttled):', lastBalance);\r\n        return lastBalance;\r\n      }\r\n    }\r\n\r\n    // Check if we're already fetching to prevent concurrent calls\r\n    const throttleKey = 'admin_platform_balance_fetch';\r\n    if (throttleManager.current.shouldThrottle(throttleKey, 5000)) {\r\n      debugLog('Platform balance fetch throttled, returning current balance:', adminBalance);\r\n      return adminBalance;\r\n    }\r\n\r\n    try {\r\n      console.log('[Wallet] Admin requesting unified platform wallet balance...');\r\n      \r\n      // Always use the unified endpoint\r\n      const response = await apiClient.get<any>('/wallet/admin-platform-balance');\r\n      \r\n      debugLog('Unified platform balance response:', response);\r\n      \r\n      if (response.success && response.data) {\r\n        const balance = response.data.balance || 0;\r\n        console.log('[Wallet] Unified platform wallet balance:', balance);\r\n        \r\n        // Cache the fetched balance\r\n        lastPlatformBalanceFetch.current = { balance, timestamp: now };\r\n        \r\n        // Only update state if balance actually changed\r\n        if (balance !== adminBalance) {\r\n          // Set this as THE admin balance for all admin users\r\n          setAdminBalanceState(balance);\r\n          \r\n          // Fire event with deduplication\r\n          fireAdminBalanceUpdateEvent(balance);\r\n        } else {\r\n          debugLog('Balance unchanged, skipping state update');\r\n        }\r\n        \r\n        return balance;\r\n      }\r\n      \r\n      console.warn('[Wallet] Platform balance fetch failed:', response.error);\r\n      return adminBalance; // Return current balance on failure\r\n    } catch (error) {\r\n      console.error('[Wallet] Error fetching platform balance:', error);\r\n      return adminBalance; // Return current balance on error\r\n    }\r\n  }, [user, apiClient, fireAdminBalanceUpdateEvent, adminBalance]);\r\n\r\n  // CRITICAL FIX: Fetch admin actions from API with throttling\r\n  const fetchAdminActions = useCallback(async (): Promise<void> => {\r\n    if (!user || (user.role !== 'admin' && !isAdminUser(user.username))) {\r\n      debugLog('Not admin user, skipping admin actions fetch');\r\n      return;\r\n    }\r\n\r\n    // Throttle admin actions fetch to prevent rapid calls\r\n    const now = Date.now();\r\n    if (now - lastAdminActionsFetch.current < 30000) { // 30 second minimum between fetches\r\n      debugLog('Admin actions fetch throttled');\r\n      return;\r\n    }\r\n\r\n    try {\r\n      debugLog('Fetching admin actions...');\r\n      lastAdminActionsFetch.current = now;\r\n      \r\n      const response = await apiClient.get<any>('/admin/actions?limit=100');\r\n      \r\n      debugLog('Admin actions response:', response);\r\n      \r\n      if (response.success && response.data) {\r\n        // Normalize the admin actions data\r\n        const normalizedActions = response.data.map((action: any) => ({\r\n          id: action._id || action.id,\r\n          _id: action._id || action.id,\r\n          type: action.type,\r\n          amount: action.amount,\r\n          reason: action.reason,\r\n          date: action.date,\r\n          metadata: action.metadata || {},\r\n          targetUser: action.metadata?.seller || action.metadata?.username,\r\n          username: action.metadata?.seller || action.metadata?.username,\r\n          adminUser: action.adminUser || 'platform',\r\n          role: action.metadata?.role\r\n        }));\r\n        \r\n        setAdminActions(normalizedActions);\r\n        debugLog('Admin actions loaded:', normalizedActions.length);\r\n      } else {\r\n        console.warn('[WalletContext] Admin actions fetch failed:', response.error);\r\n      }\r\n    } catch (error) {\r\n      console.error('[WalletContext] Error fetching admin actions:', error);\r\n    }\r\n  }, [user, apiClient]);\r\n\r\n  // FIXED: Define reloadData BEFORE it's used in other functions\r\n  const reloadData = useCallback(async () => {\r\n    if (isLoading) {\r\n      debugLog('Already loading, skipping reload');\r\n      return;\r\n    }\r\n    \r\n    setIsLoading(true);\r\n    try {\r\n      // Note: loadAllData will be defined later, so we need to be careful here\r\n      // For now, we'll just set a flag and handle the actual loading later\r\n      debugLog('Reload data requested');\r\n      \r\n      // For admin users, also refresh admin actions\r\n      if (user?.role === 'admin' || isAdminUser(user?.username || '')) {\r\n        await fetchAdminActions();\r\n      }\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  }, [isLoading, user, fetchAdminActions]);\r\n\r\n  // WebSocket event handlers\r\n  const handleWalletBalanceUpdate = useCallback((data: any) => {\r\n    debugLog('Received wallet:balance_update:', data);\r\n    \r\n    // Check for duplicate\r\n    if (deduplicationManager.current.isDuplicate('balance_update', data)) {\r\n      debugLog('Skipping duplicate balance update');\r\n      return;\r\n    }\r\n    \r\n    // Validate incoming data with security service\r\n    try {\r\n      // Sanitize username\r\n      const sanitizedUsername = data.username ? sanitizeUsername(data.username) : null;\r\n      if (!sanitizedUsername) {\r\n        console.error('[WalletContext] Invalid username in balance update');\r\n        return;\r\n      }\r\n      \r\n      // FIX: Handle different data structures from WebSocket\r\n      let balanceValue: number;\r\n      \r\n      // Check if balance is provided directly\r\n      if (typeof data.balance === 'number') {\r\n        balanceValue = data.balance;\r\n      }\r\n      // Check if it's in newBalance field (from backend WebSocket emit)\r\n      else if (typeof data.newBalance === 'number') {\r\n        balanceValue = data.newBalance;\r\n      }\r\n      // Check if it's nested in a data object\r\n      else if (data.data && typeof data.data.balance === 'number') {\r\n        balanceValue = data.data.balance;\r\n      }\r\n      // Default to 0 if no valid balance found\r\n      else {\r\n        console.warn('[WalletContext] No valid balance in update data:', data);\r\n        balanceValue = 0;\r\n      }\r\n      \r\n      // Validate balance amount\r\n      const balanceValidation = walletOperationSchemas.balanceAmount.safeParse(balanceValue);\r\n      if (!balanceValidation.success) {\r\n        console.error('[WalletContext] Invalid balance amount:', balanceValidation.error);\r\n        return;\r\n      }\r\n      \r\n      const validatedBalance = balanceValidation.data;\r\n      \r\n      // Process the balance update based on role\r\n      if (data.role === 'admin' || sanitizedUsername === 'platform' || isAdminUser(sanitizedUsername)) {\r\n        // Admin balance update - only update if value changed\r\n        if (user && (user.role === 'admin' || isAdminUser(user.username))) {\r\n          if (adminBalance !== validatedBalance) {\r\n            debugLog('Updating admin balance to:', validatedBalance);\r\n            setAdminBalanceState(validatedBalance);\r\n            \r\n            // Fire event for admin balance changes with deduplication\r\n            fireAdminBalanceUpdateEvent(validatedBalance);\r\n          }\r\n        }\r\n      } else if (data.role === 'buyer') {\r\n        // Update buyer balance\r\n        setBuyerBalancesState(prev => ({\r\n          ...prev,\r\n          [sanitizedUsername]: validatedBalance\r\n        }));\r\n        \r\n        // Fire event if current user\r\n        if (user && user.username === sanitizedUsername) {\r\n          window.dispatchEvent(new CustomEvent('wallet:buyer-balance-updated', {\r\n            detail: { balance: validatedBalance, timestamp: Date.now() }\r\n          }));\r\n        }\r\n      } else if (data.role === 'seller') {\r\n        // Update seller balance\r\n        setSellerBalancesState(prev => ({\r\n          ...prev,\r\n          [sanitizedUsername]: validatedBalance\r\n        }));\r\n        \r\n        // Fire event if current user\r\n        if (user && user.username === sanitizedUsername) {\r\n          window.dispatchEvent(new CustomEvent('wallet:seller-balance-updated', {\r\n            detail: { balance: validatedBalance, timestamp: Date.now() }\r\n          }));\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error('[WalletContext] Error processing balance update:', error);\r\n    }\r\n  }, [user, fireAdminBalanceUpdateEvent, adminBalance]);\r\n\r\n  const handlePlatformBalanceUpdate = useCallback((data: any) => {\r\n    debugLog('Received platform:balance_update:', data);\r\n    \r\n    // Check for duplicate\r\n    if (deduplicationManager.current.isDuplicate('platform_balance', data)) {\r\n      debugLog('Skipping duplicate platform balance update');\r\n      return;\r\n    }\r\n    \r\n    // Handle different data structures\r\n    let balanceValue: number;\r\n    \r\n    if (typeof data.balance === 'number') {\r\n      balanceValue = data.balance;\r\n    } else if (typeof data.newBalance === 'number') {\r\n      balanceValue = data.newBalance;\r\n    } else if (data.data && typeof data.data.balance === 'number') {\r\n      balanceValue = data.data.balance;\r\n    } else {\r\n      console.warn('[WalletContext] No valid balance in platform update:', data);\r\n      balanceValue = 0;\r\n    }\r\n    \r\n    // Validate balance\r\n    const balanceValidation = walletOperationSchemas.balanceAmount.safeParse(balanceValue);\r\n    if (!balanceValidation.success) {\r\n      console.error('[WalletContext] Invalid platform balance:', balanceValidation.error);\r\n      return;\r\n    }\r\n    \r\n    // If current user is admin, update admin balance only if changed\r\n    if (user && (user.role === 'admin' || isAdminUser(user.username))) {\r\n      const newBalance = balanceValidation.data;\r\n      if (adminBalance !== newBalance) {\r\n        debugLog('Updating platform balance to:', newBalance);\r\n        setAdminBalanceState(newBalance);\r\n        \r\n        // Fire event with deduplication\r\n        fireAdminBalanceUpdateEvent(newBalance);\r\n      }\r\n    }\r\n  }, [user, fireAdminBalanceUpdateEvent, adminBalance]);\r\n\r\n  // CRITICAL: Add handler for order:created events\r\n  const handleOrderCreated = useCallback((data: any) => {\r\n    debugLog('Received order:created event:', data);\r\n    \r\n    // Check for duplicate\r\n    if (deduplicationManager.current.isDuplicate('order_created', data)) {\r\n      debugLog('Skipping duplicate order created event');\r\n      return;\r\n    }\r\n    \r\n    const order = data.order || data;\r\n    \r\n    // Check if this order is for the current user\r\n    if (user && (order.buyer === user.username || order.seller === user.username)) {\r\n      // Reload orders to get the new one\r\n      console.log('[WalletContext] New order for current user, refreshing orders');\r\n      fetchOrderHistory(user.username);\r\n    }\r\n  }, [user, fetchOrderHistory]);\r\n\r\n  const handleWalletTransaction = useCallback(async (data: any) => {\r\n    debugLog('Received wallet:transaction:', data);\r\n    \r\n    // Check for duplicate\r\n    if (deduplicationManager.current.isDuplicate('transaction', data)) {\r\n      debugLog('Skipping duplicate transaction');\r\n      return;\r\n    }\r\n    \r\n    // Validate transaction data\r\n    try {\r\n      // Sanitize usernames if present\r\n      const sanitizedFrom = data.from ? sanitizeUsername(data.from) : null;\r\n      const sanitizedTo = data.to ? sanitizeUsername(data.to) : null;\r\n      \r\n      // Validate amount if present\r\n      if (data.amount !== undefined) {\r\n        const amountValidation = walletOperationSchemas.transactionAmount.safeParse(data.amount);\r\n        if (!amountValidation.success) {\r\n          console.error('[WalletContext] Invalid transaction amount:', amountValidation.error);\r\n          return;\r\n        }\r\n      }\r\n      \r\n      // If transaction involves current user, refresh their data\r\n      if (user && (sanitizedFrom === user.username || sanitizedTo === user.username)) {\r\n        if (!throttleManager.current.shouldThrottle('user_data_refresh', 5000)) {\r\n          // Refresh both transactions and orders\r\n          await fetchTransactionHistory(user.username);\r\n          await fetchOrderHistory(user.username); \r\n        } else {\r\n          debugLog('Throttled user data refresh');\r\n        }\r\n      }\r\n      \r\n      // If transaction involves platform and user is admin, refresh admin data\r\n      if ((sanitizedFrom === 'platform' || sanitizedTo === 'platform') && \r\n          user && (user.role === 'admin' || isAdminUser(user.username))) {\r\n        if (!throttleManager.current.shouldThrottle('admin_platform_balance', 3000)) {\r\n          await fetchAdminPlatformBalance();\r\n          // Also refresh admin actions to get tier credit updates\r\n          await fetchAdminActions();\r\n        } else {\r\n          debugLog('Throttled admin platform balance refresh');\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error('[WalletContext] Error processing transaction:', error);\r\n    }\r\n  }, [user, fetchTransactionHistory, fetchOrderHistory, fetchAdminPlatformBalance, fetchAdminActions]);\r\n\r\n  // Consolidated WebSocket subscriptions\r\n  useEffect(() => {\r\n    if (!isConnected || !subscribe) return;\r\n\r\n    debugLog('Setting up WebSocket subscriptions for wallet updates');\r\n\r\n    // Subscribe to wallet:balance_update events\r\n    const unsubBalance = subscribe('wallet:balance_update' as WebSocketEvent, handleWalletBalanceUpdate);\r\n\r\n    // Subscribe to platform:balance_update events\r\n    const unsubPlatform = subscribe('platform:balance_update' as WebSocketEvent, handlePlatformBalanceUpdate);\r\n\r\n    // Subscribe to wallet:transaction events\r\n    const unsubTransaction = subscribe('wallet:transaction' as WebSocketEvent, handleWalletTransaction);\r\n    \r\n    // CRITICAL: Subscribe to order:created events\r\n    const unsubOrderCreated = subscribe('order:created' as WebSocketEvent, handleOrderCreated);\r\n\r\n    // Cleanup subscriptions\r\n    return () => {\r\n      unsubBalance();\r\n      unsubPlatform();\r\n      unsubTransaction();\r\n      unsubOrderCreated();\r\n    };\r\n  }, [isConnected, subscribe, handleWalletBalanceUpdate, handlePlatformBalanceUpdate, handleWalletTransaction, handleOrderCreated]);\r\n\r\n  // Listen to custom WebSocket balance updates via events (backward compatibility)\r\n  useEffect(() => {\r\n    if (typeof window === 'undefined') return;\r\n\r\n    const handleBalanceUpdate = (event: CustomEvent) => {\r\n      const data = event.detail;\r\n      debugLog('Received custom balance update event:', data);\r\n      handleWalletBalanceUpdate(data);\r\n    };\r\n\r\n    const handleTransaction = (event: CustomEvent) => {\r\n      debugLog('Received custom transaction event:', event.detail);\r\n      handleWalletTransaction(event.detail);\r\n    };\r\n    \r\n    const handleOrderEvent = (event: CustomEvent) => {\r\n      debugLog('Received custom order event:', event.detail);\r\n      handleOrderCreated(event.detail);\r\n    };\r\n\r\n    // Listen for custom events from other components\r\n    window.addEventListener('wallet:balance_update', handleBalanceUpdate as EventListener);\r\n    window.addEventListener('wallet:transaction', handleTransaction as EventListener);\r\n    window.addEventListener('order:created', handleOrderEvent as EventListener);\r\n\r\n    return () => {\r\n      window.removeEventListener('wallet:balance_update', handleBalanceUpdate as EventListener);\r\n      window.removeEventListener('wallet:transaction', handleTransaction as EventListener);\r\n      window.removeEventListener('order:created', handleOrderEvent as EventListener);\r\n    };\r\n  }, [handleWalletBalanceUpdate, handleWalletTransaction, handleOrderCreated]);\r\n\r\n  // Helper to emit wallet balance updates\r\n  const emitBalanceUpdate = useCallback((username: string, role: 'buyer' | 'seller' | 'admin', balance: number) => {\r\n    if (isConnected && sendMessage) {\r\n      sendMessage(WebSocketEvent.WALLET_BALANCE_UPDATE, {\r\n        username,\r\n        role,\r\n        balance,\r\n        timestamp: Date.now()\r\n      });\r\n    }\r\n  }, [isConnected, sendMessage]);\r\n\r\n  // Send tip function\r\n  const sendTip = useCallback(async (\r\n    fromUsername: string, \r\n    toUsername: string, \r\n    amount: number,\r\n    message?: string\r\n  ): Promise<boolean> => {\r\n    try {\r\n      checkRateLimit('TIP', fromUsername);\r\n      \r\n      // Input validation\r\n      if (!fromUsername || !toUsername || amount <= 0) {\r\n        console.error('[Wallet] Invalid tip parameters');\r\n        return false;\r\n      }\r\n      \r\n      // Validate and sanitize inputs\r\n      const validatedFrom = validateUsername(fromUsername);\r\n      const validatedTo = validateUsername(toUsername);\r\n      const validatedAmount = validateTransactionAmount(amount);\r\n      \r\n      // Additional tip-specific validation\r\n      const tipValidation = walletOperationSchemas.tipAmount.safeParse(validatedAmount);\r\n      if (!tipValidation.success) {\r\n        console.error('[Wallet] Invalid tip amount:', tipValidation.error);\r\n        return false;\r\n      }\r\n      \r\n      // Check balance locally first\r\n      const senderBalance = buyerBalances[validatedFrom] || 0;\r\n      if (senderBalance < validatedAmount) {\r\n        console.error('[Wallet] Insufficient balance for tip');\r\n        return false;\r\n      }\r\n      \r\n      // Send tip to backend\r\n      const response = await apiClient.post<any>('/tips/send', {\r\n        amount: validatedAmount,\r\n        recipientUsername: validatedTo,\r\n        message: message ? sanitizeStrict(message) : undefined\r\n      });\r\n      \r\n      if (!response.success) {\r\n        console.error('[Wallet] Tip failed:', response.error);\r\n        return false;\r\n      }\r\n      \r\n      // Update local state optimistically\r\n      setBuyerBalancesState(prev => ({\r\n        ...prev,\r\n        [validatedFrom]: prev[validatedFrom] - validatedAmount\r\n      }));\r\n      \r\n      setSellerBalancesState(prev => ({\r\n        ...prev,\r\n        [validatedTo]: (prev[validatedTo] || 0) + validatedAmount\r\n      }));\r\n      \r\n      // Emit balance updates\r\n      emitBalanceUpdate(validatedFrom, 'buyer', senderBalance - validatedAmount);\r\n      emitBalanceUpdate(validatedTo, 'seller', (sellerBalances[validatedTo] || 0) + validatedAmount);\r\n      \r\n      // Log the transaction locally\r\n      const tipLog: DepositLog = {\r\n        id: response.data?.transaction?.id || uuidv4(),\r\n        username: validatedFrom,\r\n        amount: validatedAmount,\r\n        method: 'credit_card',\r\n        date: new Date().toISOString(),\r\n        status: 'completed',\r\n        transactionId: response.data?.transaction?.id || uuidv4(),\r\n        notes: `Tip to ${validatedTo}`,\r\n      };\r\n      \r\n      setDepositLogs(prev => [...prev, tipLog]);\r\n      \r\n      debugLog(`[Wallet] Tip sent: $${validatedAmount} from ${validatedFrom} to ${validatedTo}`);\r\n      return true;\r\n      \r\n    } catch (error) {\r\n      console.error('[Wallet] Error sending tip:', error);\r\n      return false;\r\n    }\r\n  }, [buyerBalances, sellerBalances, apiClient, emitBalanceUpdate]);\r\n\r\n  // Fetch balance from API\r\n  const fetchBalance = useCallback(async (username: string): Promise<number> => {\r\n    try {\r\n      debugLog('Fetching balance for:', username);\r\n      \r\n      // For admin users, always fetch platform wallet\r\n      if (isAdminUser(username)) {\r\n        debugLog('Admin user detected, fetching unified platform wallet');\r\n        \r\n        const response = await apiClient.get<any>('/wallet/admin-platform-balance');\r\n        \r\n        if (response.success && response.data) {\r\n          const balance = response.data.balance || 0;\r\n          debugLog('Unified platform wallet balance:', balance);\r\n          return balance;\r\n        }\r\n        \r\n        console.warn('[WalletContext] Platform balance fetch failed:', response.error);\r\n        return 0;\r\n      }\r\n      \r\n      // For regular users, fetch their individual wallet\r\n      const response = await apiClient.get<any>(`/wallet/balance/${username}`);\r\n      \r\n      debugLog('Balance response:', response);\r\n      \r\n      if (response.success && response.data) {\r\n        return response.data.balance || 0;\r\n      }\r\n      \r\n      console.warn('[WalletContext] Balance fetch failed:', response.error);\r\n      return 0;\r\n    } catch (error) {\r\n      console.error(`[WalletContext] Failed to fetch balance for ${username}:`, error);\r\n      return 0;\r\n    }\r\n  }, [apiClient]);\r\n\r\n  // Get platform transactions\r\n  const getPlatformTransactions = useCallback(async (limit: number = 100, page: number = 1): Promise<any[]> => {\r\n    if (!user || (user.role !== 'admin' && !isAdminUser(user.username))) {\r\n      debugLog('Not admin user, skipping platform transactions fetch');\r\n      return [];\r\n    }\r\n\r\n    try {\r\n      debugLog('Fetching platform transactions...');\r\n      \r\n      const response = await apiClient.get<any>(`/wallet/platform-transactions?limit=${limit}&page=${page}`);\r\n      \r\n      debugLog('Platform transactions response:', response);\r\n      \r\n      if (response.success && response.data) {\r\n        return response.data;\r\n      }\r\n      \r\n      console.warn('[WalletContext] Platform transactions fetch failed:', response.error);\r\n      return [];\r\n    } catch (error) {\r\n      console.error('[WalletContext] Error fetching platform transactions:', error);\r\n      return [];\r\n    }\r\n  }, [user, apiClient]);\r\n\r\n  // Fetch complete admin analytics data\r\n  const fetchAdminAnalytics = useCallback(async (timeFilter: string = 'all'): Promise<any> => {\r\n    if (!user || (user.role !== 'admin' && !isAdminUser(user.username))) {\r\n      debugLog('Not admin user, skipping analytics fetch');\r\n      return null;\r\n    }\r\n\r\n    try {\r\n      debugLog('Fetching admin analytics data with filter:', timeFilter);\r\n      \r\n      const response = await apiClient.get<any>(`/wallet/admin/analytics?timeFilter=${timeFilter}`);\r\n      \r\n      debugLog('Admin analytics response:', response);\r\n      \r\n      if (response.success && response.data) {\r\n        const data = response.data;\r\n        \r\n        // Update all the state variables with the fetched data\r\n        // IMPORTANT: Admin balance is the unified platform wallet balance\r\n        if (data.adminBalance !== adminBalance) {\r\n          setAdminBalanceState(data.adminBalance);\r\n          fireAdminBalanceUpdateEvent(data.adminBalance);\r\n        }\r\n        \r\n        setOrderHistory(data.orderHistory);\r\n        setDepositLogs(data.depositLogs);\r\n        setSellerWithdrawals(data.sellerWithdrawals);\r\n        setAdminWithdrawals(data.adminWithdrawals);\r\n        \r\n        // If adminActions are included in the response, use them\r\n        // Otherwise, fetch them separately\r\n        if (data.adminActions && data.adminActions.length > 0) {\r\n          setAdminActions(data.adminActions);\r\n        } else {\r\n          // Fetch admin actions separately if not included\r\n          await fetchAdminActions();\r\n        }\r\n        \r\n        // Update wallet balances\r\n        if (data.wallet) {\r\n          Object.entries(data.wallet).forEach(([username, balance]) => {\r\n            if (data.users[username]) {\r\n              const userRole = data.users[username].role;\r\n              // Skip admin users as they use unified balance\r\n              if (userRole === 'admin' || isAdminUser(username)) {\r\n                // Don't set individual balances for admin users\r\n                return;\r\n              } else if (userRole === 'buyer') {\r\n                setBuyerBalancesState(prev => ({ ...prev, [username]: balance as number }));\r\n              } else if (userRole === 'seller') {\r\n                setSellerBalancesState(prev => ({ ...prev, [username]: balance as number }));\r\n              }\r\n            }\r\n          });\r\n        }\r\n        \r\n        debugLog('Analytics data loaded:', {\r\n          adminBalance: data.adminBalance,\r\n          orders: data.orderHistory.length,\r\n          deposits: data.depositLogs.length,\r\n          adminActions: adminActions.length,\r\n          summary: data.summary\r\n        });\r\n        \r\n        return data;\r\n      }\r\n      \r\n      console.warn('[WalletContext] Analytics fetch failed:', response.error);\r\n      return null;\r\n    } catch (error) {\r\n      console.error('[WalletContext] Error fetching analytics:', error);\r\n      return null;\r\n    }\r\n  }, [user, apiClient, fireAdminBalanceUpdateEvent, fetchAdminActions, adminActions.length, adminBalance]);\r\n\r\n  // Get analytics data with time filter\r\n  const getAnalyticsData = useCallback(async (timeFilter: string = 'all') => {\r\n    if (!user || (user.role !== 'admin' && !isAdminUser(user.username))) {\r\n      debugLog('Not admin, cannot get analytics');\r\n      return null;\r\n    }\r\n    \r\n    return await fetchAdminAnalytics(timeFilter);\r\n  }, [user, fetchAdminAnalytics]);\r\n\r\n  // Load all data from API with admin analytics support\r\n  const loadAllData = useCallback(async () => {\r\n    if (!user) {\r\n      debugLog('No user, skipping data load');\r\n      return false;\r\n    }\r\n\r\n    try {\r\n      debugLog('Loading wallet data from API for user:', user.username);\r\n      \r\n      // For admin users, always fetch unified platform wallet\r\n      if (user.role === 'admin' || isAdminUser(user.username)) {\r\n        debugLog('Admin detected - fetching unified platform wallet...');\r\n        \r\n        // Fetch unified platform balance\r\n        const platformBalance = await fetchAdminPlatformBalance();\r\n        \r\n        // Fetch admin actions for tier credit tracking\r\n        await fetchAdminActions();\r\n        \r\n        // Also fetch analytics data if needed\r\n        const analyticsData = await fetchAdminAnalytics('all');\r\n        \r\n        if (analyticsData) {\r\n          // Override the admin balance with unified platform balance\r\n          if (platformBalance !== adminBalance) {\r\n            setAdminBalanceState(platformBalance);\r\n            fireAdminBalanceUpdateEvent(platformBalance);\r\n          }\r\n          \r\n          debugLog('Admin analytics loaded with unified balance:', platformBalance);\r\n        }\r\n        \r\n        return true;\r\n      }\r\n      \r\n      // For non-admin users, fetch regular wallet data\r\n      const balance = await fetchBalance(user.username);\r\n      debugLog('Fetched balance:', balance, 'for role:', user.role);\r\n      \r\n      if (user.role === 'buyer') {\r\n        setBuyerBalancesState(prev => ({ ...prev, [user.username]: balance }));\r\n      } else if (user.role === 'seller') {\r\n        setSellerBalancesState(prev => ({ ...prev, [user.username]: balance }));\r\n      }\r\n      \r\n      // CRITICAL: Fetch actual orders, not transactions\r\n      await fetchOrderHistory(user.username);\r\n      \r\n      // Also fetch transaction history for reference\r\n      await fetchTransactionHistory(user.username);\r\n      \r\n      debugLog('Data loaded successfully');\r\n      return true;\r\n    } catch (error) {\r\n      console.error('[WalletContext] Error loading wallet data:', error);\r\n      setInitializationError('Failed to load wallet data');\r\n      return false;\r\n    }\r\n  }, [user, fetchBalance, fetchAdminPlatformBalance, fetchAdminAnalytics, fetchOrderHistory, fetchTransactionHistory, fireAdminBalanceUpdateEvent, fetchAdminActions, adminBalance]);\r\n\r\n  // CRITICAL FIX: Refresh admin data with proper throttling\r\n  const refreshAdminData = useCallback(async () => {\r\n    if (!user || (user.role !== 'admin' && !isAdminUser(user.username))) {\r\n      debugLog('Not admin, skipping admin data refresh');\r\n      return;\r\n    }\r\n    \r\n    // Add throttling to prevent rapid refreshes\r\n    if (throttleManager.current.shouldThrottle('refresh_admin_data', 10000)) {\r\n      debugLog('Admin data refresh throttled');\r\n      return;\r\n    }\r\n    \r\n    try {\r\n      debugLog('Refreshing admin data...');\r\n      \r\n      // Fetch unified platform balance (now properly throttled)\r\n      const platformBalance = await fetchAdminPlatformBalance();\r\n      \r\n      // Fetch admin actions (only if needed)\r\n      if (!throttleManager.current.shouldThrottle('fetch_admin_actions', 30000)) {\r\n        await fetchAdminActions();\r\n      }\r\n      \r\n      // Only fetch analytics if significant time has passed\r\n      if (!throttleManager.current.shouldThrottle('fetch_analytics', 60000)) {\r\n        const analyticsData = await fetchAdminAnalytics('all');\r\n        \r\n        if (analyticsData && analyticsData.adminBalance !== platformBalance) {\r\n          // Ensure unified balance is used\r\n          setAdminBalanceState(platformBalance);\r\n          fireAdminBalanceUpdateEvent(platformBalance);\r\n        }\r\n        \r\n        debugLog('Admin data refreshed with unified balance:', platformBalance);\r\n      }\r\n    } catch (error) {\r\n      console.error('[WalletContext] Error refreshing admin data:', error);\r\n    }\r\n  }, [user, fetchAdminPlatformBalance, fetchAdminAnalytics, fireAdminBalanceUpdateEvent, fetchAdminActions]);\r\n\r\n  // Initialize wallet when user logs in\r\n  useEffect(() => {\r\n    const initializeWallet = async () => {\r\n      if (initializingRef.current || !user) {\r\n        return;\r\n      }\r\n      \r\n      initializingRef.current = true;\r\n      setIsLoading(true);\r\n      setInitializationError(null);\r\n\r\n      try {\r\n        debugLog('Initializing wallet for user:', user.username);\r\n        \r\n        const loadSuccess = await loadAllData();\r\n        \r\n        if (loadSuccess) {\r\n          setIsInitialized(true);\r\n          debugLog('Wallet initialization complete');\r\n        }\r\n      } catch (error) {\r\n        console.error('[WalletContext] Initialization error:', error);\r\n        setInitializationError(error instanceof Error ? error.message : 'Unknown error');\r\n      } finally {\r\n        setIsLoading(false);\r\n        initializingRef.current = false;\r\n      }\r\n    };\r\n\r\n    if (user) {\r\n      initializeWallet();\r\n    } else {\r\n      // Clear wallet data when user logs out\r\n      setBuyerBalancesState({});\r\n      setSellerBalancesState({});\r\n      setAdminBalanceState(0);\r\n      setOrderHistory([]);\r\n      setIsInitialized(false);\r\n      deduplicationManager.current.destroy();\r\n      deduplicationManager.current = new DeduplicationManager(30000);\r\n      throttleManager.current.clear();\r\n      lastPlatformBalanceFetch.current = null;\r\n      lastFiredBalanceRef.current = null;\r\n      lastAdminActionsFetch.current = 0;\r\n    }\r\n  }, [user, loadAllData]);\r\n\r\n  // Balance getters (from cached state)\r\n  const getBuyerBalance = useCallback((username: string): number => {\r\n    try {\r\n      const validatedUsername = validateUsername(username);\r\n      // Admin users don't have buyer balances\r\n      if (isAdminUser(validatedUsername)) {\r\n        return 0;\r\n      }\r\n      return buyerBalances[validatedUsername] || 0;\r\n    } catch {\r\n      return 0;\r\n    }\r\n  }, [buyerBalances]);\r\n\r\n  const getSellerBalance = useCallback((seller: string): number => {\r\n    try {\r\n      const validatedSeller = validateUsername(seller);\r\n      // Admin users don't have seller balances\r\n      if (isAdminUser(validatedSeller)) {\r\n        return 0;\r\n      }\r\n      return sellerBalances[validatedSeller] || 0;\r\n    } catch {\r\n      return 0;\r\n    }\r\n  }, [sellerBalances]);\r\n\r\n  // Balance setters (update cache and call API)\r\n  const setBuyerBalance = useCallback(async (username: string, balance: number) => {\r\n    // Don't set buyer balance for admin users\r\n    if (isAdminUser(username)) {\r\n      debugLog('Skipping buyer balance update for admin user');\r\n      return;\r\n    }\r\n    \r\n    const validatedUsername = validateUsername(username);\r\n    \r\n    // Update local cache immediately\r\n    setBuyerBalancesState((prev) => ({\r\n      ...prev,\r\n      [validatedUsername]: balance,\r\n    }));\r\n    \r\n    // Emit WebSocket update\r\n    emitBalanceUpdate(validatedUsername, 'buyer', balance);\r\n  }, [emitBalanceUpdate]);\r\n\r\n  const setSellerBalance = useCallback(async (seller: string, balance: number) => {\r\n    // Don't set seller balance for admin users\r\n    if (isAdminUser(seller)) {\r\n      debugLog('Skipping seller balance update for admin user');\r\n      return;\r\n    }\r\n    \r\n    const validatedSeller = validateUsername(seller);\r\n    \r\n    // Update local cache immediately\r\n    setSellerBalancesState((prev) => ({\r\n      ...prev,\r\n      [validatedSeller]: balance,\r\n    }));\r\n    \r\n    // Emit WebSocket update\r\n    emitBalanceUpdate(validatedSeller, 'seller', balance);\r\n  }, [emitBalanceUpdate]);\r\n\r\n  const setAdminBalance = useCallback(async (balance: number) => {\r\n    // Only update if changed\r\n    if (adminBalance !== balance) {\r\n      setAdminBalanceState(balance);\r\n      fireAdminBalanceUpdateEvent(balance);\r\n      \r\n      // Emit WebSocket update for platform wallet\r\n      emitBalanceUpdate('platform', 'admin', balance);\r\n    }\r\n  }, [emitBalanceUpdate, fireAdminBalanceUpdateEvent, adminBalance]);\r\n\r\n  // Create order via API\r\n  const addOrder = useCallback(async (order: Order) => {\r\n    try {\r\n      debugLog('Creating order via API:', order);\r\n      \r\n      const orderPayload = {\r\n        title: order.title,\r\n        description: order.description,\r\n        price: order.price,\r\n        markedUpPrice: order.markedUpPrice,\r\n        seller: order.seller,\r\n        buyer: order.buyer,\r\n        tags: order.tags || [],\r\n        wasAuction: order.wasAuction || false,\r\n        imageUrl: order.imageUrl,\r\n        listingId: order.listingId,\r\n        deliveryAddress: order.deliveryAddress || {\r\n          fullName: 'John Doe',\r\n          addressLine1: '123 Main St',\r\n          city: 'New York',\r\n          state: 'NY',\r\n          postalCode: '10001',\r\n          country: 'US',\r\n        },\r\n      };\r\n\r\n      debugLog('Order payload:', orderPayload);\r\n\r\n      const response = await apiClient.post<any>('/orders', orderPayload);\r\n\r\n      debugLog('Order creation response:', response);\r\n\r\n      if (response.success && response.data) {\r\n        // Include tier information in the order\r\n        const orderWithTier = {\r\n          ...response.data,\r\n          sellerTier: response.data.sellerTier,\r\n          tierCreditAmount: response.data.tierCreditAmount || 0\r\n        };\r\n        \r\n        setOrderHistory((prev) => [...prev, orderWithTier]);\r\n        \r\n        // Only fetch current user's balance after order creation\r\n        if (user?.username) {\r\n          const newBalance = await fetchBalance(user.username);\r\n          \r\n          if (user.role === 'buyer') {\r\n            setBuyerBalancesState(prev => ({ ...prev, [user.username]: newBalance }));\r\n          } else if (user.role === 'seller') {\r\n            setSellerBalancesState(prev => ({ ...prev, [user.username]: newBalance }));\r\n          } else if (user.role === 'admin' || isAdminUser(user.username)) {\r\n            // For admin users, refresh platform balance AND admin actions\r\n            await refreshAdminData();\r\n          }\r\n        }\r\n        \r\n        // If current user is admin, refresh admin actions to get tier credits\r\n        if (user?.role === 'admin' || isAdminUser(user?.username || '')) {\r\n          await fetchAdminActions();\r\n        }\r\n        \r\n        // Refresh order history for current user only\r\n        if (user?.username) {\r\n          if (!throttleManager.current.shouldThrottle('order_refresh', 3000)) {\r\n            await fetchOrderHistory(user.username);\r\n          }\r\n        }\r\n        \r\n        debugLog('Order created and balance updated');\r\n      } else {\r\n        const errorMessage = response.error?.message || response.error || 'Order creation failed';\r\n        console.error('[WalletContext] Order creation failed:', errorMessage);\r\n        throw new Error(errorMessage);\r\n      }\r\n    } catch (error) {\r\n      console.error('[WalletContext] Failed to create order:', error);\r\n      throw error;\r\n    }\r\n  }, [apiClient, fetchBalance, fetchOrderHistory, refreshAdminData, user, fetchAdminActions]);\r\n\r\n  // UPDATED: Purchase custom request implementation\r\n  const purchaseCustomRequest = useCallback(async (request: CustomRequestPurchase): Promise<boolean> => {\r\n    console.log('[WalletContext] Processing custom request purchase:', request);\r\n    \r\n    try {\r\n      debugLog('Processing custom request via API:', {\r\n        requestId: request.requestId,\r\n        buyer: request.buyer,\r\n        seller: request.seller,\r\n        amount: request.amount\r\n      });\r\n      \r\n      // Prepare the request data for the backend\r\n      const orderRequest = {\r\n        requestId: request.requestId,\r\n        title: request.description || 'Custom Request',\r\n        description: request.metadata?.description || request.description,\r\n        price: request.amount,\r\n        seller: request.seller,\r\n        buyer: request.buyer,\r\n        tags: request.metadata?.tags || [],\r\n        deliveryAddress: undefined // Will be added later by buyer\r\n      };\r\n      \r\n      debugLog('Calling custom request endpoint with:', orderRequest);\r\n      \r\n      // Call the new custom request endpoint\r\n      const response = await apiClient.post<any>('/orders/custom-request', orderRequest);\r\n      \r\n      debugLog('Custom request order response:', response);\r\n      \r\n      if (response.success && response.data) {\r\n        console.log('[WalletContext] Custom request order created successfully:', response.data.id);\r\n        \r\n        // Add to order history\r\n        const orderWithDetails = {\r\n          ...response.data,\r\n          isCustomRequest: true,\r\n          originalRequestId: request.requestId\r\n        };\r\n        setOrderHistory(prev => [...prev, orderWithDetails]);\r\n        \r\n        // Now update reloadData to use loadAllData\r\n        await loadAllData();\r\n        \r\n        // Dispatch event for other components to react\r\n        window.dispatchEvent(new CustomEvent('custom_request:paid', {\r\n          detail: {\r\n            requestId: request.requestId,\r\n            orderId: response.data.id,\r\n            buyer: request.buyer,\r\n            seller: request.seller,\r\n            amount: request.amount\r\n          }\r\n        }));\r\n        \r\n        // If notification callback is set, notify seller\r\n        if (addSellerNotification) {\r\n          addSellerNotification(\r\n            request.seller,\r\n            `💰 Custom request \"${request.description}\" has been paid! Check your orders to fulfill.`\r\n          );\r\n        }\r\n        \r\n        return true;\r\n      } else {\r\n        console.error('[WalletContext] Failed to create custom request order:', response.error);\r\n        \r\n        // Check if it's an insufficient balance error\r\n        if (response.error?.message?.includes('Insufficient balance')) {\r\n          throw new Error(response.error.message);\r\n        }\r\n        \r\n        return false;\r\n      }\r\n      \r\n    } catch (error) {\r\n      console.error('[WalletContext] Error processing custom request purchase:', error);\r\n      \r\n      // Re-throw errors with message for UI to handle\r\n      if (error instanceof Error) {\r\n        throw error;\r\n      }\r\n      \r\n      throw new Error('Failed to process custom request payment');\r\n    }\r\n  }, [apiClient, loadAllData, addSellerNotification]);\r\n\r\n  // Make a deposit via API\r\n  const addDeposit = useCallback(async (\r\n    username: string, \r\n    amount: number, \r\n    method: DepositLog['method'], \r\n    notes?: string\r\n  ): Promise<boolean> => {\r\n    try {\r\n      checkRateLimit('DEPOSIT', username);\r\n      \r\n      const validatedUsername = validateUsername(username);\r\n      const validatedAmount = validateTransactionAmount(amount);\r\n      \r\n      debugLog('Processing deposit via API:', {\r\n        username: validatedUsername,\r\n        amount: validatedAmount,\r\n        method,\r\n        authUser: user?.username\r\n      });\r\n      \r\n      const response = await apiClient.post<any>('/wallet/deposit', {\r\n        amount: validatedAmount,\r\n        method,\r\n        notes,\r\n      });\r\n      \r\n      debugLog('Deposit response:', response);\r\n      \r\n      if (response.success) {\r\n        // Wait a moment for the transaction to be processed\r\n        await new Promise(resolve => setTimeout(resolve, 500));\r\n        \r\n        // Refresh balance after deposit\r\n        const newBalance = await fetchBalance(validatedUsername);\r\n        debugLog('New balance after deposit:', newBalance);\r\n        \r\n        if (!isAdminUser(validatedUsername)) {\r\n          setBuyerBalancesState(prev => ({ ...prev, [validatedUsername]: newBalance }));\r\n        }\r\n        \r\n        // Add to local deposit logs\r\n        const depositLog: DepositLog = {\r\n          id: response.data?.id || uuidv4(),\r\n          username: validatedUsername,\r\n          amount: validatedAmount,\r\n          method,\r\n          date: response.data?.createdAt || new Date().toISOString(),\r\n          status: 'completed',\r\n          transactionId: response.data?.id || uuidv4(),\r\n          notes,\r\n        };\r\n        \r\n        setDepositLogs(prev => [...prev, depositLog]);\r\n        \r\n        // Emit WebSocket event for real-time update\r\n        if (!isAdminUser(validatedUsername)) {\r\n          emitBalanceUpdate(validatedUsername, 'buyer', newBalance);\r\n        }\r\n        \r\n        debugLog('Deposit successful');\r\n        return true;\r\n      } else {\r\n        console.error('[WalletContext] Deposit failed:', response.error);\r\n        if (response.error?.message) {\r\n          throw new Error(response.error.message);\r\n        }\r\n        return false;\r\n      }\r\n    } catch (error) {\r\n      console.error('[WalletContext] Error processing deposit:', error);\r\n      throw error;\r\n    }\r\n  }, [apiClient, fetchBalance, emitBalanceUpdate, user]);\r\n\r\n  // Purchase listing with proper error handling\r\n  const purchaseListing = useCallback(async (listing: Listing, buyerUsername: string): Promise<boolean> => {\r\n    try {\r\n      checkRateLimit('API_CALL', buyerUsername);\r\n      \r\n      const validatedBuyer = validateUsername(buyerUsername);\r\n      const validatedSeller = validateUsername(listing.seller);\r\n      \r\n      // Validate price with security service\r\n      const priceValidation = securityService.validateAmount(listing.price, {\r\n        min: 0.01,\r\n        max: 100000\r\n      });\r\n      \r\n      if (!priceValidation.valid) {\r\n        throw new Error(priceValidation.error || 'Invalid listing price');\r\n      }\r\n      \r\n      debugLog('Processing purchase:', {\r\n        buyer: validatedBuyer,\r\n        seller: validatedSeller,\r\n        listing: listing.title,\r\n        price: listing.price,\r\n        markedUpPrice: listing.markedUpPrice\r\n      });\r\n      \r\n      await addOrder({\r\n        id: listing.id || uuidv4(),\r\n        title: listing.title,\r\n        description: listing.description,\r\n        price: listing.price,\r\n        markedUpPrice: listing.markedUpPrice || listing.price,\r\n        seller: validatedSeller,\r\n        buyer: validatedBuyer,\r\n        imageUrl: listing.imageUrls?.[0],\r\n        date: new Date().toISOString(),\r\n        shippingStatus: 'pending',\r\n        tags: listing.tags || [],\r\n        listingId: listing.id,\r\n        deliveryAddress: {\r\n          fullName: 'John Doe',\r\n          addressLine1: '123 Main St',\r\n          city: 'New York',\r\n          state: 'NY',\r\n          postalCode: '10001',\r\n          country: 'US',\r\n        },\r\n      });\r\n      \r\n      // Notification\r\n      if (addSellerNotification) {\r\n        addSellerNotification(\r\n          validatedSeller,\r\n          `New sale: \"${listing.title}\" for ${listing.price.toFixed(2)}`\r\n        );\r\n      }\r\n      \r\n      debugLog('Purchase successful');\r\n      return true;\r\n    } catch (error) {\r\n      console.error('[Purchase] Error:', error);\r\n      throw error;\r\n    }\r\n  }, [addOrder, addSellerNotification]);\r\n\r\n  // Withdraw funds via API\r\n  const addSellerWithdrawal = useCallback(async (username: string, amount: number) => {\r\n    try {\r\n      checkRateLimit('WITHDRAWAL', username);\r\n      \r\n      const validatedUsername = validateUsername(username);\r\n      const validatedAmount = validateTransactionAmount(amount);\r\n      \r\n      debugLog('Processing withdrawal via API:', {\r\n        username: validatedUsername,\r\n        amount: validatedAmount\r\n      });\r\n      \r\n      const response = await apiClient.post<any>('/wallet/withdraw', {\r\n        username: validatedUsername,\r\n        amount: validatedAmount,\r\n        accountDetails: {\r\n          accountNumber: '****1234',\r\n          routingNumber: '123456789',\r\n          accountType: 'checking',\r\n        },\r\n      });\r\n      \r\n      debugLog('Withdrawal response:', response);\r\n      \r\n      if (response.success) {\r\n        const newWithdrawal: Withdrawal = { \r\n          amount: validatedAmount, \r\n          date: response.data?.createdAt || new Date().toISOString(), \r\n          status: response.data?.status || 'pending'\r\n        };\r\n        \r\n        setSellerWithdrawals((prev) => ({\r\n          ...prev,\r\n          [validatedUsername]: [...(prev[validatedUsername] || []), newWithdrawal],\r\n        }));\r\n        \r\n        // Refresh balance\r\n        const newBalance = await fetchBalance(validatedUsername);\r\n        if (!isAdminUser(validatedUsername)) {\r\n          setSellerBalancesState(prev => ({ ...prev, [validatedUsername]: newBalance }));\r\n        }\r\n        \r\n        debugLog('Withdrawal successful');\r\n      } else {\r\n        console.error('[WalletContext] Withdrawal failed:', response.error);\r\n        throw new Error(response.error?.message || 'Withdrawal failed');\r\n      }\r\n    } catch (error) {\r\n      console.error('[WalletContext] Withdrawal error:', error);\r\n      throw error;\r\n    }\r\n  }, [apiClient, fetchBalance]);\r\n\r\n  // Admin credit via API\r\n  const adminCreditUser = useCallback(async (\r\n    username: string,\r\n    role: 'buyer' | 'seller',\r\n    amount: number,\r\n    reason: string\r\n  ): Promise<boolean> => {\r\n    try {\r\n      checkRateLimit('REPORT_ACTION', 'admin');\r\n      \r\n      const validatedUsername = validateUsername(username);\r\n      const validatedAmount = validateTransactionAmount(amount);\r\n      const sanitizedReason = sanitizeStrict(reason);\r\n      \r\n      debugLog('Processing admin credit via API:', {\r\n        username: validatedUsername,\r\n        role,\r\n        amount: validatedAmount,\r\n        reason: sanitizedReason\r\n      });\r\n      \r\n      const response = await apiClient.post<any>('/wallet/admin-actions', {\r\n        action: 'credit',\r\n        username: validatedUsername,\r\n        amount: validatedAmount,\r\n        reason: sanitizedReason,\r\n        adminUsername: user?.username || 'platform',\r\n      });\r\n      \r\n      debugLog('Admin credit response:', response);\r\n      \r\n      if (response.success) {\r\n        // Refresh balance\r\n        const newBalance = await fetchBalance(validatedUsername);\r\n        \r\n        if (role === 'buyer' && !isAdminUser(validatedUsername)) {\r\n          setBuyerBalancesState(prev => ({ ...prev, [validatedUsername]: newBalance }));\r\n        } else if (role === 'seller' && !isAdminUser(validatedUsername)) {\r\n          setSellerBalancesState(prev => ({ ...prev, [validatedUsername]: newBalance }));\r\n        }\r\n        \r\n        // Refresh platform balance after admin action\r\n        if (user?.role === 'admin' || isAdminUser(user?.username || '')) {\r\n          await fetchAdminPlatformBalance();\r\n          // Refresh admin actions after credit\r\n          await fetchAdminActions();\r\n        }\r\n        \r\n        // Update admin actions locally\r\n        const action: AdminAction = {\r\n          id: response.data?.id || uuidv4(),\r\n          type: 'credit',\r\n          amount: validatedAmount,\r\n          targetUser: validatedUsername,\r\n          username: validatedUsername,\r\n          adminUser: user?.username || 'platform',\r\n          reason: sanitizedReason,\r\n          date: response.data?.createdAt || new Date().toISOString(),\r\n          role,\r\n        };\r\n        \r\n        setAdminActions(prev => [...prev, action]);\r\n        \r\n        debugLog('Admin credit successful');\r\n        return true;\r\n      }\r\n      \r\n      console.error('[WalletContext] Admin credit failed:', response.error);\r\n      return false;\r\n    } catch (error) {\r\n      console.error('Admin credit error:', error);\r\n      return false;\r\n    }\r\n  }, [user, apiClient, fetchBalance, fetchAdminPlatformBalance, fetchAdminActions]);\r\n\r\n  // Admin debit via API\r\n  const adminDebitUser = useCallback(async (\r\n    username: string,\r\n    role: 'buyer' | 'seller',\r\n    amount: number,\r\n    reason: string\r\n  ): Promise<boolean> => {\r\n    try {\r\n      checkRateLimit('REPORT_ACTION', 'admin');\r\n      \r\n      const validatedUsername = validateUsername(username);\r\n      const validatedAmount = validateTransactionAmount(amount);\r\n      const sanitizedReason = sanitizeStrict(reason);\r\n      \r\n      debugLog('Processing admin debit via API:', {\r\n        username: validatedUsername,\r\n        role,\r\n        amount: validatedAmount,\r\n        reason: sanitizedReason\r\n      });\r\n      \r\n      const response = await apiClient.post<any>('/wallet/admin-actions', {\r\n        action: 'debit',\r\n        username: validatedUsername,\r\n        amount: validatedAmount,\r\n        reason: sanitizedReason,\r\n        adminUsername: user?.username || 'platform',\r\n      });\r\n      \r\n      debugLog('Admin debit response:', response);\r\n      \r\n      if (response.success) {\r\n        // Refresh balance\r\n        const newBalance = await fetchBalance(validatedUsername);\r\n        \r\n        if (role === 'buyer' && !isAdminUser(validatedUsername)) {\r\n          setBuyerBalancesState(prev => ({ ...prev, [validatedUsername]: newBalance }));\r\n        } else if (role === 'seller' && !isAdminUser(validatedUsername)) {\r\n          setSellerBalancesState(prev => ({ ...prev, [validatedUsername]: newBalance }));\r\n        }\r\n        \r\n        // Refresh platform balance after admin action\r\n        if (user?.role === 'admin' || isAdminUser(user?.username || '')) {\r\n          await fetchAdminPlatformBalance();\r\n          // Refresh admin actions after debit\r\n          await fetchAdminActions();\r\n        }\r\n        \r\n        // Update admin actions locally\r\n        const action: AdminAction = {\r\n          id: response.data?.id || uuidv4(),\r\n          type: 'debit',\r\n          amount: validatedAmount,\r\n          targetUser: validatedUsername,\r\n          username: validatedUsername,\r\n          adminUser: user?.username || 'platform',\r\n          reason: sanitizedReason,\r\n          date: response.data?.createdAt || new Date().toISOString(),\r\n          role,\r\n        };\r\n        \r\n        setAdminActions(prev => [...prev, action]);\r\n        \r\n        debugLog('Admin debit successful');\r\n        return true;\r\n      }\r\n      \r\n      console.error('[WalletContext] Admin debit failed:', response.error);\r\n      return false;\r\n    } catch (error) {\r\n      console.error('Admin debit error:', error);\r\n      return false;\r\n    }\r\n  }, [user, apiClient, fetchBalance, fetchAdminPlatformBalance, fetchAdminActions]);\r\n\r\n  // Get transaction history from API\r\n  const getTransactionHistory = useCallback(async (username?: string, limit?: number) => {\r\n    try {\r\n      const targetUsername = username || user?.username;\r\n      if (!targetUsername) {\r\n        console.warn('[WalletContext] No username for transaction history');\r\n        return [];\r\n      }\r\n      \r\n      // For admin users, use platform\r\n      const queryUsername = isAdminUser(targetUsername) ? 'platform' : targetUsername;\r\n      \r\n      const endpoint = `/wallet/transactions/${queryUsername}${limit ? `?limit=${limit}` : ''}`;\r\n      debugLog('Fetching transaction history:', endpoint);\r\n      \r\n      const response = await apiClient.get<any>(endpoint);\r\n      \r\n      debugLog('Transaction history response:', response);\r\n      \r\n      if (response.success && response.data) {\r\n        return response.data;\r\n      }\r\n      \r\n      return [];\r\n    } catch (error) {\r\n      console.error('Error getting transaction history:', error);\r\n      return [];\r\n    }\r\n  }, [apiClient, user]);\r\n\r\n  // UPDATE reloadData to use loadAllData properly\r\n  const updateReloadData = useCallback(async () => {\r\n    if (isLoading) {\r\n      debugLog('Already loading, skipping reload');\r\n      return;\r\n    }\r\n    \r\n    setIsLoading(true);\r\n    try {\r\n      await loadAllData();\r\n      // For admin users, also refresh admin actions\r\n      if (user?.role === 'admin' || isAdminUser(user?.username || '')) {\r\n        await fetchAdminActions();\r\n      }\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  }, [loadAllData, isLoading, user, fetchAdminActions]);\r\n\r\n  // Subscription payment via API\r\n  const subscribeToSellerWithPayment = useCallback(async (\r\n    buyer: string,\r\n    seller: string,\r\n    amount: number\r\n  ): Promise<boolean> => {\r\n    try {\r\n      debugLog('Processing subscription via API:', { buyer, seller, amount });\r\n      \r\n      const response = await apiClient.post<any>('/subscriptions/subscribe', {\r\n        seller, \r\n        price: amount\r\n      });\r\n      \r\n      debugLog('Subscription response:', response);\r\n      \r\n      if (response.success) {\r\n        // Refresh buyer balance\r\n        const newBalance = await fetchBalance(buyer);\r\n        if (!isAdminUser(buyer)) {\r\n          setBuyerBalancesState(prev => ({ ...prev, [buyer]: newBalance }));\r\n        }\r\n        return true;\r\n      }\r\n      \r\n      return false;\r\n    } catch (error) {\r\n      console.error('Subscription error:', error);\r\n      return false;\r\n    }\r\n  }, [apiClient, fetchBalance]);\r\n\r\n  // Unsubscribe from seller via API\r\n  const unsubscribeFromSeller = useCallback(async (\r\n    buyer: string,\r\n    seller: string\r\n  ): Promise<boolean> => {\r\n    try {\r\n      debugLog('Processing unsubscribe via API:', { buyer, seller });\r\n      \r\n      const response = await apiClient.post<any>('/subscriptions/unsubscribe', {\r\n        seller\r\n      });\r\n      \r\n      debugLog('Unsubscribe response:', response);\r\n      \r\n      if (response.success) {\r\n        debugLog('Successfully unsubscribed');\r\n        \r\n        // Optionally refresh buyer balance to reflect any changes\r\n        if (buyer === user?.username) {\r\n          const newBalance = await fetchBalance(buyer);\r\n          if (!isAdminUser(buyer)) {\r\n            setBuyerBalancesState(prev => ({ ...prev, [buyer]: newBalance }));\r\n          }\r\n        }\r\n        \r\n        return true;\r\n      }\r\n      \r\n      console.error('[WalletContext] Unsubscribe failed:', response.error);\r\n      return false;\r\n    } catch (error) {\r\n      console.error('[WalletContext] Unsubscribe error:', error);\r\n      return false;\r\n    }\r\n  }, [apiClient, fetchBalance, user]);\r\n\r\n  // Admin withdrawal\r\n  const addAdminWithdrawal = useCallback(async (amount: number) => {\r\n    try {\r\n      debugLog('Processing admin withdrawal from unified platform wallet');\r\n      \r\n      const response = await apiClient.post<any>('/wallet/admin-withdraw', {\r\n        amount,\r\n        accountDetails: {\r\n          accountNumber: '****9999',\r\n          accountType: 'business'\r\n        },\r\n        notes: `Platform withdrawal by ${user?.username}`\r\n      });\r\n      \r\n      if (response.success) {\r\n        const withdrawal: Withdrawal = {\r\n          amount,\r\n          date: new Date().toISOString(),\r\n          status: 'completed',\r\n          method: 'bank_transfer'\r\n        };\r\n        \r\n        setAdminWithdrawals(prev => [...prev, withdrawal]);\r\n        \r\n        // Refresh unified platform balance\r\n        await fetchAdminPlatformBalance();\r\n        \r\n        debugLog('Admin withdrawal successful');\r\n      } else {\r\n        console.error('[WalletContext] Admin withdrawal failed:', response.error);\r\n        throw new Error(response.error?.message || 'Withdrawal failed');\r\n      }\r\n    } catch (error) {\r\n      console.error('[WalletContext] Admin withdrawal error:', error);\r\n      throw error;\r\n    }\r\n  }, [apiClient, fetchAdminPlatformBalance, user]);\r\n\r\n  // Update order address\r\n  const updateOrderAddress = useCallback(async (orderId: string, address: DeliveryAddress) => {\r\n    try {\r\n      debugLog('Updating order address:', orderId);\r\n      \r\n      // Use POST method since ApiClient doesn't have PUT\r\n      const response = await apiClient.post<any>(`/orders/${orderId}/address`, {\r\n        deliveryAddress: address\r\n      });\r\n      \r\n      if (response.success) {\r\n        // Update local order history\r\n        setOrderHistory(prev => prev.map(order => \r\n          order.id === orderId ? { ...order, deliveryAddress: address } : order\r\n        ));\r\n        \r\n        debugLog('Order address updated successfully');\r\n      } else {\r\n        throw new Error(response.error?.message || 'Failed to update address');\r\n      }\r\n    } catch (error) {\r\n      console.error('[WalletContext] Error updating order address:', error);\r\n      throw error;\r\n    }\r\n  }, [apiClient]);\r\n\r\n  // Update shipping status\r\n  const updateShippingStatus = useCallback(async (orderId: string, status: 'pending' | 'processing' | 'shipped') => {\r\n    try {\r\n      debugLog('Updating shipping status:', orderId, status);\r\n      \r\n      // Use POST method since ApiClient doesn't have PUT\r\n      const response = await apiClient.post<any>(`/orders/${orderId}/shipping`, {\r\n        shippingStatus: status\r\n      });\r\n      \r\n      if (response.success) {\r\n        // Update local order history\r\n        setOrderHistory(prev => prev.map(order => \r\n          order.id === orderId ? { ...order, shippingStatus: status } : order\r\n        ));\r\n        \r\n        debugLog('Shipping status updated successfully');\r\n      } else {\r\n        throw new Error(response.error?.message || 'Failed to update shipping status');\r\n      }\r\n    } catch (error) {\r\n      console.error('[WalletContext] Error updating shipping status:', error);\r\n      throw error;\r\n    }\r\n  }, [apiClient]);\r\n\r\n  // Auction-related stubs\r\n  const holdBidFunds = useCallback(async (): Promise<boolean> => {\r\n    debugLog('Auction features not fully implemented in API yet');\r\n    return false;\r\n  }, []);\r\n\r\n  const refundBidFunds = useCallback(async (): Promise<boolean> => {\r\n    debugLog('Auction features not fully implemented in API yet');\r\n    return false;\r\n  }, []);\r\n\r\n  const placeBid = useCallback(async (): Promise<boolean> => {\r\n    debugLog('Auction features not fully implemented in API yet');\r\n    return false;\r\n  }, []);\r\n\r\n  const finalizeAuctionPurchase = useCallback(async (): Promise<boolean> => {\r\n    debugLog('Auction features not fully implemented in API yet');\r\n    return false;\r\n  }, []);\r\n\r\n  // Enhanced features stubs\r\n  const checkSuspiciousActivity = useCallback(async (username: string) => {\r\n    return { suspicious: false, reasons: [] };\r\n  }, []);\r\n\r\n  const reconcileBalance = useCallback(async (username: string, role: 'buyer' | 'seller' | 'admin') => {\r\n    return null;\r\n  }, []);\r\n\r\n  const contextValue: WalletContextType = {\r\n    // Loading state\r\n    isLoading,\r\n    isInitialized,\r\n    initializationError,\r\n    \r\n    // Core functionality\r\n    buyerBalances,\r\n    adminBalance,\r\n    sellerBalances,\r\n    setBuyerBalance,\r\n    getBuyerBalance,\r\n    setAdminBalance,\r\n    setSellerBalance,\r\n    getSellerBalance,\r\n    purchaseListing,\r\n    purchaseCustomRequest,\r\n    subscribeToSellerWithPayment,\r\n    unsubscribeFromSeller,\r\n    orderHistory,\r\n    addOrder,\r\n    sellerWithdrawals,\r\n    adminWithdrawals,\r\n    addSellerWithdrawal,\r\n    addAdminWithdrawal,\r\n    wallet: { ...buyerBalances, ...sellerBalances, admin: adminBalance },\r\n    updateWallet: () => { console.warn('updateWallet is deprecated - use API methods instead'); },\r\n    sendTip,\r\n    setAddSellerNotificationCallback,\r\n    adminCreditUser,\r\n    adminDebitUser,\r\n    adminActions,\r\n    updateOrderAddress,\r\n    updateShippingStatus,\r\n    depositLogs,\r\n    addDeposit,\r\n    getDepositsForUser: (username: string) => depositLogs.filter(log => log.username === username),\r\n    getTotalDeposits: () => depositLogs.reduce((sum, log) => sum + log.amount, 0),\r\n    getDepositsByTimeframe: () => depositLogs,\r\n    \r\n    // Auction methods (stubs for now)\r\n    holdBidFunds,\r\n    refundBidFunds,\r\n    finalizeAuctionPurchase,\r\n    placeBid,\r\n    chargeIncrementalBid: async () => false,\r\n    getAuctionBidders: async () => [],\r\n    cleanupAuctionTracking: async () => {},\r\n    \r\n    // Enhanced features\r\n    checkSuspiciousActivity,\r\n    reconcileBalance,\r\n    getTransactionHistory,\r\n    \r\n    // Admin-specific methods\r\n    refreshAdminData,\r\n    getPlatformTransactions,\r\n    getAnalyticsData,\r\n    \r\n    // Data management - Use the updated function\r\n    reloadData: updateReloadData,\r\n  };\r\n\r\n  return (\r\n    <WalletContext.Provider value={contextValue}>\r\n      {children}\r\n    </WalletContext.Provider>\r\n  );\r\n}\r\n\r\nexport const useWallet = () => {\r\n  const context = useContext(WalletContext);\r\n  if (!context) {\r\n    throw new Error(\"useWallet must be used within a WalletProvider\");\r\n  }\r\n  return context;\r\n};"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 4023, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/gerom/OneDrive/Documents/pantypost/src/context/AuctionContext.tsx"],"sourcesContent":["'use client';\r\n\r\nimport React, {\r\n  createContext,\r\n  useContext,\r\n  useState,\r\n  useCallback,\r\n  useEffect,\r\n  useRef,\r\n  ReactNode,\r\n  useMemo,\r\n} from 'react';\r\nimport { useAuth } from './AuthContext';\r\nimport { useWebSocket } from './WebSocketContext';\r\nimport { WebSocketEvent } from '@/types/websocket';\r\nimport { apiCall } from '@/services/api.config';\r\nimport { z } from 'zod';\r\nimport { getRateLimiter } from '@/utils/security/rate-limiter';\r\nimport { isAdmin } from '@/utils/security/permissions';\r\n\r\n// -----------------------------\r\n// Types\r\n// -----------------------------\r\nexport interface Bid {\r\n  id: string;\r\n  bidder: string;\r\n  amount: number;\r\n  timestamp: string;\r\n  isWinning?: boolean;\r\n}\r\n\r\nexport interface AuctionData {\r\n  id: string;\r\n  listingId: string;\r\n  seller: string;\r\n  startingPrice: number;\r\n  reservePrice?: number;\r\n  currentBid: number;\r\n  highestBidder?: string;\r\n  previousBidder?: string;\r\n  endTime: string;\r\n  bids: Bid[];\r\n  status: 'active' | 'ended' | 'cancelled' | 'reserve_not_met';\r\n  winnerId?: string;\r\n  finalPrice?: number;\r\n  reserveMet?: boolean;\r\n}\r\n\r\ninterface AuctionContextType {\r\n  // Auction state\r\n  auctions: Record<string, AuctionData>;\r\n  activeAuctions: AuctionData[];\r\n  userBids: Record<string, Bid[]>;\r\n\r\n  // Auction actions\r\n  placeBid: (listingId: string, bidder: string, amount: number) => Promise<boolean>;\r\n  cancelAuction: (listingId: string) => Promise<boolean>;\r\n  endAuction: (listingId: string) => Promise<boolean>;\r\n  processEndedAuction: (listing: any) => Promise<boolean>;\r\n  getAuctionByListingId: (listingId: string) => AuctionData | null;\r\n  getUserBidsForAuction: (listingId: string, username: string) => Bid[];\r\n  isUserHighestBidder: (listingId: string, username: string) => boolean;\r\n  checkReserveMet: (listingId: string) => boolean;\r\n\r\n  // Loading states\r\n  isPlacingBid: boolean;\r\n  isCancellingAuction: boolean;\r\n  isLoadingAuctions: boolean;\r\n\r\n  // Error handling\r\n  bidError: string | null;\r\n  clearBidError: () => void;\r\n\r\n  // Real-time updates\r\n  subscribeToAuction: (listingId: string) => void;\r\n  unsubscribeFromAuction: (listingId: string) => void;\r\n}\r\n\r\nconst AuctionContext = createContext<AuctionContextType | null>(null);\r\n\r\n// -----------------------------\r\n// Validation Schemas (Zod)\r\n// -----------------------------\r\nconst BidEventSchema = z.object({\r\n  listingId: z.string().min(1).optional(),\r\n  id: z.string().optional(),\r\n  bidder: z.string().min(1).optional(),\r\n  username: z.string().min(1).optional(),\r\n  amount: z.number().finite().nonnegative().optional(),\r\n  bid: z\r\n    .object({\r\n      amount: z.number().finite().nonnegative(),\r\n    })\r\n    .optional(),\r\n  timestamp: z.string().optional(),\r\n});\r\n\r\nconst RefundEventSchema = z.object({\r\n  username: z.string().min(1),\r\n  amount: z.number().finite().nonnegative(),\r\n  listingId: z.string().min(1).optional(),\r\n  balance: z.number().finite().nonnegative().optional(),\r\n  reason: z.string().optional(),\r\n});\r\n\r\nconst BalanceUpdateEventSchema = z.object({\r\n  username: z.string().min(1),\r\n  newBalance: z.number().finite(),\r\n  role: z.string().optional(),\r\n});\r\n\r\nconst AuctionEndedEventSchema = z.object({\r\n  listingId: z.string().optional(),\r\n  id: z.string().optional(),\r\n  status: z.enum(['ended', 'cancelled', 'reserve_not_met']).optional(),\r\n  winnerId: z.string().optional(),\r\n  winner: z.string().optional(),\r\n  finalPrice: z.number().optional(),\r\n  finalBid: z.number().optional(),\r\n});\r\n\r\n// -----------------------------\r\n// Utilities\r\n// -----------------------------\r\nfunction makeBidId() {\r\n  if (typeof crypto !== 'undefined' && 'randomUUID' in crypto) {\r\n    return crypto.randomUUID();\r\n  }\r\n  return `bid_${Date.now()}_${Math.floor(Math.random() * 1e6)}`;\r\n}\r\n\r\nfunction coerceNumber(n: unknown, fallback = 0): number {\r\n  const v = typeof n === 'number' ? n : Number(n);\r\n  return Number.isFinite(v) ? v : fallback;\r\n}\r\n\r\n// Local, safe defaults for bid spam protection\r\nconst BID_LIMIT = {\r\n  maxAttempts: 5,\r\n  windowMs: 10_000,\r\n  blockDuration: 10_000,\r\n};\r\n\r\nexport function AuctionProvider({ children }: { children: ReactNode }) {\r\n  const { user } = useAuth();\r\n\r\n  const wsContext = useWebSocket();\r\n  const subscribe = wsContext?.subscribe || (() => () => {});\r\n  const isConnected = wsContext?.isConnected || false;\r\n\r\n  const [auctions, setAuctions] = useState<Record<string, AuctionData>>({});\r\n  const [userBids, setUserBids] = useState<Record<string, Bid[]>>({});\r\n  const [isPlacingBid, setIsPlacingBid] = useState(false);\r\n  const [isCancellingAuction, setIsCancellingAuction] = useState(false);\r\n  const [isLoadingAuctions, setIsLoadingAuctions] = useState(false);\r\n  const [bidError, setBidError] = useState<string | null>(null);\r\n\r\n  // Keep a ref to latest auctions to avoid effect dependency churn\r\n  const auctionsRef = useRef(auctions);\r\n  useEffect(() => {\r\n    auctionsRef.current = auctions;\r\n  }, [auctions]);\r\n\r\n  const activeAuctions = useMemo(\r\n    () => Object.values(auctions).filter((a) => a.status === 'active'),\r\n    [auctions]\r\n  );\r\n\r\n  const clearBidError = useCallback(() => {\r\n    setBidError(null);\r\n  }, []);\r\n\r\n  const refreshCurrentUserBalance = useCallback(async () => {\r\n    if (!user) return;\r\n\r\n    try {\r\n      const response = await apiCall<any>(`/wallet/balance/${user.username}`, {\r\n        method: 'GET',\r\n      });\r\n\r\n      if (response.success && response.data) {\r\n        const newBalance = response.data.balance || 0;\r\n\r\n        if (typeof window !== 'undefined') {\r\n          console.log(`[AuctionContext] Current user balance updated: $${newBalance}`);\r\n\r\n          window.dispatchEvent(\r\n            new CustomEvent('wallet:balance_update', {\r\n              detail: {\r\n                username: user.username,\r\n                role: user.role,\r\n                balance: newBalance,\r\n                newBalance: newBalance,\r\n                timestamp: Date.now(),\r\n              },\r\n            })\r\n          );\r\n\r\n          const roleEvent =\r\n            user.role === 'buyer' ? 'wallet:buyer-balance-updated' : 'wallet:seller-balance-updated';\r\n          window.dispatchEvent(\r\n            new CustomEvent(roleEvent, {\r\n              detail: {\r\n                username: user.username,\r\n                balance: newBalance,\r\n                timestamp: Date.now(),\r\n              },\r\n            })\r\n          );\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error(`[AuctionContext] Error refreshing current user balance:`, error);\r\n    }\r\n  }, [user]);\r\n\r\n  const updateAuctionWithBid = useCallback((listingId: string, rawData: unknown) => {\r\n    const parsed = BidEventSchema.safeParse(rawData);\r\n    if (!parsed.success) {\r\n      console.warn('[AuctionContext] Ignoring malformed bid event', parsed.error?.flatten());\r\n      return undefined as unknown as string | undefined;\r\n    }\r\n    const data = parsed.data;\r\n\r\n    const amount =\r\n      typeof data.amount === 'number'\r\n        ? data.amount\r\n        : coerceNumber(data.bid?.amount, 0);\r\n\r\n    const bidder = (data.bidder || data.username || '').trim();\r\n    if (!listingId || !bidder || !Number.isFinite(amount)) {\r\n      console.warn('[AuctionContext] Incomplete bid payload; skipping update');\r\n      return undefined as unknown as string | undefined;\r\n    }\r\n\r\n    const bid: Bid = {\r\n      id: makeBidId(),\r\n      bidder,\r\n      amount,\r\n      timestamp: data.timestamp || new Date().toISOString(),\r\n      isWinning: true,\r\n    };\r\n\r\n    console.log('[AuctionContext] Processing bid update:', { listingId, bid });\r\n\r\n    let previousHighestBidder: string | undefined;\r\n\r\n    setAuctions((prev) => {\r\n      const existingAuction = prev[listingId];\r\n      previousHighestBidder = existingAuction?.highestBidder;\r\n\r\n      const reserveMet = existingAuction?.reservePrice\r\n        ? bid.amount >= existingAuction.reservePrice\r\n        : true;\r\n\r\n      return {\r\n        ...prev,\r\n        [listingId]: {\r\n          ...existingAuction,\r\n          listingId,\r\n          id: listingId,\r\n          seller: existingAuction?.seller || '',\r\n          startingPrice: existingAuction?.startingPrice || 0,\r\n          reservePrice: existingAuction?.reservePrice,\r\n          currentBid: bid.amount,\r\n          highestBidder: bid.bidder,\r\n          previousBidder: previousHighestBidder,\r\n          endTime: existingAuction?.endTime || '',\r\n          status: existingAuction?.status || 'active',\r\n          reserveMet,\r\n          bids: [...(existingAuction?.bids || []), bid].sort((a, b) => b.amount - a.amount),\r\n        },\r\n      };\r\n    });\r\n\r\n    setUserBids((prev) => ({\r\n      ...prev,\r\n      [bid.bidder]: [...(prev[bid.bidder] || []), bid],\r\n    }));\r\n\r\n    return previousHighestBidder;\r\n  }, []);\r\n\r\n  const updateAuctionStatus = useCallback(\r\n    (\r\n      listingId: string,\r\n      status: 'ended' | 'cancelled' | 'reserve_not_met',\r\n      winnerId?: string,\r\n      finalPrice?: number\r\n    ) => {\r\n      setAuctions((prev) => {\r\n        const existingAuction = prev[listingId];\r\n\r\n        return {\r\n          ...prev,\r\n          [listingId]: {\r\n            ...existingAuction,\r\n            listingId,\r\n            id: listingId,\r\n            seller: existingAuction?.seller || '',\r\n            startingPrice: existingAuction?.startingPrice || 0,\r\n            reservePrice: existingAuction?.reservePrice,\r\n            currentBid: existingAuction?.currentBid || 0,\r\n            endTime: existingAuction?.endTime || '',\r\n            bids: existingAuction?.bids || [],\r\n            status,\r\n            ...(winnerId && { winnerId }),\r\n            ...(typeof finalPrice === 'number' && Number.isFinite(finalPrice) && { finalPrice }),\r\n            reserveMet: status === 'reserve_not_met' ? false : existingAuction?.reserveMet,\r\n          },\r\n        };\r\n      });\r\n    },\r\n    []\r\n  );\r\n\r\n  const checkReserveMet = useCallback(\r\n    (listingId: string): boolean => {\r\n      const auction = auctions[listingId];\r\n      if (!auction || !auction.reservePrice) return true;\r\n      return auction.currentBid >= auction.reservePrice;\r\n    },\r\n    [auctions]\r\n  );\r\n\r\n  // Initial load (kept minimal; extend if needed)\r\n  useEffect(() => {\r\n    const loadAuctions = async () => {\r\n      if (!user) return;\r\n\r\n      setIsLoadingAuctions(true);\r\n      try {\r\n        console.log('[AuctionContext] Loading auctions...');\r\n        // (Intentionally left without fetching to avoid regressions)\r\n      } catch (error) {\r\n        console.error('[AuctionContext] Error loading auctions:', error);\r\n      } finally {\r\n        setIsLoadingAuctions(false);\r\n      }\r\n    };\r\n\r\n    loadAuctions();\r\n  }, [user]);\r\n\r\n  // WebSocket subscriptions (stabilized: no dependency on auctions state)\r\n  useEffect(() => {\r\n    if (!isConnected || !subscribe) return;\r\n\r\n    const unsubscribers: Array<() => void> = [];\r\n\r\n    // New bid\r\n    unsubscribers.push(\r\n      subscribe(WebSocketEvent.AUCTION_BID, async (raw: unknown) => {\r\n        const parsed = BidEventSchema.safeParse(raw);\r\n        if (!parsed.success) {\r\n          console.warn('[AuctionContext] Ignoring malformed AUCTION_BID', parsed.error?.flatten());\r\n          return;\r\n        }\r\n        const data = parsed.data;\r\n        const listingId = (data.listingId || data.id || '').toString();\r\n        if (!listingId) return;\r\n\r\n        updateAuctionWithBid(listingId, data);\r\n\r\n        if (user && (data.bidder === user.username || data.username === user.username)) {\r\n          await refreshCurrentUserBalance();\r\n        }\r\n      })\r\n    );\r\n\r\n    // Wallet refund\r\n    unsubscribers.push(\r\n      subscribe('wallet:refund' as WebSocketEvent, async (raw: unknown) => {\r\n        const parsed = RefundEventSchema.safeParse(raw);\r\n        if (!parsed.success) {\r\n          console.warn('[AuctionContext] Ignoring malformed wallet:refund', parsed.error?.flatten());\r\n          return;\r\n        }\r\n        const data = parsed.data;\r\n\r\n        if (user && data.username === user.username) {\r\n          console.log('[AuctionContext] Current user was refunded, refreshing balance');\r\n          await refreshCurrentUserBalance();\r\n\r\n          if (typeof window !== 'undefined') {\r\n            window.dispatchEvent(\r\n              new CustomEvent('wallet:user-refunded', {\r\n                detail: {\r\n                  username: user.username,\r\n                  amount: data.amount,\r\n                  listingId: data.listingId,\r\n                  balance: data.balance,\r\n                  reason: data.reason,\r\n                  timestamp: Date.now(),\r\n                },\r\n              })\r\n            );\r\n          }\r\n        }\r\n      })\r\n    );\r\n\r\n    // Balance update passthrough (dedupe + fan-out)\r\n    unsubscribers.push(\r\n      subscribe('wallet:balance_update' as WebSocketEvent, async (raw: unknown) => {\r\n        const parsed = BalanceUpdateEventSchema.safeParse(raw);\r\n        if (!parsed.success) {\r\n          console.warn('[AuctionContext] Ignoring malformed wallet:balance_update', parsed.error?.flatten());\r\n          return;\r\n        }\r\n        const data = parsed.data;\r\n\r\n        if (user && data.username === user.username && typeof data.newBalance === 'number') {\r\n          if (typeof window !== 'undefined') {\r\n            window.dispatchEvent(\r\n              new CustomEvent('wallet:balance_update', {\r\n                detail: {\r\n                  username: user.username,\r\n                  role: user.role,\r\n                  balance: data.newBalance,\r\n                  newBalance: data.newBalance,\r\n                  timestamp: Date.now(),\r\n                },\r\n              })\r\n            );\r\n\r\n            const roleEvent =\r\n              user.role === 'buyer'\r\n                ? 'wallet:buyer-balance-updated'\r\n                : 'wallet:seller-balance-updated';\r\n            window.dispatchEvent(\r\n              new CustomEvent(roleEvent, {\r\n                detail: {\r\n                  username: user.username,\r\n                  balance: data.newBalance,\r\n                  timestamp: Date.now(),\r\n                },\r\n              })\r\n            );\r\n\r\n            window.dispatchEvent(\r\n              new CustomEvent('auction:check-bid-status', {\r\n                detail: {\r\n                  username: user.username,\r\n                  balance: data.newBalance,\r\n                  timestamp: Date.now(),\r\n                },\r\n              })\r\n            );\r\n          }\r\n        }\r\n      })\r\n    );\r\n\r\n    // Outbid notice (no-op other than logging for now)\r\n    unsubscribers.push(\r\n      subscribe('auction:outbid' as WebSocketEvent, async (data: any) => {\r\n        console.log('[AuctionContext] User was outbid:', data);\r\n        if (user && data?.username === user.username) {\r\n          console.log('[AuctionContext] Current user was outbid on', data?.listingTitle);\r\n        }\r\n      })\r\n    );\r\n\r\n    // Auction ended\r\n    unsubscribers.push(\r\n      subscribe(WebSocketEvent.AUCTION_ENDED, async (raw: unknown) => {\r\n        const parsed = AuctionEndedEventSchema.safeParse(raw);\r\n        if (!parsed.success) {\r\n          console.warn('[AuctionContext] Ignoring malformed AUCTION_ENDED', parsed.error?.flatten());\r\n          return;\r\n        }\r\n        const data = parsed.data;\r\n\r\n        const listingId = (data.listingId || data.id || '').toString();\r\n        if (!listingId) return;\r\n\r\n        const status = data.status || 'ended';\r\n\r\n        if (status === 'reserve_not_met') {\r\n          updateAuctionStatus(listingId, 'reserve_not_met');\r\n\r\n          const auction = auctionsRef.current[listingId];\r\n          if (user && auction?.highestBidder === user.username) {\r\n            console.log('[AuctionContext] Reserve not met, user will be refunded');\r\n          }\r\n        } else {\r\n          const winner = data.winnerId || data.winner;\r\n          const final =\r\n            typeof data.finalPrice === 'number'\r\n              ? data.finalPrice\r\n              : typeof data.finalBid === 'number'\r\n              ? data.finalBid\r\n              : undefined;\r\n\r\n          updateAuctionStatus(listingId, 'ended', winner, final);\r\n\r\n          if (user && winner === user.username) {\r\n            await refreshCurrentUserBalance();\r\n          }\r\n        }\r\n      })\r\n    );\r\n\r\n    // Reserve not met\r\n    unsubscribers.push(\r\n      subscribe('auction:reserve_not_met' as WebSocketEvent, async (raw: unknown) => {\r\n        const parsed = AuctionEndedEventSchema.safeParse(raw);\r\n        if (!parsed.success) {\r\n          console.warn('[AuctionContext] Ignoring malformed auction:reserve_not_met', parsed.error?.flatten());\r\n          return;\r\n        }\r\n        const data = parsed.data;\r\n\r\n        const listingId = (data.listingId || data.id || '').toString();\r\n        if (!listingId) return;\r\n\r\n        updateAuctionStatus(listingId, 'reserve_not_met');\r\n\r\n        const auction = auctionsRef.current[listingId];\r\n        if (user && auction?.highestBidder === user.username) {\r\n          console.log('[AuctionContext] User was highest bidder, awaiting refund for reserve not met');\r\n        }\r\n      })\r\n    );\r\n\r\n    // Cancelled\r\n    unsubscribers.push(\r\n      subscribe(WebSocketEvent.AUCTION_CANCELLED, async (raw: unknown) => {\r\n        const parsed = AuctionEndedEventSchema.safeParse(raw);\r\n        if (!parsed.success) {\r\n          console.warn('[AuctionContext] Ignoring malformed AUCTION_CANCELLED', parsed.error?.flatten());\r\n          return;\r\n        }\r\n        const data = parsed.data;\r\n\r\n        const listingId = (data.listingId || data.id || '').toString();\r\n        if (!listingId) return;\r\n\r\n        const auction = auctionsRef.current[listingId];\r\n        updateAuctionStatus(listingId, 'cancelled');\r\n\r\n        if (user && auction?.highestBidder === user.username) {\r\n          await refreshCurrentUserBalance();\r\n        }\r\n      })\r\n    );\r\n\r\n    return () => {\r\n      unsubscribers.forEach((unsub) => {\r\n        try {\r\n          unsub();\r\n        } catch {\r\n          // swallow teardown errors\r\n        }\r\n      });\r\n    };\r\n  }, [isConnected, subscribe, updateAuctionWithBid, updateAuctionStatus, refreshCurrentUserBalance, user]);\r\n\r\n  const placeBid = useCallback(\r\n    async (listingId: string, bidder: string, amount: number): Promise<boolean> => {\r\n      if (!user) {\r\n        setBidError('You must be logged in to bid');\r\n        return false;\r\n      }\r\n\r\n      // Gentle client-side rate limit against spam clicks\r\n      try {\r\n        const limiter = getRateLimiter(); // no args\r\n        const key = `auction:bid:${user.username}`;\r\n        limiter.check(key, {\r\n          maxAttempts: BID_LIMIT.maxAttempts,\r\n          windowMs: BID_LIMIT.windowMs,\r\n          blockDuration: BID_LIMIT.blockDuration,\r\n        });\r\n      } catch {\r\n        setBidError('Too many bid attempts. Please wait a moment.');\r\n        return false;\r\n      }\r\n\r\n      // Coerce & validate amount\r\n      const amt = coerceNumber(amount, NaN);\r\n      if (!Number.isFinite(amt) || amt < 0) {\r\n        setBidError('Invalid bid amount');\r\n        return false;\r\n      }\r\n\r\n      // Ensure bidder matches logged-in user (UI safety)\r\n      if (bidder && user.username && bidder !== user.username) {\r\n        console.warn('[AuctionContext] Bidder mismatch; normalizing to current user');\r\n      }\r\n\r\n      setIsPlacingBid(true);\r\n      setBidError(null);\r\n\r\n      try {\r\n        const response = await apiCall<any>(`/listings/${listingId}/bid`, {\r\n          method: 'POST',\r\n          headers: { 'Content-Type': 'application/json' },\r\n          body: JSON.stringify({ amount: amt }),\r\n        });\r\n\r\n        if (response.success) {\r\n          console.log('[AuctionContext] Bid placed successfully:', response.data?.message || 'Success');\r\n\r\n          updateAuctionWithBid(listingId, {\r\n            bidder: user.username,\r\n            amount: amt,\r\n            timestamp: new Date().toISOString(),\r\n          });\r\n\r\n          const auction = auctionsRef.current[listingId];\r\n          if (auction?.reservePrice && amt < auction.reservePrice) {\r\n            console.log('[AuctionContext] Bid placed but reserve price not yet met');\r\n          }\r\n\r\n          await refreshCurrentUserBalance();\r\n\r\n          return true;\r\n        } else {\r\n          const errorMsg =\r\n            typeof response.error === 'string'\r\n              ? response.error\r\n              : response.error?.message || 'Failed to place bid';\r\n          setBidError(errorMsg);\r\n          console.error('[AuctionContext] Bid failed:', errorMsg);\r\n          return false;\r\n        }\r\n      } catch (error: any) {\r\n        const errorMsg = error?.message || 'Network error while placing bid';\r\n        setBidError(errorMsg);\r\n        console.error('[AuctionContext] Bid error:', error);\r\n        return false;\r\n      } finally {\r\n        setIsPlacingBid(false);\r\n      }\r\n    },\r\n    [user, updateAuctionWithBid, refreshCurrentUserBalance]\r\n  );\r\n\r\n  const cancelAuction = useCallback(\r\n    async (listingId: string): Promise<boolean> => {\r\n      if (!user) return false;\r\n\r\n      setIsCancellingAuction(true);\r\n\r\n      try {\r\n        const response = await apiCall<any>(`/listings/${listingId}/cancel-auction`, {\r\n          method: 'POST',\r\n          headers: { 'Content-Type': 'application/json' },\r\n        });\r\n\r\n        if (response.success) {\r\n          return true;\r\n        } else {\r\n          console.error('[AuctionContext] Cancel auction failed:', response.error);\r\n          return false;\r\n        }\r\n      } catch (error: any) {\r\n        console.error('[AuctionContext] Cancel auction error:', error);\r\n        return false;\r\n      } finally {\r\n        setIsCancellingAuction(false);\r\n      }\r\n    },\r\n    [user]\r\n  );\r\n\r\n  const endAuction = useCallback(\r\n    async (listingId: string): Promise<boolean> => {\r\n      if (!user || !isAdmin(user)) {\r\n        return false;\r\n      }\r\n\r\n      try {\r\n        const response = await apiCall<any>(`/listings/${listingId}/end-auction`, {\r\n          method: 'POST',\r\n          headers: { 'Content-Type': 'application/json' },\r\n        });\r\n\r\n        if (response.success) {\r\n          return true;\r\n        } else {\r\n          console.error('[AuctionContext] End auction failed:', response.error);\r\n          return false;\r\n        }\r\n      } catch (error: any) {\r\n        console.error('[AuctionContext] End auction error:', error);\r\n        return false;\r\n      }\r\n    },\r\n    [user]\r\n  );\r\n\r\n  // Process ended auction - handle already processed auctions gracefully\r\n  const processEndedAuction = useCallback(\r\n    async (listing: any): Promise<boolean> => {\r\n      if (!listing?.auction) return false;\r\n\r\n      try {\r\n        // Call backend to process auction completion\r\n        const response = await apiCall<any>(`/listings/${listing.id}/end-auction`, {\r\n          method: 'POST',\r\n          headers: { 'Content-Type': 'application/json' },\r\n        });\r\n\r\n        if (response.success) {\r\n          // Check if it was already processed (backend returns success with alreadyProcessed flag)\r\n          const alreadyProcessed =\r\n            response.data?.alreadyProcessed ||\r\n            response.data?.data?.alreadyProcessed ||\r\n            false;\r\n\r\n          if (alreadyProcessed) {\r\n            console.log('[AuctionContext] Auction was already processed:', response.data?.status);\r\n\r\n            // Update status based on the already-processed status\r\n            const status =\r\n              response.data?.status || response.data?.data?.status || 'ended';\r\n            if (status === 'reserve_not_met') {\r\n              updateAuctionStatus(listing.id, 'reserve_not_met');\r\n            } else if (listing.auction.highestBidder && listing.auction.highestBid) {\r\n              updateAuctionStatus(\r\n                listing.id,\r\n                'ended',\r\n                listing.auction.highestBidder,\r\n                listing.auction.highestBid\r\n              );\r\n            } else {\r\n              updateAuctionStatus(listing.id, 'ended');\r\n            }\r\n\r\n            return true; // handled\r\n          }\r\n\r\n          // Process the response data\r\n          const responseData = response.data || {};\r\n\r\n          // Check if order was created successfully\r\n          const order = responseData.order || responseData.data?.order;\r\n          if (order) {\r\n            console.log('[AuctionContext] Order created successfully:', order);\r\n\r\n            // Fire event for order creation\r\n            if (typeof window !== 'undefined') {\r\n              window.dispatchEvent(\r\n                new CustomEvent('order:created', {\r\n                  detail: { order },\r\n                })\r\n              );\r\n            }\r\n          }\r\n\r\n          // Update status based on response\r\n          const status = responseData.status || responseData.data?.status || 'ended';\r\n          if (status === 'reserve_not_met') {\r\n            updateAuctionStatus(listing.id, 'reserve_not_met');\r\n          } else if (listing.auction.highestBidder && listing.auction.highestBid) {\r\n            updateAuctionStatus(\r\n              listing.id,\r\n              'ended',\r\n              listing.auction.highestBidder,\r\n              listing.auction.highestBid\r\n            );\r\n          } else {\r\n            updateAuctionStatus(listing.id, 'ended');\r\n          }\r\n\r\n          return true;\r\n        }\r\n\r\n        // Error path: treat known messages as already-processed\r\n        const msg =\r\n          (typeof response.error === 'string'\r\n            ? response.error\r\n            : response.error?.message || ''\r\n          ).toLowerCase();\r\n\r\n        if (\r\n          msg.includes('auction is not active') ||\r\n          msg.includes('already processed') ||\r\n          msg.includes('auction already processed')\r\n        ) {\r\n          console.log('[AuctionContext] Auction already processed, treating as success');\r\n          updateAuctionStatus(listing.id, 'ended');\r\n          return true;\r\n        }\r\n\r\n        console.error('[AuctionContext] Failed to process ended auction:', response.error);\r\n        return false;\r\n      } catch (error: any) {\r\n        const msg = (error?.message || '').toLowerCase();\r\n        if (\r\n          msg.includes('auction is not active') ||\r\n          msg.includes('already processed') ||\r\n          msg.includes('auction already processed')\r\n        ) {\r\n          console.log('[AuctionContext] Auction already processed (from catch), treating as success');\r\n          updateAuctionStatus(listing.id, 'ended');\r\n          return true;\r\n        }\r\n\r\n        console.error('[AuctionContext] Error processing ended auction:', error);\r\n        return false;\r\n      }\r\n    },\r\n    [updateAuctionStatus]\r\n  );\r\n\r\n  const getAuctionByListingId = useCallback(\r\n    (listingId: string): AuctionData | null => auctions[listingId] || null,\r\n    [auctions]\r\n  );\r\n\r\n  const getUserBidsForAuction = useCallback(\r\n    (listingId: string, username: string): Bid[] => {\r\n      const auction = auctions[listingId];\r\n      if (!auction) return [];\r\n      return auction.bids.filter((bid) => bid.bidder === username);\r\n    },\r\n    [auctions]\r\n  );\r\n\r\n  const isUserHighestBidder = useCallback(\r\n    (listingId: string, username: string): boolean => {\r\n      const auction = auctions[listingId];\r\n      return auction?.highestBidder === username;\r\n    },\r\n    [auctions]\r\n  );\r\n\r\n  const subscribeToAuction = useCallback(\r\n    (listingId: string) => {\r\n      if (!isConnected) return;\r\n      console.log('[AuctionContext] Subscribing to auction:', listingId);\r\n      // Hook for future: if your WS supports rooms, join here.\r\n    },\r\n    [isConnected]\r\n  );\r\n\r\n  const unsubscribeFromAuction = useCallback(\r\n    (listingId: string) => {\r\n      if (!isConnected) return;\r\n      console.log('[AuctionContext] Unsubscribing from auction:', listingId);\r\n      // Hook for future: if your WS supports rooms, leave here.\r\n    },\r\n    [isConnected]\r\n  );\r\n\r\n  const value: AuctionContextType = {\r\n    auctions,\r\n    activeAuctions,\r\n    userBids,\r\n    placeBid,\r\n    cancelAuction,\r\n    endAuction,\r\n    processEndedAuction,\r\n    getAuctionByListingId,\r\n    getUserBidsForAuction,\r\n    isUserHighestBidder,\r\n    checkReserveMet,\r\n    isPlacingBid,\r\n    isCancellingAuction,\r\n    isLoadingAuctions,\r\n    bidError,\r\n    clearBidError,\r\n    subscribeToAuction,\r\n    unsubscribeFromAuction,\r\n  };\r\n\r\n  return <AuctionContext.Provider value={value}>{children}</AuctionContext.Provider>;\r\n}\r\n\r\nexport function useAuction() {\r\n  const context = useContext(AuctionContext);\r\n  if (!context) {\r\n    throw new Error('useAuction must be used within AuctionProvider');\r\n  }\r\n  return context;\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 4649, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/gerom/OneDrive/Documents/pantypost/src/context/ListingContext.tsx"],"sourcesContent":["'use client';\r\n\r\nimport {\r\n  createContext,\r\n  useContext,\r\n  useState,\r\n  useEffect,\r\n  ReactNode,\r\n  useCallback,\r\n  useRef,\r\n  useMemo,\r\n} from 'react';\r\nimport { useWallet } from './WalletContext';\r\nimport { useAuth } from './AuthContext';\r\nimport { useAuction } from './AuctionContext';\r\nimport { useWebSocket } from './WebSocketContext';\r\nimport { WebSocketEvent } from '@/types/websocket';\r\nimport type { Order } from '@/types/order';\r\nimport { v4 as uuidv4 } from 'uuid';\r\nimport { listingsService, usersService, storageService } from '@/services';\r\nimport { ListingDraft } from '@/types/myListings';\r\nimport { securityService, sanitize } from '@/services/security.service';\r\nimport { listingSchemas } from '@/utils/validation/schemas';\r\n\r\nexport type Role = 'buyer' | 'seller' | 'admin';\r\n\r\nexport type VerificationStatus = 'unverified' | 'pending' | 'verified' | 'rejected';\r\n\r\nexport type VerificationDocs = {\r\n  codePhoto?: string;\r\n  idFront?: string;\r\n  idBack?: string;\r\n  passport?: string;\r\n  code?: string;\r\n};\r\n\r\nexport type Bid = {\r\n  id: string;\r\n  bidder: string;\r\n  amount: number;\r\n  date: string;\r\n};\r\n\r\nexport type AuctionStatus = 'active' | 'ended' | 'cancelled' | 'reserve_not_met';\r\n\r\nexport type AuctionSettings = {\r\n  isAuction: boolean;\r\n  startingPrice: number;\r\n  reservePrice?: number;\r\n  endTime: string;\r\n  bids: Bid[];\r\n  highestBid?: number;\r\n  highestBidder?: string;\r\n  status: AuctionStatus;\r\n  minimumIncrement?: number;\r\n};\r\n\r\nexport type Listing = {\r\n  id: string;\r\n  title: string;\r\n  description: string;\r\n  price: number;\r\n  markedUpPrice: number;\r\n  imageUrls: string[];\r\n  date: string;\r\n  seller: string;\r\n\r\n  isVerified?: boolean;\r\n  isPremium?: boolean;\r\n  isLocked?: boolean;\r\n  tags?: string[];\r\n  hoursWorn?: number;\r\n  views?: number;\r\n\r\n  auction?: AuctionSettings;\r\n};\r\n\r\nexport type NewListingInput = Omit<Listing, 'id' | 'date' | 'markedUpPrice'>;\r\nexport type AddListingInput = Omit<Listing, 'id' | 'date' | 'markedUpPrice'>;\r\n\r\nexport type AuctionInput = {\r\n  startingPrice: number;\r\n  reservePrice?: number;\r\n  endTime: string;\r\n};\r\n\r\nexport type Notification = {\r\n  id: string;\r\n  message: string;\r\n  timestamp: string;\r\n  cleared: boolean;\r\n};\r\n\r\nexport type NotificationItem = string | Notification;\r\n\r\ntype NotificationStore = Record<string, NotificationItem[]>;\r\n\r\ninterface SubscriptionData {\r\n  seller: string;\r\n  price: number;\r\n  subscribedAt: string;\r\n}\r\n\r\n// ============ Sold-listing dedup manager (browser-safe timers) ============\r\nclass SoldListingDeduplicationManager {\r\n  private processedListings: Map<string, number> = new Map();\r\n  private cleanupInterval: ReturnType<typeof setInterval> | null = null;\r\n  private expiryMs: number;\r\n\r\n  constructor(expiryMs: number = 60_000) {\r\n    this.expiryMs = expiryMs;\r\n    this.startCleanup();\r\n  }\r\n\r\n  private startCleanup() {\r\n    this.cleanupInterval = setInterval(() => {\r\n      const now = Date.now();\r\n      const expiredKeys: string[] = [];\r\n      this.processedListings.forEach((timestamp, listingId) => {\r\n        if (now - timestamp > this.expiryMs) expiredKeys.push(listingId);\r\n      });\r\n      expiredKeys.forEach((key) => this.processedListings.delete(key));\r\n    }, 30_000);\r\n  }\r\n\r\n  isDuplicate(listingId: string): boolean {\r\n    if (this.processedListings.has(listingId)) return true;\r\n    this.processedListings.set(listingId, Date.now());\r\n    return false;\r\n  }\r\n\r\n  destroy() {\r\n    if (this.cleanupInterval) {\r\n      clearInterval(this.cleanupInterval);\r\n      this.cleanupInterval = null;\r\n    }\r\n    this.processedListings.clear();\r\n  }\r\n}\r\n\r\ntype ListingContextType = {\r\n  isAuthReady: boolean;\r\n  listings: Listing[];\r\n  addListing: (listing: AddListingInput) => Promise<void>;\r\n  addAuctionListing: (listing: AddListingInput, auctionSettings: AuctionInput) => Promise<void>;\r\n  removeListing: (id: string) => Promise<void>;\r\n  updateListing: (\r\n    id: string,\r\n    updatedListing: Partial<Omit<Listing, 'id' | 'date' | 'markedUpPrice'>>\r\n  ) => Promise<void>;\r\n  purchaseListingAndRemove: (listing: Listing, buyerUsername: string) => Promise<boolean>;\r\n\r\n  // Auction functions\r\n  placeBid: (listingId: string, bidder: string, amount: number) => Promise<boolean>;\r\n  getAuctionListings: () => Listing[];\r\n  getActiveAuctions: () => Listing[];\r\n  getEndedAuctions: () => Listing[];\r\n  checkEndedAuctions: () => Promise<void>;\r\n  cancelAuction: (listingId: string) => Promise<boolean>;\r\n\r\n  // Draft functions\r\n  saveDraft: (draft: ListingDraft) => Promise<boolean>;\r\n  getDrafts: () => Promise<ListingDraft[]>;\r\n  deleteDraft: (draftId: string) => Promise<boolean>;\r\n\r\n  // Image functions\r\n  uploadImage: (file: File) => Promise<string | null>;\r\n  deleteImage: (imageUrl: string) => Promise<boolean>;\r\n\r\n  subscriptions: { [buyer: string]: string[] };\r\n  subscribeToSeller: (buyer: string, seller: string, price: number) => Promise<boolean>;\r\n  unsubscribeFromSeller: (buyer: string, seller: string) => Promise<void>;\r\n  isSubscribed: (buyer: string, seller: string) => boolean;\r\n\r\n  // Notifications\r\n  sellerNotifications: Notification[];\r\n  addSellerNotification: (seller: string, message: string) => void;\r\n  clearSellerNotification: (notificationId: string | number) => void;\r\n  restoreSellerNotification: (notificationId: string) => void;\r\n  permanentlyDeleteSellerNotification: (notificationId: string) => void;\r\n\r\n  // Verification\r\n  requestVerification: (docs: VerificationDocs) => Promise<void>;\r\n  setVerificationStatus: (\r\n    username: string,\r\n    status: VerificationStatus,\r\n    rejectionReason?: string\r\n  ) => Promise<void>;\r\n\r\n  users: { [username: string]: any };\r\n\r\n  orderHistory: Order[];\r\n  latestOrder: Order | null;\r\n\r\n  // Loading and error states\r\n  isLoading: boolean;\r\n  error: string | null;\r\n  refreshListings: () => Promise<void>;\r\n};\r\n\r\nconst ListingContext = createContext<ListingContextType | undefined>(undefined);\r\n\r\nexport const ListingProvider: React.FC<{ children: ReactNode }> = ({ children }) => {\r\n  const { user, updateUser } = useAuth();\r\n  const webSocketContext = useWebSocket();\r\n\r\n  const subscribe = webSocketContext?.subscribe;\r\n  const isConnected = webSocketContext?.isConnected || false;\r\n\r\n  const [users, setUsers] = useState<{ [username: string]: any }>({});\r\n  const [listings, setListings] = useState<Listing[]>([]);\r\n  const [subscriptions, setSubscriptions] = useState<{ [buyer: string]: string[] }>({});\r\n  const [notificationStore, setNotificationStore] = useState<NotificationStore>({});\r\n  const [isAuthReady, setIsAuthReady] = useState(false);\r\n  const [isLoading, setIsLoading] = useState(false);\r\n  const [error, setError] = useState<string | null>(null);\r\n  const [latestOrder, setLatestOrder] = useState<Order | null>(null);\r\n\r\n  const soldListingDeduplicator = useRef(new SoldListingDeduplicationManager());\r\n  const listingUpdateDeduplicator = useRef(new Map<string, number>());\r\n  const DEBOUNCE_TIME = 500;\r\n\r\n  const apiRequestCache = useRef(new Map<string, { timestamp: number; promise: Promise<any> }>());\r\n  const API_CACHE_TIME = 1000;\r\n\r\n  // ---------- Notification helpers ----------\r\n  const normalizeNotification = (item: NotificationItem): Notification => {\r\n    if (typeof item === 'string') {\r\n      return {\r\n        id: uuidv4(),\r\n        message: sanitize.strict(item),\r\n        timestamp: new Date().toISOString(),\r\n        cleared: false,\r\n      };\r\n    }\r\n    return {\r\n      ...item,\r\n      message: sanitize.strict(item.message),\r\n    };\r\n  };\r\n\r\n  const saveNotificationStore = async (store: NotificationStore) => {\r\n    try {\r\n      await storageService.setItem('seller_notifications_store', store);\r\n    } catch (e) {\r\n      console.error('[ListingContext] Failed saving notification store', e);\r\n    }\r\n  };\r\n\r\n  const addSellerNotification = useCallback((seller: string, message: string) => {\r\n    const safeSeller = sanitize.username(seller);\r\n    if (!safeSeller) {\r\n      console.warn('[ListingContext] Attempted to add notification with invalid seller');\r\n      return;\r\n    }\r\n\r\n    const sanitizedMessage = sanitize.strict(message);\r\n    const newNotification: Notification = {\r\n      id: uuidv4(),\r\n      message: sanitizedMessage,\r\n      timestamp: new Date().toISOString(),\r\n      cleared: false,\r\n    };\r\n\r\n    setNotificationStore((prev) => {\r\n      const sellerNotifications = prev[safeSeller] || [];\r\n      const updated = {\r\n        ...prev,\r\n        [safeSeller]: [...sellerNotifications.map(normalizeNotification), newNotification],\r\n      };\r\n      // fire-and-forget\r\n      saveNotificationStore(updated);\r\n      return updated;\r\n    });\r\n  }, []);\r\n\r\n  const {\r\n    subscribeToSellerWithPayment,\r\n    setAddSellerNotificationCallback,\r\n    purchaseListing,\r\n    orderHistory,\r\n    unsubscribeFromSeller: walletUnsubscribeFromSeller,\r\n  } = useWallet();\r\n\r\n  const { placeBid: auctionPlaceBid, cancelAuction: auctionCancelAuction, processEndedAuction } =\r\n    useAuction();\r\n\r\n  useEffect(() => {\r\n    if (setAddSellerNotificationCallback) {\r\n      setAddSellerNotificationCallback(addSellerNotification);\r\n    }\r\n  }, [setAddSellerNotificationCallback, addSellerNotification]);\r\n\r\n  // ---------- WebSocket: listing sold ----------\r\n  useEffect(() => {\r\n    if (!isConnected || !subscribe) return;\r\n\r\n    const unsubscribe = subscribe('listing:sold' as WebSocketEvent, (data: { listingId?: string; id?: string }) => {\r\n      const id = data.listingId ?? data.id;\r\n      if (!id) return;\r\n\r\n      const now = Date.now();\r\n      const last = listingUpdateDeduplicator.current.get(id);\r\n      if (last && now - last < DEBOUNCE_TIME) return;\r\n      listingUpdateDeduplicator.current.set(id, now);\r\n\r\n      if (soldListingDeduplicator.current.isDuplicate(id)) return;\r\n\r\n      setListings((prev) => {\r\n        if (!prev.some((l) => l.id === id)) return prev;\r\n        const filtered = prev.filter((l) => l.id !== id);\r\n\r\n        if (typeof window !== 'undefined') {\r\n          setTimeout(() => {\r\n            window.dispatchEvent(\r\n              new CustomEvent('listing:removed', { detail: { listingId: id, reason: 'sold' } })\r\n            );\r\n          }, 100);\r\n        }\r\n        return filtered;\r\n      });\r\n    });\r\n\r\n    return () => {\r\n      unsubscribe();\r\n      listingUpdateDeduplicator.current.clear();\r\n    };\r\n  }, [isConnected, subscribe]);\r\n\r\n  // ---------- WebSocket: order created ----------\r\n  useEffect(() => {\r\n    if (!isConnected || !subscribe) return;\r\n\r\n    const unsubscribe = subscribe('order:created' as WebSocketEvent, (data: any) => {\r\n      const order = data?.order || data;\r\n      if (order) {\r\n        setLatestOrder(order);\r\n        if (typeof window !== 'undefined') {\r\n          window.dispatchEvent(new CustomEvent('order:created', { detail: { order } }));\r\n        }\r\n      }\r\n    });\r\n\r\n    return () => {\r\n      unsubscribe();\r\n    };\r\n  }, [isConnected, subscribe]);\r\n\r\n  // Cleanup dedup manager on unmount\r\n  useEffect(() => {\r\n    return () => {\r\n      soldListingDeduplicator.current.destroy();\r\n    };\r\n  }, []);\r\n\r\n  // Listen for notification changes (multi-tab)\r\n  useEffect(() => {\r\n    function handleStorageChange(e: StorageEvent) {\r\n      if (e.key === 'seller_notifications_store') {\r\n        try {\r\n          setNotificationStore(JSON.parse(e.newValue || '{}'));\r\n        } catch {\r\n          setNotificationStore({});\r\n        }\r\n      }\r\n    }\r\n    window.addEventListener('storage', handleStorageChange);\r\n    return () => window.removeEventListener('storage', handleStorageChange);\r\n  }, []);\r\n\r\n  const migrateNotifications = (notifications: NotificationItem[]): Notification[] =>\r\n    notifications.map(normalizeNotification);\r\n\r\n  // Cached fetch (per listing)\r\n  const fetchListingWithCache = useCallback(async (listingId: string) => {\r\n    const now = Date.now();\r\n    const cached = apiRequestCache.current.get(listingId);\r\n    if (cached && now - cached.timestamp < API_CACHE_TIME) {\r\n      return cached.promise;\r\n    }\r\n    const promise = listingsService.getListing(listingId);\r\n    apiRequestCache.current.set(listingId, { timestamp: now, promise });\r\n\r\n    setTimeout(() => {\r\n      const cleanupTime = Date.now();\r\n      for (const [key, value] of apiRequestCache.current.entries()) {\r\n        if (cleanupTime - value.timestamp > API_CACHE_TIME * 2) {\r\n          apiRequestCache.current.delete(key);\r\n        }\r\n      }\r\n    }, API_CACHE_TIME * 2);\r\n\r\n    return promise;\r\n  }, []);\r\n\r\n  // Cache for getListings\r\n  const listingsCache = useRef<{ timestamp: number; promise: Promise<any> } | null>(null);\r\n  const LISTINGS_CACHE_TIME = 1000;\r\n\r\n  // ---------- Initial load ----------\r\n  const loadData = useCallback(async () => {\r\n    if (typeof window === 'undefined') return;\r\n    if (isLoading) return;\r\n\r\n    setIsLoading(true);\r\n    setError(null);\r\n\r\n    try {\r\n      // Users (supports array or { users: [] })\r\n      const usersResult = await usersService.getUsers();\r\n      if (usersResult.success && usersResult.data) {\r\n        const usersMap: { [username: string]: any } = {};\r\n        if (Array.isArray(usersResult.data)) {\r\n          usersResult.data.forEach((u: any) => (usersMap[u.username] = u));\r\n        } else if (\r\n          usersResult.data &&\r\n          typeof usersResult.data === 'object' &&\r\n          'users' in usersResult.data &&\r\n          Array.isArray((usersResult.data as any).users)\r\n        ) {\r\n          (usersResult.data as any).users.forEach((u: any) => (usersMap[u.username] = u));\r\n        }\r\n        setUsers(usersMap);\r\n      }\r\n\r\n      // Listings\r\n      const now = Date.now();\r\n      let listingsResult;\r\n      if (listingsCache.current && now - listingsCache.current.timestamp < LISTINGS_CACHE_TIME) {\r\n        listingsResult = await listingsCache.current.promise;\r\n      } else {\r\n        const promise = listingsService.getListings();\r\n        listingsCache.current = { timestamp: now, promise };\r\n        listingsResult = await promise;\r\n      }\r\n\r\n      if (listingsResult.success && listingsResult.data) {\r\n        setListings(listingsResult.data);\r\n      } else {\r\n        throw new Error(listingsResult.error?.message || 'Failed to load listings');\r\n      }\r\n\r\n      // Subscriptions\r\n      const storedSubs = await storageService.getItem<{ [buyer: string]: string[] }>(\r\n        'subscriptions',\r\n        {}\r\n      );\r\n      setSubscriptions(storedSubs);\r\n\r\n      // Notifications\r\n      const storedNotifications = await storageService.getItem<NotificationStore>(\r\n        'seller_notifications_store',\r\n        {}\r\n      );\r\n      const migrated: NotificationStore = {};\r\n      Object.keys(storedNotifications).forEach((username) => {\r\n        if (Array.isArray(storedNotifications[username])) {\r\n          migrated[username] = migrateNotifications(storedNotifications[username]);\r\n        }\r\n      });\r\n      setNotificationStore(migrated);\r\n      await saveNotificationStore(migrated);\r\n\r\n      setIsAuthReady(true);\r\n    } catch (err: any) {\r\n      console.error('Error loading ListingContext data:', err);\r\n      setError(err?.message || 'Failed to load data');\r\n      setIsAuthReady(true);\r\n      listingsCache.current = null;\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  }, [isLoading]);\r\n\r\n  // Debounced mount-load (browser-safe timer types)\r\n  useEffect(() => {\r\n    let mounted = true;\r\n    let timeoutId: ReturnType<typeof setTimeout>;\r\n    timeoutId = setTimeout(() => {\r\n      if (mounted && !isAuthReady && !isLoading) {\r\n        loadData();\r\n      }\r\n    }, 100);\r\n    return () => {\r\n      mounted = false;\r\n      clearTimeout(timeoutId);\r\n    };\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, []);\r\n\r\n  const persistUsers = async (updated: { [username: string]: any }) => {\r\n    setUsers(updated);\r\n    await storageService.setItem('all_users_v2', updated);\r\n  };\r\n\r\n  // ---------- Refresh listings (cached) ----------\r\n  const refreshListings = useCallback(async () => {\r\n    const now = Date.now();\r\n    if (listingsCache.current && now - listingsCache.current.timestamp < LISTINGS_CACHE_TIME) {\r\n      try {\r\n        const result = await listingsCache.current.promise;\r\n        if (result.success && result.data) {\r\n          setListings(result.data);\r\n        }\r\n        return;\r\n      } catch {\r\n        // fall through to fetch fresh\r\n      }\r\n    }\r\n\r\n    setIsLoading(true);\r\n    setError(null);\r\n    try {\r\n      const promise = listingsService.getListings();\r\n      listingsCache.current = { timestamp: now, promise };\r\n      const listingsResult = await promise;\r\n      if (listingsResult.success && listingsResult.data) {\r\n        setListings(listingsResult.data);\r\n      } else {\r\n        throw new Error(listingsResult.error?.message || 'Failed to refresh listings');\r\n      }\r\n    } catch (err: any) {\r\n      console.error('Error refreshing listings:', err);\r\n      setError(err?.message || 'Failed to refresh listings');\r\n      listingsCache.current = null;\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  }, []);\r\n\r\n  // ---------- Auction checks ----------\r\n  useEffect(() => {\r\n    checkEndedAuctions();\r\n    const interval: ReturnType<typeof setInterval> = setInterval(() => {\r\n      checkEndedAuctions();\r\n    }, 60_000);\r\n    return () => clearInterval(interval);\r\n  }, [listings]); // eslint-disable-line react-hooks/exhaustive-deps\r\n\r\n  // ---------- Create listing ----------\r\n  const addListing = async (listing: NewListingInput): Promise<void> => {\r\n    if (!user || user.role !== 'seller') {\r\n      alert('You must be logged in as a seller to create listings.');\r\n      return;\r\n    }\r\n\r\n    const validationResult = securityService.validateAndSanitize(\r\n      {\r\n        title: listing.title,\r\n        description: listing.description,\r\n        price: listing.price,\r\n        tags: listing.tags,\r\n        wearDuration: listing.hoursWorn,\r\n      },\r\n      listingSchemas.createListingSchema.pick({\r\n        title: true,\r\n        description: true,\r\n        price: true,\r\n        tags: true,\r\n        wearDuration: true,\r\n      }),\r\n      {\r\n        title: sanitize.strict,\r\n        description: sanitize.strict,\r\n        tags: (tags: string[]) => tags?.map((tag) => sanitize.strict(tag)),\r\n      }\r\n    );\r\n\r\n    if (!validationResult.success) {\r\n      alert(\r\n        'Please check your listing details:\\n' +\r\n          Object.values(validationResult.errors || {}).join('\\n')\r\n      );\r\n      return;\r\n    }\r\n\r\n    const myListings = listings.filter((l) => l.seller === user.username);\r\n    const isVerified = user.isVerified || user.verificationStatus === 'verified';\r\n    const maxListings = isVerified ? 25 : 2;\r\n\r\n    if (myListings.length >= maxListings) {\r\n      alert(\r\n        isVerified\r\n          ? 'You have reached the maximum of 25 listings for verified sellers.'\r\n          : 'Unverified sellers can only have 2 active listings. Please verify your account to add more.'\r\n      );\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const sanitizedListing = {\r\n        ...listing,\r\n        title: validationResult.data!.title,\r\n        description: validationResult.data!.description,\r\n        price: validationResult.data!.price,\r\n        tags: validationResult.data!.tags,\r\n        hoursWorn: validationResult.data!.wearDuration,\r\n        seller: user.username,\r\n        isVerified: isVerified,\r\n      };\r\n\r\n      const result = await listingsService.createListing(sanitizedListing);\r\n      if (result.success && result.data) {\r\n        setListings((prev) => [...prev, result.data!]);\r\n        if (typeof window !== 'undefined') {\r\n          window.dispatchEvent(\r\n            new CustomEvent('listingCreated', { detail: { listing: result.data } })\r\n          );\r\n        }\r\n      } else {\r\n        alert(result.error?.message || 'Failed to create listing. Please try again.');\r\n      }\r\n    } catch (error) {\r\n      console.error('Error creating listing:', error);\r\n      alert('An error occurred while creating the listing.');\r\n    }\r\n  };\r\n\r\n  // ---------- Create auction listing ----------\r\n  const addAuctionListing = async (\r\n    listing: AddListingInput,\r\n    auctionSettings: AuctionInput\r\n  ): Promise<void> => {\r\n    if (!user || user.role !== 'seller') {\r\n      alert('You must be logged in as a seller to create auction listings.');\r\n      return;\r\n    }\r\n\r\n    const listingValidation = securityService.validateAndSanitize(\r\n      {\r\n        title: listing.title,\r\n        description: listing.description,\r\n        price: listing.price,\r\n        tags: listing.tags,\r\n        wearDuration: listing.hoursWorn,\r\n      },\r\n      listingSchemas.createListingSchema.pick({\r\n        title: true,\r\n        description: true,\r\n        price: true,\r\n        tags: true,\r\n        wearDuration: true,\r\n      }),\r\n      {\r\n        title: sanitize.strict,\r\n        description: sanitize.strict,\r\n        tags: (tags: string[]) => tags?.map((tag) => sanitize.strict(tag)),\r\n      }\r\n    );\r\n\r\n    if (!listingValidation.success) {\r\n      alert(\r\n        'Please check your listing details:\\n' +\r\n          Object.values(listingValidation.errors || {}).join('\\n')\r\n      );\r\n      return;\r\n    }\r\n\r\n    const amountValidation = securityService.validateAmount(auctionSettings.startingPrice, {\r\n      min: 0.01,\r\n      max: 10_000,\r\n    });\r\n    if (!amountValidation.valid) {\r\n      alert(amountValidation.error || 'Invalid starting price');\r\n      return;\r\n    }\r\n\r\n    if (auctionSettings.reservePrice) {\r\n      const reserveValidation = securityService.validateAmount(auctionSettings.reservePrice, {\r\n        min: auctionSettings.startingPrice,\r\n        max: 10_000,\r\n      });\r\n      if (!reserveValidation.valid) {\r\n        alert('Reserve price must be at least the starting price');\r\n        return;\r\n      }\r\n    }\r\n\r\n    const myListings = listings.filter((l) => l.seller === user.username);\r\n    const isVerified = user.isVerified || user.verificationStatus === 'verified';\r\n    const maxListings = isVerified ? 25 : 2;\r\n\r\n    if (myListings.length >= maxListings) {\r\n      alert(\r\n        isVerified\r\n          ? 'You have reached the maximum of 25 listings for verified sellers.'\r\n          : 'Unverified sellers can only have 2 active listings. Please verify your account to add more.'\r\n      );\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const sanitizedListing = {\r\n        ...listing,\r\n        title: listingValidation.data!.title,\r\n        description: listingValidation.data!.description,\r\n        price: listingValidation.data!.price,\r\n        tags: listingValidation.data!.tags,\r\n        hoursWorn: listingValidation.data!.wearDuration,\r\n        seller: user.username,\r\n        isVerified: isVerified,\r\n        auction: auctionSettings,\r\n      };\r\n\r\n      const result = await listingsService.createListing(sanitizedListing);\r\n      if (result.success && result.data) {\r\n        setListings((prev) => [...prev, result.data!]);\r\n\r\n        addSellerNotification(\r\n          user.username,\r\n          `🔨 You've created a new auction: \"${sanitizedListing.title}\" starting at $${auctionSettings.startingPrice.toFixed(\r\n            2\r\n          )}`\r\n        );\r\n        if (typeof window !== 'undefined') {\r\n          window.dispatchEvent(\r\n            new CustomEvent('listingCreated', { detail: { listing: result.data } })\r\n          );\r\n        }\r\n      } else {\r\n        alert(result.error?.message || 'Failed to create auction listing. Please try again.');\r\n      }\r\n    } catch (error) {\r\n      console.error('Error creating auction listing:', error);\r\n      alert('An error occurred while creating the auction listing.');\r\n    }\r\n  };\r\n\r\n  // ---------- Remove listing ----------\r\n  const removeListing = async (id: string): Promise<void> => {\r\n    try {\r\n      const result = await listingsService.deleteListing(id);\r\n      if (result.success) {\r\n        setListings((prev) => prev.filter((l) => l.id !== id));\r\n\r\n        if (typeof window !== 'undefined') {\r\n          window.dispatchEvent(\r\n            new CustomEvent('listing:removed', { detail: { listingId: id, reason: 'deleted' } })\r\n          );\r\n          window.dispatchEvent(new CustomEvent('listingDeleted', { detail: { listingId: id } }));\r\n        }\r\n      } else {\r\n        throw new Error(result.error?.message || 'Failed to delete listing');\r\n      }\r\n    } catch (error: any) {\r\n      console.error('Error removing listing:', error);\r\n      alert(error?.message || 'Failed to remove listing');\r\n    }\r\n  };\r\n\r\n  // ---------- Purchase + remove ----------\r\n  const purchaseListingAndRemove = async (\r\n    listing: Listing,\r\n    buyerUsername: string\r\n  ): Promise<boolean> => {\r\n    try {\r\n      const sanitizedBuyer = sanitize.username(buyerUsername);\r\n      if (!sanitizedBuyer) return false;\r\n\r\n      const listingForWallet = {\r\n        id: listing.id,\r\n        title: listing.title,\r\n        description: listing.description,\r\n        price: listing.price,\r\n        markedUpPrice: listing.markedUpPrice,\r\n        seller: listing.seller,\r\n        sellerUsername: listing.seller,\r\n        imageUrls: listing.imageUrls,\r\n        type: 'instant' as const,\r\n        status: 'active' as const,\r\n        category: 'panties' as const,\r\n        shippingIncluded: true,\r\n        internationalShipping: false,\r\n        createdAt: listing.date,\r\n        updatedAt: listing.date,\r\n        views: listing.views || 0,\r\n        favorites: 0,\r\n        tags: listing.tags,\r\n        size: undefined,\r\n        color: undefined,\r\n        material: undefined,\r\n        wearTime: listing.hoursWorn?.toString(),\r\n        customizations: [],\r\n        featured: false,\r\n        verified: listing.isVerified,\r\n        nsfw: false,\r\n      };\r\n\r\n      const success = await purchaseListing(listingForWallet as any, sanitizedBuyer);\r\n      if (success) {\r\n        soldListingDeduplicator.current.isDuplicate(listing.id);\r\n        await removeListing(listing.id);\r\n      }\r\n      return success;\r\n    } catch (error) {\r\n      console.error('Error in purchaseListingAndRemove:', error);\r\n      return false;\r\n    }\r\n  };\r\n\r\n  // ---------- Update listing ----------\r\n  const updateListing = async (\r\n    id: string,\r\n    updatedListing: Partial<Omit<Listing, 'id' | 'date' | 'markedUpPrice'>>\r\n  ): Promise<void> => {\r\n    try {\r\n      const sanitizedUpdate: any = { ...updatedListing };\r\n\r\n      if (updatedListing.title) sanitizedUpdate.title = sanitize.strict(updatedListing.title);\r\n      if (updatedListing.description)\r\n        sanitizedUpdate.description = sanitize.strict(updatedListing.description);\r\n      if (Array.isArray(updatedListing.tags)) {\r\n        sanitizedUpdate.tags = updatedListing.tags.map((tag) => sanitize.strict(tag));\r\n      }\r\n\r\n      const result = await listingsService.updateListing(id, sanitizedUpdate);\r\n      if (result.success && result.data) {\r\n        setListings((prev) => prev.map((l) => (l.id === id ? result.data! : l)));\r\n      } else {\r\n        throw new Error(result.error?.message || 'Failed to update listing');\r\n      }\r\n    } catch (error: any) {\r\n      console.error('Error updating listing:', error);\r\n      alert(error?.message || 'Failed to update listing');\r\n    }\r\n  };\r\n\r\n  // ---------- Bidding ----------\r\n  const placeBid = useCallback(\r\n    async (listingId: string, bidder: string, amount: number): Promise<boolean> => {\r\n      try {\r\n        const cleanBidder = sanitize.username(bidder);\r\n        if (!cleanBidder || !Number.isFinite(amount) || amount <= 0) {\r\n          console.error('[ListingContext] Invalid bid input');\r\n          return false;\r\n        }\r\n\r\n        const listing = listings.find((l) => l.id === listingId);\r\n        if (!listing) {\r\n          console.error('[ListingContext] Listing not found:', listingId);\r\n          return false;\r\n        }\r\n\r\n        const isCurrentHighestBidder = listing.auction?.highestBidder === cleanBidder;\r\n        const currentHighestBid = listing.auction?.highestBid || 0;\r\n\r\n        if (isCurrentHighestBidder && currentHighestBid > 0) {\r\n          const bidDifference = amount - currentHighestBid;\r\n          if (!(bidDifference > 0)) {\r\n            console.warn('[ListingContext] Incremental bid must exceed current highest bid');\r\n            return false;\r\n          }\r\n        }\r\n\r\n        const success = await auctionPlaceBid(listingId, cleanBidder, amount);\r\n        if (success) {\r\n          await refreshListings();\r\n          addSellerNotification(\r\n            listing.seller,\r\n            `💰 New bid! ${cleanBidder} bid $${amount.toFixed(2)} on \"${listing.title}\"`\r\n          );\r\n        }\r\n        return success;\r\n      } catch (error) {\r\n        console.error('[ListingContext] Bid error:', error);\r\n        return false;\r\n      }\r\n    },\r\n    [listings, auctionPlaceBid, refreshListings, addSellerNotification]\r\n  );\r\n\r\n  const getAuctionListings = (): Listing[] => listings.filter((l) => l.auction?.isAuction);\r\n  const getActiveAuctions = (): Listing[] =>\r\n    listings.filter((l) => l.auction?.isAuction && l.auction.status === 'active');\r\n  const getEndedAuctions = (): Listing[] =>\r\n    listings.filter((l) => l.auction?.isAuction && l.auction.status === 'ended');\r\n\r\n  // Only sellers/admins check ended auctions\r\n  const checkEndedAuctions = async (): Promise<void> => {\r\n    if (!user || (user.role !== 'seller' && user.role !== 'admin')) return;\r\n\r\n    const activeAuctions = getActiveAuctions();\r\n    const now = new Date();\r\n\r\n    for (const listing of activeAuctions) {\r\n      if (\r\n        listing.auction &&\r\n        new Date(listing.auction.endTime) <= now &&\r\n        (user.username === listing.seller || user.role === 'admin')\r\n      ) {\r\n        const processed = await processEndedAuction(listing);\r\n        if (processed) {\r\n          setListings((prev) =>\r\n            prev.map((l) =>\r\n              l.id === listing.id\r\n                ? { ...l, auction: { ...l.auction!, status: 'ended' as AuctionStatus } }\r\n                : l\r\n            )\r\n          );\r\n\r\n          if (listing.auction.highestBidder) {\r\n            soldListingDeduplicator.current.isDuplicate(listing.id);\r\n            setListings((prev) => prev.filter((l) => l.id !== listing.id));\r\n\r\n            if (typeof window !== 'undefined') {\r\n              window.dispatchEvent(\r\n                new CustomEvent('listing:removed', {\r\n                  detail: { listingId: listing.id, reason: 'auction-sold' },\r\n                })\r\n              );\r\n            }\r\n          }\r\n\r\n          if (listing.auction.highestBidder && listing.auction.highestBid) {\r\n            const sellerEarnings = listing.auction.highestBid * 0.8;\r\n            addSellerNotification(\r\n              listing.seller,\r\n              `🏆 Auction ended: \"${listing.title}\" sold to ${listing.auction.highestBidder} for $${listing.auction.highestBid.toFixed(\r\n                2\r\n              )}. You'll receive $${sellerEarnings.toFixed(2)} (after 20% platform fee)`\r\n            );\r\n          } else {\r\n            addSellerNotification(\r\n              listing.seller,\r\n              `🔨 Auction ended: No valid bids for \"${listing.title}\"`\r\n            );\r\n          }\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  // ---------- Cancel auction ----------\r\n  const cancelAuction = async (listingId: string): Promise<boolean> => {\r\n    if (!user) return false;\r\n\r\n    const listing = listings.find((l) => l.id === listingId);\r\n    if (!listing) return false;\r\n\r\n    if (user.role !== 'admin' && user.username !== listing.seller) return false;\r\n\r\n    const success = await auctionCancelAuction(listingId);\r\n    if (success) {\r\n      setListings((prev) =>\r\n        prev.map((l) =>\r\n          l.id === listingId ? { ...l, auction: { ...l.auction!, status: 'cancelled' } } : l\r\n        )\r\n      );\r\n\r\n      addSellerNotification(listing.seller, `🛑 You cancelled your auction: \"${listing.title}\". All bidders have been refunded.`);\r\n    }\r\n\r\n    return success;\r\n  };\r\n\r\n  // ---------- Drafts ----------\r\n  const saveDraft = async (draft: ListingDraft): Promise<boolean> => {\r\n    if (!user || user.role !== 'seller') {\r\n      console.error('Only sellers can save drafts');\r\n      return false;\r\n    }\r\n\r\n    try {\r\n      const sanitizedDraft = {\r\n        ...draft,\r\n        formState: {\r\n          ...draft.formState,\r\n          title: draft.formState.title ? sanitize.strict(draft.formState.title) : '',\r\n          description: draft.formState.description ? sanitize.strict(draft.formState.description) : '',\r\n          tags: draft.formState.tags ? sanitize.strict(draft.formState.tags) : '',\r\n        },\r\n        seller: user.username,\r\n      };\r\n\r\n      const result = await listingsService.saveDraft(sanitizedDraft);\r\n      return !!result.success;\r\n    } catch (error) {\r\n      console.error('Error saving draft:', error);\r\n      return false;\r\n    }\r\n  };\r\n\r\n  const getDrafts = async (): Promise<ListingDraft[]> => {\r\n    if (!user || user.role !== 'seller') return [];\r\n    try {\r\n      const result = await listingsService.getDrafts(user.username);\r\n      return result.success && result.data ? result.data : [];\r\n    } catch (error) {\r\n      console.error('Error getting drafts:', error);\r\n      return [];\r\n    }\r\n  };\r\n\r\n  const deleteDraft = async (draftId: string): Promise<boolean> => {\r\n    try {\r\n      const result = await listingsService.deleteDraft(draftId);\r\n      return !!result.success;\r\n    } catch (error) {\r\n      console.error('Error deleting draft:', error);\r\n      return false;\r\n    }\r\n  };\r\n\r\n  // ---------- Images ----------\r\n  const uploadImage = async (file: File): Promise<string | null> => {\r\n    const fileValidation = securityService.validateFileUpload(file, {\r\n      maxSize: 5 * 1024 * 1024,\r\n      allowedTypes: ['image/jpeg', 'image/jpg', 'image/png', 'image/webp'],\r\n      allowedExtensions: ['jpg', 'jpeg', 'png', 'webp'],\r\n    });\r\n    if (!fileValidation.valid) {\r\n      alert(fileValidation.error || 'Invalid file');\r\n      return null;\r\n    }\r\n    try {\r\n      const result = await listingsService.uploadImage(file);\r\n      return result.success && result.data ? result.data : null;\r\n    } catch (error) {\r\n      console.error('Error uploading image:', error);\r\n      return null;\r\n    }\r\n  };\r\n\r\n  const deleteImage = async (imageUrl: string): Promise<boolean> => {\r\n    try {\r\n      const sanitizedUrl = sanitize.url(imageUrl);\r\n      if (!sanitizedUrl) {\r\n        console.error('Invalid image URL');\r\n        return false;\r\n      }\r\n      const result = await listingsService.deleteImage(sanitizedUrl);\r\n      return !!result.success;\r\n    } catch (error) {\r\n      console.error('Error deleting image:', error);\r\n      return false;\r\n    }\r\n  };\r\n\r\n  // ---------- Subscriptions ----------\r\n  const subscribeToSeller = async (buyer: string, seller: string, price: number): Promise<boolean> => {\r\n    const priceValidation = securityService.validateAmount(price, { min: 0.01, max: 1000 });\r\n    if (!priceValidation.valid) {\r\n      console.error('Invalid subscription price:', priceValidation.error);\r\n      return false;\r\n    }\r\n\r\n    const sanitizedBuyer = sanitize.username(buyer);\r\n    const sanitizedSeller = sanitize.username(seller);\r\n    if (!sanitizedBuyer || !sanitizedSeller) return false;\r\n\r\n    const success = await subscribeToSellerWithPayment(sanitizedBuyer, sanitizedSeller, price);\r\n    if (success) {\r\n      setSubscriptions((prev) => {\r\n        const updated = {\r\n          ...prev,\r\n          [sanitizedBuyer]: [...(prev[sanitizedBuyer] || []), sanitizedSeller],\r\n        };\r\n        storageService.setItem('subscriptions', updated);\r\n        return updated;\r\n      });\r\n\r\n      const subscriptionDetails =\r\n        (await storageService.getItem<Record<string, SubscriptionData[]>>(\r\n          'subscription_details',\r\n          {}\r\n        )) || {};\r\n      const buyerSubs = subscriptionDetails[sanitizedBuyer] || [];\r\n      const filtered = buyerSubs.filter((sub) => sub.seller !== sanitizedSeller);\r\n      filtered.push({ seller: sanitizedSeller, price, subscribedAt: new Date().toISOString() });\r\n      subscriptionDetails[sanitizedBuyer] = filtered;\r\n      await storageService.setItem('subscription_details', subscriptionDetails);\r\n\r\n      addSellerNotification(sanitizedSeller, `🎉 ${sanitizedBuyer} subscribed to you!`);\r\n    }\r\n    return success;\r\n  };\r\n\r\n  const unsubscribeFromSeller = async (buyer: string, seller: string): Promise<void> => {\r\n    try {\r\n      const sanitizedBuyer = sanitize.username(buyer);\r\n      const sanitizedSeller = sanitize.username(seller);\r\n      if (!sanitizedBuyer || !sanitizedSeller) return;\r\n\r\n      let success = false;\r\n      if (walletUnsubscribeFromSeller && typeof walletUnsubscribeFromSeller === 'function') {\r\n        success = await walletUnsubscribeFromSeller(sanitizedBuyer, sanitizedSeller);\r\n      } else {\r\n        console.warn('[ListingContext] Wallet unsubscribe method not available; local update only');\r\n        success = true;\r\n      }\r\n\r\n      if (success) {\r\n        setSubscriptions((prev) => {\r\n          const updated = {\r\n            ...prev,\r\n            [sanitizedBuyer]: (prev[sanitizedBuyer] || []).filter((s) => s !== sanitizedSeller),\r\n          };\r\n        storageService.setItem('subscriptions', updated);\r\n          return updated;\r\n        });\r\n\r\n        const subscriptionDetails =\r\n          (await storageService.getItem<Record<string, SubscriptionData[]>>(\r\n            'subscription_details',\r\n            {}\r\n          )) || {};\r\n        const buyerSubs = subscriptionDetails[sanitizedBuyer] || [];\r\n        subscriptionDetails[sanitizedBuyer] = buyerSubs.filter(\r\n          (sub) => sub.seller !== sanitizedSeller\r\n        );\r\n        await storageService.setItem('subscription_details', subscriptionDetails);\r\n\r\n        addSellerNotification(sanitizedSeller, `${sanitizedBuyer} unsubscribed from your content`);\r\n      } else {\r\n        throw new Error('Failed to unsubscribe. Please try again.');\r\n      }\r\n    } catch (error) {\r\n      console.error('[ListingContext] Error in unsubscribeFromSeller:', error);\r\n      throw error;\r\n    }\r\n  };\r\n\r\n  const isSubscribed = (buyer: string, seller: string): boolean => {\r\n    const sanitizedBuyer = sanitize.username(buyer);\r\n    const sanitizedSeller = sanitize.username(seller);\r\n    if (!sanitizedBuyer || !sanitizedSeller) return false;\r\n    return subscriptions[sanitizedBuyer]?.includes(sanitizedSeller) ?? false;\r\n  };\r\n\r\n  // ---------- Seller notifications (current) ----------\r\n  const getCurrentSellerNotifications = (): Notification[] => {\r\n    if (!user || user.role !== 'seller') return [];\r\n    const safeUser = sanitize.username(user.username);\r\n    if (!safeUser) return [];\r\n    const userNotifications = notificationStore[safeUser] || [];\r\n    return userNotifications.map(normalizeNotification);\r\n  };\r\n\r\n  const clearSellerNotification = (notificationId: string | number) => {\r\n    if (!user || user.role !== 'seller') return;\r\n\r\n    const username = sanitize.username(user.username);\r\n    if (!username) return;\r\n\r\n    const userNotifications = notificationStore[username] || [];\r\n    setNotificationStore((prev) => {\r\n      const updatedNotifications = userNotifications.map((item, index) => {\r\n        const notification = normalizeNotification(item);\r\n        const shouldClear =\r\n          typeof notificationId === 'string' ? notification.id === notificationId : index === notificationId;\r\n        return shouldClear ? { ...notification, cleared: true } : notification;\r\n      });\r\n\r\n      const updated = { ...prev, [username]: updatedNotifications };\r\n      saveNotificationStore(updated);\r\n      return updated;\r\n    });\r\n  };\r\n\r\n  const restoreSellerNotification = (notificationId: string) => {\r\n    if (!user || user.role !== 'seller') return;\r\n\r\n    const username = sanitize.username(user.username);\r\n    if (!username) return;\r\n\r\n    const userNotifications = notificationStore[username] || [];\r\n    setNotificationStore((prev) => {\r\n      const updatedNotifications = userNotifications.map((item) => {\r\n        const notification = normalizeNotification(item);\r\n        return notification.id === notificationId ? { ...notification, cleared: false } : notification;\r\n      });\r\n\r\n      const updated = { ...prev, [username]: updatedNotifications };\r\n      saveNotificationStore(updated);\r\n      return updated;\r\n    });\r\n  };\r\n\r\n  const permanentlyDeleteSellerNotification = (notificationId: string) => {\r\n    if (!user || user.role !== 'seller') return;\r\n\r\n    const username = sanitize.username(user.username);\r\n    if (!username) return;\r\n\r\n    const userNotifications = notificationStore[username] || [];\r\n    setNotificationStore((prev) => {\r\n      const updatedNotifications = userNotifications.filter((item) => {\r\n        const notification = normalizeNotification(item);\r\n        return notification.id !== notificationId;\r\n      });\r\n\r\n      const updated = { ...prev, [username]: updatedNotifications };\r\n      saveNotificationStore(updated);\r\n      return updated;\r\n    });\r\n  };\r\n\r\n  // ---------- Verification ----------\r\n  const requestVerification = async (docs: VerificationDocs): Promise<void> => {\r\n    if (!user) return;\r\n\r\n    const code =\r\n      docs.code || `VERIF-${user.username}-${Math.floor(100000 + Math.random() * 900000)}`;\r\n\r\n    try {\r\n      const result = await usersService.requestVerification(user.username, { ...docs, code });\r\n      if (result.success) {\r\n        await updateUser({\r\n          verificationStatus: 'pending',\r\n          verificationRequestedAt: new Date().toISOString(),\r\n          verificationDocs: { ...docs, code },\r\n        });\r\n\r\n        const updatedUser = {\r\n          ...user,\r\n          verificationStatus: 'pending' as VerificationStatus,\r\n          verificationDocs: { ...docs, code },\r\n          verificationRequestedAt: new Date().toISOString(),\r\n        };\r\n\r\n        await persistUsers({\r\n          ...users,\r\n          [user.username]: updatedUser,\r\n        });\r\n      } else {\r\n        alert('Failed to submit verification request. Please try again.');\r\n      }\r\n    } catch (error) {\r\n      console.error('Error submitting verification request:', error);\r\n      alert('An error occurred while submitting verification request.');\r\n    }\r\n  };\r\n\r\n  const setVerificationStatus = async (\r\n    username: string,\r\n    status: VerificationStatus,\r\n    rejectionReason?: string\r\n  ): Promise<void> => {\r\n    // client gate: admin only\r\n    if (!user || user.role !== 'admin') {\r\n      console.warn('[ListingContext] setVerificationStatus blocked: admin only');\r\n      return;\r\n    }\r\n\r\n    const sanitizedUsername = sanitize.username(username);\r\n    const sanitizedReason = rejectionReason ? sanitize.strict(rejectionReason) : undefined;\r\n    if (!sanitizedUsername) return;\r\n\r\n    const existingUser = users[sanitizedUsername];\r\n    if (!existingUser) return;\r\n\r\n    try {\r\n      const result = await usersService.updateVerificationStatus(sanitizedUsername, {\r\n        status,\r\n        rejectionReason: sanitizedReason,\r\n        adminUsername: user.username,\r\n      });\r\n\r\n      if (result.success) {\r\n        const updatedUser = {\r\n          ...existingUser,\r\n          verificationStatus: status,\r\n          verified: status === 'verified',\r\n          verificationReviewedAt: new Date().toISOString(),\r\n          verificationRejectionReason: sanitizedReason,\r\n        };\r\n\r\n        if (user?.username === sanitizedUsername) {\r\n          await updateUser({\r\n            verificationStatus: status,\r\n            isVerified: status === 'verified',\r\n            verificationRejectionReason: sanitizedReason,\r\n          });\r\n        }\r\n\r\n        await persistUsers({\r\n          ...users,\r\n          [sanitizedUsername]: updatedUser,\r\n        });\r\n\r\n        setListings((prev) =>\r\n          prev.map((l) => (l.seller === sanitizedUsername ? { ...l, isVerified: status === 'verified' } : l))\r\n        );\r\n      } else {\r\n        alert('Failed to update verification status. Please try again.');\r\n      }\r\n    } catch (error) {\r\n      console.error('Error updating verification status:', error);\r\n      alert('An error occurred while updating verification status.');\r\n    }\r\n  };\r\n\r\n  const sellerNotifications = getCurrentSellerNotifications();\r\n\r\n  return (\r\n    <ListingContext.Provider\r\n      value={{\r\n        isAuthReady,\r\n        listings,\r\n        addListing,\r\n        addAuctionListing,\r\n        removeListing,\r\n        updateListing,\r\n        purchaseListingAndRemove,\r\n        placeBid,\r\n        getAuctionListings,\r\n        getActiveAuctions,\r\n        getEndedAuctions,\r\n        checkEndedAuctions,\r\n        cancelAuction,\r\n        saveDraft,\r\n        getDrafts,\r\n        deleteDraft,\r\n        uploadImage,\r\n        deleteImage,\r\n        subscriptions,\r\n        subscribeToSeller,\r\n        unsubscribeFromSeller,\r\n        isSubscribed,\r\n        sellerNotifications,\r\n        addSellerNotification,\r\n        clearSellerNotification,\r\n        restoreSellerNotification,\r\n        permanentlyDeleteSellerNotification,\r\n        requestVerification,\r\n        setVerificationStatus,\r\n        users,\r\n        orderHistory,\r\n        latestOrder,\r\n        isLoading,\r\n        error,\r\n        refreshListings,\r\n      }}\r\n    >\r\n      {children}\r\n    </ListingContext.Provider>\r\n  );\r\n};\r\n\r\nexport const useListings = () => {\r\n  const context = useContext(ListingContext);\r\n  if (!context) throw new Error('useListings must be used within a ListingProvider');\r\n  return context;\r\n};\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 5645, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/gerom/OneDrive/Documents/pantypost/src/context/MessageContext.tsx"],"sourcesContent":["// src/context/MessageContext.tsx\r\nimport React, { createContext, useContext, useState, useEffect, ReactNode, useCallback, useRef } from 'react';\r\nimport { sanitizeStrict } from '@/utils/security/sanitization';\r\nimport { v4 as uuidv4 } from 'uuid';\r\nimport { messagesService, storageService } from '@/services';\r\nimport { messageSchemas } from '@/utils/validation/schemas';\r\nimport { z } from 'zod';\r\n\r\n// Import WebSocket context\r\nimport { useWebSocket } from '@/context/WebSocketContext';\r\nimport { WebSocketEvent } from '@/types/websocket';\r\n\r\n// Enhanced Message type with id and isRead\r\ntype Message = {\r\n  id?: string;\r\n  sender: string;\r\n  receiver: string;\r\n  content: string;\r\n  date: string;\r\n  isRead?: boolean;\r\n  read?: boolean;\r\n  type?: 'normal' | 'customRequest' | 'image' | 'tip';\r\n  meta?: {\r\n    id?: string;\r\n    title?: string;\r\n    price?: number;\r\n    tags?: string[];\r\n    message?: string;\r\n    imageUrl?: string;\r\n    tipAmount?: number;\r\n  };\r\n  threadId?: string;\r\n  _optimisticId?: string; // Track optimistic messages\r\n};\r\n\r\n// Enhanced ReportLog type with processing status\r\ntype ReportLog = {\r\n  id?: string;\r\n  reporter: string;\r\n  reportee: string;\r\n  messages: Message[];\r\n  date: string;\r\n  processed?: boolean;\r\n  banApplied?: boolean;\r\n  banId?: string;\r\n  severity?: 'low' | 'medium' | 'high' | 'critical';\r\n  category?: 'harassment' | 'spam' | 'inappropriate_content' | 'scam' | 'other';\r\n  adminNotes?: string;\r\n  processedBy?: string;\r\n  processedAt?: string;\r\n};\r\n\r\ntype MessageOptions = {\r\n  type?: 'normal' | 'customRequest' | 'image' | 'tip';\r\n  meta?: {\r\n    id?: string;\r\n    title?: string;\r\n    price?: number;\r\n    tags?: string[];\r\n    message?: string;\r\n    imageUrl?: string;\r\n    tipAmount?: number;\r\n  };\r\n  _optimisticId?: string; // Track optimistic ID\r\n};\r\n\r\n// Thread type for organized message threads\r\ntype MessageThread = {\r\n  [otherParty: string]: Message[];\r\n};\r\n\r\n// Thread info type for additional thread metadata\r\ntype ThreadInfo = {\r\n  unreadCount: number;\r\n  lastMessage: Message | null;\r\n  otherParty: string;\r\n};\r\n\r\n// Message notification type\r\ntype MessageNotification = {\r\n  buyer: string;\r\n  messageCount: number;\r\n  lastMessage: string;\r\n  timestamp: string;\r\n};\r\n\r\n// Enhanced MessageContextType with additional methods\r\ntype MessageContextType = {\r\n  messages: { [conversationKey: string]: Message[] };\r\n  isLoading: boolean;\r\n  sendMessage: (\r\n    sender: string,\r\n    receiver: string,\r\n    content: string,\r\n    options?: MessageOptions\r\n  ) => Promise<void>;\r\n  sendCustomRequest: (\r\n    buyer: string,\r\n    seller: string,\r\n    content: string,\r\n    title: string,\r\n    price: number,\r\n    tags: string[],\r\n    listingId: string\r\n  ) => void;\r\n  getMessagesForUsers: (userA: string, userB: string) => Message[];\r\n  getThreadsForUser: (username: string, role?: 'buyer' | 'seller') => MessageThread;\r\n  getThreadInfo: (username: string, otherParty: string) => ThreadInfo;\r\n  getAllThreadsInfo: (username: string, role?: 'buyer' | 'seller') => { [otherParty: string]: ThreadInfo };\r\n  markMessagesAsRead: (userA: string, userB: string) => Promise<void>;\r\n  blockUser: (blocker: string, blockee: string) => Promise<void>;\r\n  unblockUser: (blocker: string, blockee: string) => Promise<void>;\r\n  reportUser: (reporter: string, reportee: string) => Promise<void>;\r\n  isBlocked: (blocker: string, blockee: string) => boolean;\r\n  hasReported: (reporter: string, reportee: string) => boolean;\r\n  getReportCount: () => number;\r\n  blockedUsers: { [user: string]: string[] };\r\n  reportedUsers: { [user: string]: string[] };\r\n  reportLogs: ReportLog[];\r\n  messageNotifications: { [seller: string]: MessageNotification[] };\r\n  clearMessageNotifications: (seller: string, buyer: string) => void;\r\n  refreshMessages: () => void;\r\n};\r\n\r\nconst MessageContext = createContext<MessageContextType | undefined>(undefined);\r\n\r\n// Helper to create a consistent conversation key\r\nconst getConversationKey = (userA: string, userB: string): string => {\r\n  return [userA, userB].sort().join('-');\r\n};\r\n\r\n// Validation schemas\r\nconst customRequestMetaSchema = z.object({\r\n  title: messageSchemas.customRequest.shape.title,\r\n  price: messageSchemas.customRequest.shape.price,\r\n  message: messageSchemas.customRequest.shape.description,\r\n});\r\n\r\nexport const MessageProvider: React.FC<{ children: ReactNode }> = ({ children }) => {\r\n  const [messages, setMessages] = useState<{ [conversationKey: string]: Message[] }>({});\r\n  const [blockedUsers, setBlockedUsers] = useState<{ [user: string]: string[] }>({});\r\n  const [reportedUsers, setReportedUsers] = useState<{ [user: string]: string[] }>({});\r\n  const [reportLogs, setReportLogs] = useState<ReportLog[]>([]);\r\n  const [messageNotifications, setMessageNotifications] = useState<{ [seller: string]: MessageNotification[] }>({});\r\n  const [isLoading, setIsLoading] = useState(true);\r\n  const [updateTrigger, setUpdateTrigger] = useState(0);\r\n\r\n  // Use WebSocket context - with safe fallback\r\n  const wsContext = useWebSocket ? useWebSocket() : null;\r\n  const { subscribe, isConnected } = wsContext || { subscribe: null, isConnected: false };\r\n  \r\n  // Track processed message IDs to prevent duplicates\r\n  const processedMessageIds = useRef<Set<string>>(new Set());\r\n  const optimisticMessageMap = useRef<Map<string, string>>(new Map()); // optimisticId -> realId\r\n  const subscriptionsRef = useRef<(() => void)[]>([]);\r\n\r\n  // Initialize service on mount\r\n  useEffect(() => {\r\n    messagesService.initialize();\r\n  }, []);\r\n\r\n  // Load initial data using services\r\n  useEffect(() => {\r\n    const loadData = async () => {\r\n      if (typeof window === 'undefined') {\r\n        setIsLoading(false);\r\n        return;\r\n      }\r\n\r\n      try {\r\n        setIsLoading(true);\r\n\r\n        // Load messages\r\n        const storedMessages = await storageService.getItem<{ [key: string]: Message[] }>('panty_messages', {});\r\n\r\n        // Ensure we have a valid object\r\n        if (storedMessages && typeof storedMessages === 'object') {\r\n          // Migrate old format if needed\r\n          const needsMigration = Object.values(storedMessages).some(\r\n            value => !Array.isArray(value) || (value.length > 0 && !value[0].sender)\r\n          );\r\n\r\n          if (needsMigration) {\r\n            console.log('Migrating message format...');\r\n            const migrated: { [key: string]: Message[] } = {};\r\n\r\n            Object.entries(storedMessages).forEach(([key, msgs]) => {\r\n              if (Array.isArray(msgs)) {\r\n                msgs.forEach((msg: any) => {\r\n                  if (msg.sender && msg.receiver) {\r\n                    const conversationKey = getConversationKey(msg.sender, msg.receiver);\r\n                    if (!migrated[conversationKey]) {\r\n                      migrated[conversationKey] = [];\r\n                    }\r\n                    migrated[conversationKey].push({\r\n                      ...msg,\r\n                      content: sanitizeStrict(msg.content || '')\r\n                    });\r\n                  }\r\n                });\r\n              }\r\n            });\r\n\r\n            setMessages(migrated);\r\n            await storageService.setItem('panty_messages', migrated);\r\n          } else {\r\n            // Sanitize existing messages\r\n            const sanitized: { [key: string]: Message[] } = {};\r\n            Object.entries(storedMessages).forEach(([key, msgs]) => {\r\n              sanitized[key] = msgs.map(msg => ({\r\n                ...msg,\r\n                content: sanitizeStrict(msg.content || '')\r\n              }));\r\n            });\r\n            setMessages(sanitized);\r\n          }\r\n        }\r\n\r\n        // Load blocked users\r\n        const blocked = await storageService.getItem<{ [user: string]: string[] }>('panty_blocked', {});\r\n        setBlockedUsers(blocked || {});\r\n\r\n        // Load reported users\r\n        const reported = await storageService.getItem<{ [user: string]: string[] }>('panty_reported', {});\r\n        setReportedUsers(reported || {});\r\n\r\n        // Load report logs\r\n        const reports = await storageService.getItem<ReportLog[]>('panty_report_logs', []);\r\n        setReportLogs(reports || []);\r\n\r\n        // Load message notifications\r\n        const notifications = await storageService.getItem<{ [seller: string]: MessageNotification[] }>('panty_message_notifications', {});\r\n        setMessageNotifications(notifications || {});\r\n\r\n      } catch (error) {\r\n        console.error('Error loading message data:', error);\r\n      } finally {\r\n        setIsLoading(false);\r\n      }\r\n    };\r\n\r\n    loadData();\r\n  }, []);\r\n\r\n  // FIXED: WebSocket listener for new messages - handle optimistic updates properly\r\n  useEffect(() => {\r\n    // Clean up previous subscriptions\r\n    subscriptionsRef.current.forEach(unsub => unsub());\r\n    subscriptionsRef.current = [];\r\n\r\n    if (!subscribe) {\r\n      console.log('[MessageContext] WebSocket subscribe not available');\r\n      return;\r\n    }\r\n\r\n    console.log('[MessageContext] Setting up WebSocket listeners, connected:', isConnected);\r\n\r\n    // Subscribe to new message events\r\n    const unsubscribeNewMessage = subscribe('message:new' as WebSocketEvent, (data: any) => {\r\n      console.log('[MessageContext] New message received via WebSocket:', data);\r\n      \r\n      if (data && data.sender && data.receiver) {\r\n        const conversationKey = getConversationKey(data.sender, data.receiver);\r\n        \r\n        // Check if we've already processed this message ID\r\n        if (data.id && processedMessageIds.current.has(data.id)) {\r\n          console.log('[MessageContext] Message already processed, skipping:', data.id);\r\n          return;\r\n        }\r\n        \r\n        if (data.id) {\r\n          processedMessageIds.current.add(data.id);\r\n          // Clean up old IDs to prevent memory leak\r\n          if (processedMessageIds.current.size > 1000) {\r\n            const idsArray = Array.from(processedMessageIds.current);\r\n            processedMessageIds.current = new Set(idsArray.slice(-500));\r\n          }\r\n        }\r\n        \r\n        const newMessage: Message = {\r\n          id: data.id || uuidv4(),\r\n          sender: data.sender,\r\n          receiver: data.receiver,\r\n          content: data.content || '',\r\n          date: data.date || data.createdAt || new Date().toISOString(),\r\n          isRead: data.isRead || false,\r\n          read: data.read || false,\r\n          type: data.type || 'normal',\r\n          meta: data.meta,\r\n          threadId: data.threadId || conversationKey,\r\n          _optimisticId: data._optimisticId\r\n        };\r\n        \r\n        console.log('[MessageContext] Processing message for conversation:', conversationKey);\r\n        \r\n        // Update messages state\r\n        setMessages(prev => {\r\n          const existingMessages = prev[conversationKey] || [];\r\n          \r\n          // Check if this is a confirmation of an optimistic message\r\n          if (data._optimisticId) {\r\n            // Store the mapping\r\n            optimisticMessageMap.current.set(data._optimisticId, newMessage.id!);\r\n            \r\n            // Remove the optimistic message and add the confirmed one\r\n            const withoutOptimistic = existingMessages.filter(m => \r\n              m._optimisticId !== data._optimisticId\r\n            );\r\n            \r\n            // Check if the confirmed message already exists\r\n            const isDuplicate = withoutOptimistic.some(m => \r\n              m.id && m.id === newMessage.id\r\n            );\r\n            \r\n            if (isDuplicate) {\r\n              console.log('[MessageContext] Confirmed message already exists, skipping');\r\n              return prev;\r\n            }\r\n            \r\n            const updatedMessages = {\r\n              ...prev,\r\n              [conversationKey]: [...withoutOptimistic, newMessage],\r\n            };\r\n            \r\n            console.log('[MessageContext] Replaced optimistic message with confirmed message');\r\n            \r\n            // Save to storage\r\n            storageService.setItem('panty_messages', updatedMessages).catch(err => \r\n              console.error('[MessageContext] Failed to save messages:', err)\r\n            );\r\n            \r\n            return updatedMessages;\r\n          }\r\n          \r\n          // Check if message already exists (by ID or by content+timestamp for duplicates)\r\n          const isDuplicate = existingMessages.some(m => {\r\n            if (m.id && m.id === newMessage.id) return true;\r\n            \r\n            // Check for duplicate by content and approximate time (within 2 seconds)\r\n            if (m.sender === newMessage.sender && \r\n                m.receiver === newMessage.receiver &&\r\n                m.content === newMessage.content) {\r\n              const timeDiff = Math.abs(new Date(m.date).getTime() - new Date(newMessage.date).getTime());\r\n              return timeDiff < 2000;\r\n            }\r\n            \r\n            return false;\r\n          });\r\n          \r\n          if (isDuplicate) {\r\n            console.log('[MessageContext] Duplicate message detected, skipping');\r\n            return prev;\r\n          }\r\n          \r\n          const updatedMessages = {\r\n            ...prev,\r\n            [conversationKey]: [...existingMessages, newMessage],\r\n          };\r\n          \r\n          console.log('[MessageContext] Added new message to conversation');\r\n          \r\n          // Save to storage\r\n          storageService.setItem('panty_messages', updatedMessages).catch(err => \r\n            console.error('[MessageContext] Failed to save messages:', err)\r\n          );\r\n          \r\n          return updatedMessages;\r\n        });\r\n        \r\n        // Force a re-render to ensure UI updates\r\n        setUpdateTrigger(prev => {\r\n          console.log('[MessageContext] Triggering update:', prev + 1);\r\n          return prev + 1;\r\n        });\r\n        \r\n        // Update notifications if it's not a custom request\r\n        if (data.type !== 'customRequest') {\r\n          setMessageNotifications(prev => {\r\n            const sellerNotifs = prev[data.receiver] || [];\r\n            const existingIndex = sellerNotifs.findIndex((n: MessageNotification) => n.buyer === data.sender);\r\n\r\n            if (existingIndex >= 0) {\r\n              const updated = [...sellerNotifs];\r\n              updated[existingIndex] = {\r\n                buyer: data.sender,\r\n                messageCount: updated[existingIndex].messageCount + 1,\r\n                lastMessage: data.content.substring(0, 50) + (data.content.length > 50 ? '...' : ''),\r\n                timestamp: new Date().toISOString()\r\n              };\r\n              return {\r\n                ...prev,\r\n                [data.receiver]: updated\r\n              };\r\n            } else {\r\n              return {\r\n                ...prev,\r\n                [data.receiver]: [...sellerNotifs, {\r\n                  buyer: data.sender,\r\n                  messageCount: 1,\r\n                  lastMessage: data.content.substring(0, 50) + (data.content.length > 50 ? '...' : ''),\r\n                  timestamp: new Date().toISOString()\r\n                }]\r\n              };\r\n            }\r\n          });\r\n        }\r\n        \r\n        // Emit a custom event for components to listen to\r\n        if (typeof window !== 'undefined') {\r\n          console.log('[MessageContext] Dispatching DOM event for new message');\r\n          window.dispatchEvent(new CustomEvent('message:new', { detail: newMessage }));\r\n        }\r\n      }\r\n    });\r\n\r\n    // Also listen for message:read events\r\n    const unsubscribeRead = subscribe('message:read' as WebSocketEvent, (data: any) => {\r\n      console.log('[MessageContext] Messages marked as read via WebSocket:', data);\r\n      \r\n      if (data && data.threadId && data.messageIds) {\r\n        setMessages(prev => {\r\n          const updatedMessages = { ...prev };\r\n          if (updatedMessages[data.threadId]) {\r\n            updatedMessages[data.threadId] = updatedMessages[data.threadId].map(msg => {\r\n              // Check both real ID and optimistic ID mapping\r\n              const realId = msg._optimisticId ? \r\n                optimisticMessageMap.current.get(msg._optimisticId) || msg.id : \r\n                msg.id;\r\n                \r\n              if (realId && data.messageIds.includes(realId)) {\r\n                return { ...msg, isRead: true, read: true };\r\n              }\r\n              return msg;\r\n            });\r\n          }\r\n          \r\n          // Save to storage\r\n          storageService.setItem('panty_messages', updatedMessages).catch(err => \r\n            console.error('[MessageContext] Failed to save messages after read update:', err)\r\n          );\r\n          \r\n          return updatedMessages;\r\n        });\r\n        \r\n        // Emit DOM event for read status update\r\n        if (typeof window !== 'undefined') {\r\n          window.dispatchEvent(new CustomEvent('message:read', { detail: data }));\r\n        }\r\n        \r\n        // Force a re-render\r\n        setUpdateTrigger(prev => prev + 1);\r\n      }\r\n    });\r\n\r\n    subscriptionsRef.current = [unsubscribeNewMessage, unsubscribeRead];\r\n\r\n    return () => {\r\n      console.log('[MessageContext] Cleaning up WebSocket listeners');\r\n      subscriptionsRef.current.forEach(unsub => unsub());\r\n      subscriptionsRef.current = [];\r\n    };\r\n  }, [subscribe, isConnected]);\r\n\r\n  // Save data whenever it changes\r\n  useEffect(() => {\r\n    if (typeof window !== 'undefined' && !isLoading) {\r\n      storageService.setItem('panty_messages', messages);\r\n    }\r\n  }, [messages, isLoading]);\r\n\r\n  useEffect(() => {\r\n    if (typeof window !== 'undefined' && !isLoading) {\r\n      storageService.setItem('panty_blocked', blockedUsers);\r\n    }\r\n  }, [blockedUsers, isLoading]);\r\n\r\n  useEffect(() => {\r\n    if (typeof window !== 'undefined' && !isLoading) {\r\n      storageService.setItem('panty_reported', reportedUsers);\r\n    }\r\n  }, [reportedUsers, isLoading]);\r\n\r\n  useEffect(() => {\r\n    if (typeof window !== 'undefined' && !isLoading) {\r\n      storageService.setItem('panty_report_logs', reportLogs);\r\n    }\r\n  }, [reportLogs, isLoading]);\r\n\r\n  useEffect(() => {\r\n    if (typeof window !== 'undefined' && !isLoading) {\r\n      storageService.setItem('panty_message_notifications', messageNotifications);\r\n    }\r\n  }, [messageNotifications, isLoading]);\r\n\r\n  // FIXED: Send message with optimistic ID tracking\r\n  const sendMessage = useCallback(async (\r\n    sender: string,\r\n    receiver: string,\r\n    content: string,\r\n    options?: MessageOptions\r\n  ) => {\r\n    // Validate inputs\r\n    if (!sender || !receiver) {\r\n      console.error('Invalid sender or receiver');\r\n      return;\r\n    }\r\n\r\n    if (!content.trim() && !options?.meta?.imageUrl) {\r\n      console.error('Cannot send empty message without image');\r\n      return;\r\n    }\r\n\r\n    // For image messages, allow empty content or provide default\r\n    let sanitizedContent = content;\r\n    if (options?.type === 'image' && !content.trim() && options?.meta?.imageUrl) {\r\n      sanitizedContent = 'Image shared';\r\n    }\r\n\r\n    // Validate message content only if we have content to validate\r\n    if (sanitizedContent.trim()) {\r\n      const contentValidation = messageSchemas.messageContent.safeParse(sanitizedContent);\r\n      if (!contentValidation.success) {\r\n        console.error('Invalid message content:', contentValidation.error);\r\n        return;\r\n      }\r\n      sanitizedContent = contentValidation.data;\r\n    }\r\n\r\n    // Validate and sanitize meta fields if present\r\n    let sanitizedMeta = options?.meta;\r\n    if (sanitizedMeta) {\r\n      sanitizedMeta = {\r\n        ...sanitizedMeta,\r\n        title: sanitizedMeta.title ? sanitizeStrict(sanitizedMeta.title) : undefined,\r\n        message: sanitizedMeta.message ? sanitizeStrict(sanitizedMeta.message) : undefined,\r\n        tags: sanitizedMeta.tags?.map(tag => sanitizeStrict(tag).slice(0, 30)),\r\n      };\r\n    }\r\n\r\n    try {\r\n      // Include optimistic ID if provided\r\n      const messageData = {\r\n        sender,\r\n        receiver,\r\n        content: sanitizedContent,\r\n        type: options?.type,\r\n        meta: sanitizedMeta,\r\n        _optimisticId: options?._optimisticId\r\n      };\r\n      \r\n      const result = await messagesService.sendMessage(messageData);\r\n\r\n      if (result.success && result.data) {\r\n        // DON'T add the message to local state here - let WebSocket handle it\r\n        // This prevents duplicates\r\n        console.log('Message sent successfully, waiting for WebSocket confirmation');\r\n        \r\n        // Only update notifications locally since WebSocket won't handle this\r\n        if (options?.type !== 'customRequest') {\r\n          setMessageNotifications(prev => {\r\n            const sellerNotifs = prev[receiver] || [];\r\n            const existingIndex = sellerNotifs.findIndex(n => n.buyer === sender);\r\n\r\n            if (existingIndex >= 0) {\r\n              const updated = [...sellerNotifs];\r\n              updated[existingIndex] = {\r\n                buyer: sender,\r\n                messageCount: updated[existingIndex].messageCount + 1,\r\n                lastMessage: sanitizedContent.substring(0, 50) + (sanitizedContent.length > 50 ? '...' : ''),\r\n                timestamp: new Date().toISOString()\r\n              };\r\n              return {\r\n                ...prev,\r\n                [receiver]: updated\r\n              };\r\n            } else {\r\n              return {\r\n                ...prev,\r\n                [receiver]: [...sellerNotifs, {\r\n                  buyer: sender,\r\n                  messageCount: 1,\r\n                  lastMessage: sanitizedContent.substring(0, 50) + (sanitizedContent.length > 50 ? '...' : ''),\r\n                  timestamp: new Date().toISOString()\r\n                }]\r\n              };\r\n            }\r\n          });\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error('Error sending message:', error);\r\n    }\r\n  }, []);\r\n\r\n  const sendCustomRequest = useCallback((\r\n    buyer: string,\r\n    seller: string,\r\n    content: string,\r\n    title: string,\r\n    price: number,\r\n    tags: string[],\r\n    listingId: string\r\n  ) => {\r\n    // Validate custom request data\r\n    const validation = customRequestMetaSchema.safeParse({\r\n      title,\r\n      price,\r\n      message: content,\r\n    });\r\n\r\n    if (!validation.success) {\r\n      console.error('Invalid custom request:', validation.error);\r\n      return;\r\n    }\r\n\r\n    sendMessage(buyer, seller, validation.data.message, {\r\n      type: 'customRequest',\r\n      meta: {\r\n        id: uuidv4(),\r\n        title: validation.data.title,\r\n        price: validation.data.price,\r\n        tags: tags.map(tag => sanitizeStrict(tag).slice(0, 30)),\r\n        message: validation.data.message,\r\n      },\r\n    });\r\n  }, [sendMessage]);\r\n\r\n  const getMessagesForUsers = useCallback((userA: string, userB: string): Message[] => {\r\n    const conversationKey = getConversationKey(userA, userB);\r\n    return messages[conversationKey] || [];\r\n  }, [messages, updateTrigger]); // Add updateTrigger to dependencies\r\n\r\n  const getThreadsForUser = useCallback((username: string, role?: 'buyer' | 'seller'): MessageThread => {\r\n    const threads: MessageThread = {};\r\n\r\n    Object.entries(messages).forEach(([key, msgs]) => {\r\n      msgs.forEach(msg => {\r\n        if (msg.sender === username || msg.receiver === username) {\r\n          const otherParty = msg.sender === username ? msg.receiver : msg.sender;\r\n          if (!threads[otherParty]) {\r\n            threads[otherParty] = [];\r\n          }\r\n          threads[otherParty].push(msg);\r\n        }\r\n      });\r\n    });\r\n\r\n    Object.values(threads).forEach(thread => {\r\n      thread.sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());\r\n    });\r\n\r\n    return threads;\r\n  }, [messages, updateTrigger]); // Add updateTrigger to dependencies\r\n\r\n  const getThreadInfo = useCallback((username: string, otherParty: string): ThreadInfo => {\r\n    const conversationKey = getConversationKey(username, otherParty);\r\n    const threadMessages = messages[conversationKey] || [];\r\n\r\n    const unreadCount = threadMessages.filter(\r\n      msg => msg.receiver === username && !msg.read && !msg.isRead\r\n    ).length;\r\n\r\n    const lastMessage = threadMessages.length > 0 ?\r\n      threadMessages[threadMessages.length - 1] : null;\r\n\r\n    return {\r\n      unreadCount,\r\n      lastMessage,\r\n      otherParty\r\n    };\r\n  }, [messages, updateTrigger]); // Add updateTrigger to dependencies\r\n\r\n  const getAllThreadsInfo = useCallback((username: string, role?: 'buyer' | 'seller'): { [otherParty: string]: ThreadInfo } => {\r\n    const threads = getThreadsForUser(username, role);\r\n    const threadInfos: { [otherParty: string]: ThreadInfo } = {};\r\n\r\n    Object.keys(threads).forEach(otherParty => {\r\n      threadInfos[otherParty] = getThreadInfo(username, otherParty);\r\n    });\r\n\r\n    return threadInfos;\r\n  }, [getThreadsForUser, getThreadInfo]);\r\n\r\n  const markMessagesAsRead = useCallback(async (userA: string, userB: string) => {\r\n    try {\r\n      const result = await messagesService.markMessagesAsRead(userA, userB);\r\n      if (result.success) {\r\n        const conversationKey = getConversationKey(userA, userB);\r\n        setMessages(prev => {\r\n          const conversationMessages = prev[conversationKey] || [];\r\n          const updatedMessages = conversationMessages.map(msg =>\r\n            msg.receiver === userA && msg.sender === userB && !msg.read\r\n              ? { ...msg, read: true, isRead: true }\r\n              : msg\r\n          );\r\n\r\n          const updated = {\r\n            ...prev,\r\n            [conversationKey]: updatedMessages,\r\n          };\r\n          \r\n          // Save to storage\r\n          storageService.setItem('panty_messages', updated).catch(err => \r\n            console.error('[MessageContext] Failed to save messages after marking read:', err)\r\n          );\r\n          \r\n          return updated;\r\n        });\r\n\r\n        clearMessageNotifications(userA, userB);\r\n        \r\n        // Force a re-render\r\n        setUpdateTrigger(prev => prev + 1);\r\n      }\r\n    } catch (error) {\r\n      console.error('Error marking messages as read:', error);\r\n    }\r\n  }, []);\r\n\r\n  const clearMessageNotifications = useCallback((seller: string, buyer: string) => {\r\n    setMessageNotifications(prev => {\r\n      const sellerNotifs = prev[seller] || [];\r\n      const filtered = sellerNotifs.filter(n => n.buyer !== buyer);\r\n\r\n      if (filtered.length === sellerNotifs.length) {\r\n        return prev;\r\n      }\r\n\r\n      return {\r\n        ...prev,\r\n        [seller]: filtered\r\n      };\r\n    });\r\n  }, []);\r\n\r\n  const blockUser = useCallback(async (blocker: string, blockee: string) => {\r\n    try {\r\n      const result = await messagesService.blockUser({\r\n        blocker,\r\n        blocked: blockee,\r\n      });\r\n\r\n      if (result.success) {\r\n        setBlockedUsers(prev => {\r\n          const blockerList = prev[blocker] || [];\r\n          if (!blockerList.includes(blockee)) {\r\n            return {\r\n              ...prev,\r\n              [blocker]: [...blockerList, blockee],\r\n            };\r\n          }\r\n          return prev;\r\n        });\r\n      }\r\n    } catch (error) {\r\n      console.error('Error blocking user:', error);\r\n    }\r\n  }, []);\r\n\r\n  const unblockUser = useCallback(async (blocker: string, blockee: string) => {\r\n    try {\r\n      const result = await messagesService.unblockUser({\r\n        blocker,\r\n        blocked: blockee,\r\n      });\r\n\r\n      if (result.success) {\r\n        setBlockedUsers(prev => {\r\n          const blockerList = prev[blocker] || [];\r\n          return {\r\n            ...prev,\r\n            [blocker]: blockerList.filter(b => b !== blockee),\r\n          };\r\n        });\r\n      }\r\n    } catch (error) {\r\n      console.error('Error unblocking user:', error);\r\n    }\r\n  }, []);\r\n\r\n  const reportUser = useCallback(async (reporter: string, reportee: string) => {\r\n    const conversationKey = getConversationKey(reporter, reportee);\r\n    const reportMessages = messages[conversationKey] || [];\r\n\r\n    try {\r\n      const result = await messagesService.reportUser({\r\n        reporter,\r\n        reportee,\r\n        messages: reportMessages,\r\n      });\r\n\r\n      if (result.success) {\r\n        setReportedUsers(prev => {\r\n          const reporterList = prev[reporter] || [];\r\n          if (!reporterList.includes(reportee)) {\r\n            return {\r\n              ...prev,\r\n              [reporter]: [...reporterList, reportee],\r\n            };\r\n          }\r\n          return prev;\r\n        });\r\n\r\n        const newReport: ReportLog = {\r\n          id: uuidv4(),\r\n          reporter,\r\n          reportee,\r\n          messages: reportMessages,\r\n          date: new Date().toISOString(),\r\n          processed: false,\r\n          category: 'other'\r\n        };\r\n\r\n        setReportLogs(prev => [...prev, newReport]);\r\n      }\r\n    } catch (error) {\r\n      console.error('Error reporting user:', error);\r\n    }\r\n  }, [messages]);\r\n\r\n  const isBlocked = useCallback((blocker: string, blockee: string): boolean => {\r\n    return blockedUsers[blocker]?.includes(blockee) ?? false;\r\n  }, [blockedUsers]);\r\n\r\n  const hasReported = useCallback((reporter: string, reportee: string): boolean => {\r\n    return reportedUsers[reporter]?.includes(reportee) ?? false;\r\n  }, [reportedUsers]);\r\n\r\n  const getReportCount = useCallback((): number => {\r\n    return reportLogs.filter(report => !report.processed).length;\r\n  }, [reportLogs]);\r\n\r\n  // Add a method to force refresh messages\r\n  const refreshMessages = useCallback(() => {\r\n    console.log('[MessageContext] Force refresh triggered');\r\n    setUpdateTrigger(prev => prev + 1);\r\n  }, []);\r\n\r\n  return (\r\n    <MessageContext.Provider\r\n      value={{\r\n        messages,\r\n        isLoading,\r\n        sendMessage,\r\n        sendCustomRequest,\r\n        getMessagesForUsers,\r\n        getThreadsForUser,\r\n        getThreadInfo,\r\n        getAllThreadsInfo,\r\n        markMessagesAsRead,\r\n        blockUser,\r\n        unblockUser,\r\n        reportUser,\r\n        isBlocked,\r\n        hasReported,\r\n        getReportCount,\r\n        blockedUsers,\r\n        reportedUsers,\r\n        reportLogs,\r\n        messageNotifications,\r\n        clearMessageNotifications,\r\n        refreshMessages,\r\n      }}\r\n    >\r\n      {children}\r\n    </MessageContext.Provider>\r\n  );\r\n};\r\n\r\nexport const useMessages = () => {\r\n  const context = useContext(MessageContext);\r\n  if (!context) {\r\n    throw new Error('useMessages must be used within a MessageProvider');\r\n  }\r\n  return context;\r\n};\r\n\r\n// Enhanced external getReportCount function for header use\r\nexport const getReportCount = async (): Promise<number> => {\r\n  try {\r\n    if (typeof window === 'undefined') return 0;\r\n\r\n    const reports = await storageService.getItem<ReportLog[]>('panty_report_logs', []);\r\n    if (!Array.isArray(reports)) return 0;\r\n\r\n    const pendingReports = reports.filter(report =>\r\n      report &&\r\n      typeof report === 'object' &&\r\n      !report.processed\r\n    );\r\n\r\n    return pendingReports.length;\r\n  } catch (error) {\r\n    console.error('Error getting external report count:', error);\r\n    return 0;\r\n  }\r\n};"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 6309, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/gerom/OneDrive/Documents/pantypost/src/context/ReviewContext.tsx"],"sourcesContent":["// src/context/ReviewContext.tsx\r\n'use client';\r\n\r\nimport { createContext, useContext, useState, useEffect, ReactNode, useCallback } from 'react';\r\nimport { reviewsService, Review as ServiceReview, ReviewStats } from '@/services/reviews.service';\r\nimport { useAuth } from './AuthContext';\r\nimport { sanitizeStrict } from '@/utils/security/sanitization';\r\nimport { z } from 'zod';\r\n\r\nexport type Review = {\r\n  _id?: string;\r\n  orderId?: string;\r\n  reviewer: string;\r\n  reviewee?: string;\r\n  rating: number;\r\n  comment: string;\r\n  date: string;\r\n  asDescribed?: boolean;\r\n  fastShipping?: boolean;\r\n  wouldBuyAgain?: boolean;\r\n  sellerResponse?: {\r\n    text: string;\r\n    date: string;\r\n  };\r\n};\r\n\r\n// Validation schema for reviews\r\nconst reviewSchema = z.object({\r\n  rating: z.number().int().min(1).max(5),\r\n  comment: z.string().min(10, 'Review must be at least 10 characters').max(500, 'Review must be less than 500 characters'),\r\n});\r\n\r\ntype ReviewContextType = {\r\n  getReviewsForSeller: (sellerUsername: string) => Promise<Review[]>;\r\n  addReview: (sellerUsername: string, orderId: string, review: Omit<Review, 'reviewer' | 'date'>) => Promise<boolean>;\r\n  hasReviewed: (orderId: string) => Promise<boolean>;\r\n  getReviewStats: (sellerUsername: string) => Promise<ReviewStats | null>;\r\n  isLoading: boolean;\r\n  error: string | null;\r\n};\r\n\r\nconst ReviewContext = createContext<ReviewContextType | undefined>(undefined);\r\n\r\nexport const ReviewProvider: React.FC<{ children: ReactNode }> = ({ children }) => {\r\n  const [cachedReviews, setCachedReviews] = useState<{ [seller: string]: Review[] }>({});\r\n  const [cachedStats, setCachedStats] = useState<{ [seller: string]: ReviewStats }>({});\r\n  const [isLoading, setIsLoading] = useState(false);\r\n  const [error, setError] = useState<string | null>(null);\r\n  const { user } = useAuth();\r\n\r\n  // Clear cache when user changes\r\n  useEffect(() => {\r\n    setCachedReviews({});\r\n    setCachedStats({});\r\n  }, [user?.username]);\r\n\r\n  const getReviewsForSeller = useCallback(async (sellerUsername: string): Promise<Review[]> => {\r\n    try {\r\n      setIsLoading(true);\r\n      setError(null);\r\n\r\n      // Check cache first\r\n      if (cachedReviews[sellerUsername]) {\r\n        return cachedReviews[sellerUsername];\r\n      }\r\n\r\n      // Fetch from API\r\n      const response = await reviewsService.getSellerReviews(sellerUsername);\r\n      \r\n      if (response.success && response.data) {\r\n        const reviews: Review[] = response.data.reviews.map(r => ({\r\n          _id: r._id,\r\n          orderId: r.orderId,\r\n          reviewer: r.reviewer,\r\n          reviewee: r.reviewee,\r\n          rating: r.rating,\r\n          comment: r.comment,\r\n          date: r.createdAt,\r\n          asDescribed: r.asDescribed,\r\n          fastShipping: r.fastShipping,\r\n          wouldBuyAgain: r.wouldBuyAgain,\r\n          sellerResponse: r.sellerResponse,\r\n        }));\r\n\r\n        // Update cache\r\n        setCachedReviews(prev => ({\r\n          ...prev,\r\n          [sellerUsername]: reviews\r\n        }));\r\n\r\n        // Cache stats too\r\n        if (response.data.stats) {\r\n          setCachedStats(prev => ({\r\n            ...prev,\r\n            [sellerUsername]: response.data!.stats\r\n          }));\r\n        }\r\n\r\n        return reviews;\r\n      } else {\r\n        setError(response.error?.message || 'Failed to fetch reviews');\r\n        return [];\r\n      }\r\n    } catch (error) {\r\n      console.error('Error fetching reviews:', error);\r\n      setError('Failed to fetch reviews');\r\n      return [];\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  }, [cachedReviews]);\r\n\r\n  const addReview = useCallback(async (\r\n    sellerUsername: string, \r\n    orderId: string,\r\n    review: Omit<Review, 'reviewer' | 'date'>\r\n  ): Promise<boolean> => {\r\n    try {\r\n      setIsLoading(true);\r\n      setError(null);\r\n\r\n      if (!user?.username) {\r\n        setError('You must be logged in to submit a review');\r\n        return false;\r\n      }\r\n\r\n      // Validate review data\r\n      const validation = reviewSchema.safeParse({\r\n        rating: review.rating,\r\n        comment: review.comment,\r\n      });\r\n\r\n      if (!validation.success) {\r\n        setError(validation.error.errors[0]?.message || 'Invalid review');\r\n        return false;\r\n      }\r\n\r\n      // Create review via API\r\n      const response = await reviewsService.createReview({\r\n        orderId,\r\n        rating: validation.data.rating,\r\n        comment: sanitizeStrict(validation.data.comment),\r\n        asDescribed: review.asDescribed !== false,\r\n        fastShipping: review.fastShipping !== false,\r\n        wouldBuyAgain: review.wouldBuyAgain !== false,\r\n      });\r\n\r\n      if (response.success) {\r\n        // Clear cache for this seller to force refresh\r\n        setCachedReviews(prev => {\r\n          const updated = { ...prev };\r\n          delete updated[sellerUsername];\r\n          return updated;\r\n        });\r\n        setCachedStats(prev => {\r\n          const updated = { ...prev };\r\n          delete updated[sellerUsername];\r\n          return updated;\r\n        });\r\n        \r\n        return true;\r\n      } else {\r\n        setError(response.error?.message || 'Failed to create review');\r\n        return false;\r\n      }\r\n    } catch (error) {\r\n      console.error('Error adding review:', error);\r\n      setError('Failed to add review');\r\n      return false;\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  }, [user?.username]);\r\n\r\n  const hasReviewed = useCallback(async (orderId: string): Promise<boolean> => {\r\n    try {\r\n      setIsLoading(true);\r\n      setError(null);\r\n\r\n      const response = await reviewsService.checkOrderReview(orderId);\r\n      \r\n      if (response.success && response.data) {\r\n        return response.data.hasReview;\r\n      }\r\n      \r\n      return false;\r\n    } catch (error) {\r\n      console.error('Error checking review status:', error);\r\n      return false;\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  }, []);\r\n\r\n  const getReviewStats = useCallback(async (sellerUsername: string): Promise<ReviewStats | null> => {\r\n    try {\r\n      // Check cache first\r\n      if (cachedStats[sellerUsername]) {\r\n        return cachedStats[sellerUsername];\r\n      }\r\n\r\n      // If not in cache, fetch reviews which will also cache stats\r\n      await getReviewsForSeller(sellerUsername);\r\n      \r\n      return cachedStats[sellerUsername] || null;\r\n    } catch (error) {\r\n      console.error('Error getting review stats:', error);\r\n      return null;\r\n    }\r\n  }, [cachedStats, getReviewsForSeller]);\r\n\r\n  return (\r\n    <ReviewContext.Provider value={{ \r\n      getReviewsForSeller, \r\n      addReview, \r\n      hasReviewed,\r\n      getReviewStats,\r\n      isLoading,\r\n      error\r\n    }}>\r\n      {children}\r\n    </ReviewContext.Provider>\r\n  );\r\n};\r\n\r\nexport const useReviews = () => {\r\n  const context = useContext(ReviewContext);\r\n  if (!context) throw new Error('useReviews must be used within a ReviewProvider');\r\n  return context;\r\n};\r\n"],"names":[],"mappings":"AAAA,gCAAgC;;;;;;AAGhC;AACA;AACA;AACA;AACA;AANA;;;;;;;AAyBA,gCAAgC;AAChC,MAAM,eAAe,kKAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC5B,QAAQ,kKAAA,CAAA,IAAC,CAAC,MAAM,GAAG,GAAG,GAAG,GAAG,CAAC,GAAG,GAAG,CAAC;IACpC,SAAS,kKAAA,CAAA,IAAC,CAAC,MAAM,GAAG,GAAG,CAAC,IAAI,yCAAyC,GAAG,CAAC,KAAK;AAChF;AAWA,MAAM,8BAAgB,CAAA,GAAA,qMAAA,CAAA,gBAAa,AAAD,EAAiC;AAE5D,MAAM,iBAAoD,CAAC,EAAE,QAAQ,EAAE;IAC5E,MAAM,CAAC,eAAe,iBAAiB,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAkC,CAAC;IACpF,MAAM,CAAC,aAAa,eAAe,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAqC,CAAC;IACnF,MAAM,CAAC,WAAW,aAAa,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAE;IAC3C,MAAM,CAAC,OAAO,SAAS,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAiB;IAClD,MAAM,EAAE,IAAI,EAAE,GAAG,CAAA,GAAA,8HAAA,CAAA,UAAO,AAAD;IAEvB,gCAAgC;IAChC,CAAA,GAAA,qMAAA,CAAA,YAAS,AAAD,EAAE;QACR,iBAAiB,CAAC;QAClB,eAAe,CAAC;IAClB,GAAG;QAAC,MAAM;KAAS;IAEnB,MAAM,sBAAsB,CAAA,GAAA,qMAAA,CAAA,cAAW,AAAD,EAAE,OAAO;QAC7C,IAAI;YACF,aAAa;YACb,SAAS;YAET,oBAAoB;YACpB,IAAI,aAAa,CAAC,eAAe,EAAE;gBACjC,OAAO,aAAa,CAAC,eAAe;YACtC;YAEA,iBAAiB;YACjB,MAAM,WAAW,MAAM,qIAAA,CAAA,iBAAc,CAAC,gBAAgB,CAAC;YAEvD,IAAI,SAAS,OAAO,IAAI,SAAS,IAAI,EAAE;gBACrC,MAAM,UAAoB,SAAS,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAA,IAAK,CAAC;wBACxD,KAAK,EAAE,GAAG;wBACV,SAAS,EAAE,OAAO;wBAClB,UAAU,EAAE,QAAQ;wBACpB,UAAU,EAAE,QAAQ;wBACpB,QAAQ,EAAE,MAAM;wBAChB,SAAS,EAAE,OAAO;wBAClB,MAAM,EAAE,SAAS;wBACjB,aAAa,EAAE,WAAW;wBAC1B,cAAc,EAAE,YAAY;wBAC5B,eAAe,EAAE,aAAa;wBAC9B,gBAAgB,EAAE,cAAc;oBAClC,CAAC;gBAED,eAAe;gBACf,iBAAiB,CAAA,OAAQ,CAAC;wBACxB,GAAG,IAAI;wBACP,CAAC,eAAe,EAAE;oBACpB,CAAC;gBAED,kBAAkB;gBAClB,IAAI,SAAS,IAAI,CAAC,KAAK,EAAE;oBACvB,eAAe,CAAA,OAAQ,CAAC;4BACtB,GAAG,IAAI;4BACP,CAAC,eAAe,EAAE,SAAS,IAAI,CAAE,KAAK;wBACxC,CAAC;gBACH;gBAEA,OAAO;YACT,OAAO;gBACL,SAAS,SAAS,KAAK,EAAE,WAAW;gBACpC,OAAO,EAAE;YACX;QACF,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,2BAA2B;YACzC,SAAS;YACT,OAAO,EAAE;QACX,SAAU;YACR,aAAa;QACf;IACF,GAAG;QAAC;KAAc;IAElB,MAAM,YAAY,CAAA,GAAA,qMAAA,CAAA,cAAW,AAAD,EAAE,OAC5B,gBACA,SACA;QAEA,IAAI;YACF,aAAa;YACb,SAAS;YAET,IAAI,CAAC,MAAM,UAAU;gBACnB,SAAS;gBACT,OAAO;YACT;YAEA,uBAAuB;YACvB,MAAM,aAAa,aAAa,SAAS,CAAC;gBACxC,QAAQ,OAAO,MAAM;gBACrB,SAAS,OAAO,OAAO;YACzB;YAEA,IAAI,CAAC,WAAW,OAAO,EAAE;gBACvB,SAAS,WAAW,KAAK,CAAC,MAAM,CAAC,EAAE,EAAE,WAAW;gBAChD,OAAO;YACT;YAEA,wBAAwB;YACxB,MAAM,WAAW,MAAM,qIAAA,CAAA,iBAAc,CAAC,YAAY,CAAC;gBACjD;gBACA,QAAQ,WAAW,IAAI,CAAC,MAAM;gBAC9B,SAAS,CAAA,GAAA,wIAAA,CAAA,iBAAc,AAAD,EAAE,WAAW,IAAI,CAAC,OAAO;gBAC/C,aAAa,OAAO,WAAW,KAAK;gBACpC,cAAc,OAAO,YAAY,KAAK;gBACtC,eAAe,OAAO,aAAa,KAAK;YAC1C;YAEA,IAAI,SAAS,OAAO,EAAE;gBACpB,+CAA+C;gBAC/C,iBAAiB,CAAA;oBACf,MAAM,UAAU;wBAAE,GAAG,IAAI;oBAAC;oBAC1B,OAAO,OAAO,CAAC,eAAe;oBAC9B,OAAO;gBACT;gBACA,eAAe,CAAA;oBACb,MAAM,UAAU;wBAAE,GAAG,IAAI;oBAAC;oBAC1B,OAAO,OAAO,CAAC,eAAe;oBAC9B,OAAO;gBACT;gBAEA,OAAO;YACT,OAAO;gBACL,SAAS,SAAS,KAAK,EAAE,WAAW;gBACpC,OAAO;YACT;QACF,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,wBAAwB;YACtC,SAAS;YACT,OAAO;QACT,SAAU;YACR,aAAa;QACf;IACF,GAAG;QAAC,MAAM;KAAS;IAEnB,MAAM,cAAc,CAAA,GAAA,qMAAA,CAAA,cAAW,AAAD,EAAE,OAAO;QACrC,IAAI;YACF,aAAa;YACb,SAAS;YAET,MAAM,WAAW,MAAM,qIAAA,CAAA,iBAAc,CAAC,gBAAgB,CAAC;YAEvD,IAAI,SAAS,OAAO,IAAI,SAAS,IAAI,EAAE;gBACrC,OAAO,SAAS,IAAI,CAAC,SAAS;YAChC;YAEA,OAAO;QACT,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,iCAAiC;YAC/C,OAAO;QACT,SAAU;YACR,aAAa;QACf;IACF,GAAG,EAAE;IAEL,MAAM,iBAAiB,CAAA,GAAA,qMAAA,CAAA,cAAW,AAAD,EAAE,OAAO;QACxC,IAAI;YACF,oBAAoB;YACpB,IAAI,WAAW,CAAC,eAAe,EAAE;gBAC/B,OAAO,WAAW,CAAC,eAAe;YACpC;YAEA,6DAA6D;YAC7D,MAAM,oBAAoB;YAE1B,OAAO,WAAW,CAAC,eAAe,IAAI;QACxC,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,+BAA+B;YAC7C,OAAO;QACT;IACF,GAAG;QAAC;QAAa;KAAoB;IAErC,qBACE,8OAAC,cAAc,QAAQ;QAAC,OAAO;YAC7B;YACA;YACA;YACA;YACA;YACA;QACF;kBACG;;;;;;AAGP;AAEO,MAAM,aAAa;IACxB,MAAM,UAAU,CAAA,GAAA,qMAAA,CAAA,aAAU,AAAD,EAAE;IAC3B,IAAI,CAAC,SAAS,MAAM,IAAI,MAAM;IAC9B,OAAO;AACT","debugId":null}},
    {"offset": {"line": 6512, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/gerom/OneDrive/Documents/pantypost/src/context/RequestContext.tsx"],"sourcesContent":["// src/context/RequestContext.tsx\r\n\"use client\";\r\n\r\nimport React, { createContext, useContext, useState, useEffect } from \"react\";\r\nimport { storageService } from '@/services';\r\nimport { sanitizeStrict } from '@/utils/security/sanitization';\r\nimport { messageSchemas } from '@/utils/validation/schemas';\r\nimport { z } from 'zod';\r\n\r\nexport type RequestStatus = 'pending' | 'accepted' | 'rejected' | 'edited' | 'paid';\r\n\r\nexport type CustomRequest = {\r\n  id: string;\r\n  buyer: string;\r\n  seller: string;\r\n  title: string;\r\n  description: string;\r\n  price: number;\r\n  tags: string[];\r\n  status: RequestStatus;\r\n  date: string;\r\n  response?: string;\r\n  paid?: boolean;\r\n  // Add these fields to track the message-based flow\r\n  messageThreadId?: string; // Links to the conversation\r\n  lastModifiedBy?: string; // Who made the last edit\r\n  originalMessageId?: string; // Reference to original message\r\n  lastEditedBy?: string; // NEW: Track who last edited (buyer or seller)\r\n  pendingWith?: string; // NEW: Track who needs to respond (buyer or seller)\r\n};\r\n\r\n// Validation schemas\r\nconst requestSchema = z.object({\r\n  title: messageSchemas.customRequest.shape.title,\r\n  description: messageSchemas.customRequest.shape.description,\r\n  price: messageSchemas.customRequest.shape.price,\r\n  tags: z.array(z.string().max(30)).max(10).optional(),\r\n});\r\n\r\nconst responseSchema = z.string().min(1).max(500);\r\n\r\ntype RequestContextType = {\r\n  requests: CustomRequest[];\r\n  setRequests: React.Dispatch<React.SetStateAction<CustomRequest[]>>;\r\n  addRequest: (req: CustomRequest) => void;\r\n  getRequestsForUser: (username: string, role: 'buyer' | 'seller') => CustomRequest[];\r\n  getRequestById: (id: string) => CustomRequest | undefined;\r\n  respondToRequest: (\r\n    id: string,\r\n    status: RequestStatus,\r\n    response?: string,\r\n    updateFields?: Partial<Pick<CustomRequest, 'title' | 'price' | 'tags' | 'description'>>,\r\n    modifiedBy?: string\r\n  ) => void;\r\n  markRequestAsPaid: (id: string) => void;\r\n  // Helper functions for message-based workflow\r\n  getActiveRequestsForThread: (buyer: string, seller: string) => CustomRequest[];\r\n  getLatestRequestInThread: (buyer: string, seller: string) => CustomRequest | undefined;\r\n};\r\n\r\nconst RequestContext = createContext<RequestContextType | undefined>(undefined);\r\n\r\nexport const useRequests = () => {\r\n  const ctx = useContext(RequestContext);\r\n  if (!ctx) throw new Error('useRequests must be used within a RequestProvider');\r\n  return ctx;\r\n};\r\n\r\nexport const RequestProvider = ({ children }: { children: React.ReactNode }) => {\r\n  const [requests, setRequests] = useState<CustomRequest[]>([]);\r\n  const [isInitialized, setIsInitialized] = useState(false);\r\n\r\n  // Load initial data from localStorage using service\r\n  useEffect(() => {\r\n    const loadData = async () => {\r\n      if (typeof window === 'undefined' || isInitialized) return;\r\n      \r\n      try {\r\n        const stored = await storageService.getItem<CustomRequest[]>('panty_custom_requests', []);\r\n        \r\n        // Migrate and sanitize old requests\r\n        const migratedRequests = stored.map((req: any) => ({\r\n          ...req,\r\n          title: sanitizeStrict(req.title || ''),\r\n          description: sanitizeStrict(req.description || ''),\r\n          response: req.response ? sanitizeStrict(req.response) : undefined,\r\n          tags: Array.isArray(req.tags) ? req.tags.map((tag: string) => sanitizeStrict(tag).slice(0, 30)) : [],\r\n          messageThreadId: req.messageThreadId || `${req.buyer}-${req.seller}`,\r\n          lastModifiedBy: req.lastModifiedBy || req.buyer,\r\n          originalMessageId: req.originalMessageId || req.id,\r\n          lastEditedBy: req.lastEditedBy || req.buyer,\r\n          pendingWith: req.pendingWith || req.seller\r\n        }));\r\n        \r\n        setRequests(migratedRequests);\r\n        setIsInitialized(true);\r\n      } catch (error) {\r\n        console.error('Error loading requests from localStorage:', error);\r\n        setIsInitialized(true);\r\n      }\r\n    };\r\n\r\n    loadData();\r\n  }, [isInitialized]);\r\n\r\n  // Save to localStorage whenever requests change using service\r\n  useEffect(() => {\r\n    if (typeof window !== 'undefined' && isInitialized) {\r\n      storageService.setItem('panty_custom_requests', requests);\r\n    }\r\n  }, [requests, isInitialized]);\r\n\r\n  const addRequest = (req: CustomRequest) => {\r\n    // Validate request data\r\n    const validation = requestSchema.safeParse({\r\n      title: req.title,\r\n      description: req.description,\r\n      price: req.price,\r\n      tags: req.tags,\r\n    });\r\n\r\n    if (!validation.success) {\r\n      console.error('Invalid request data:', validation.error);\r\n      return;\r\n    }\r\n\r\n    const requestWithDefaults = {\r\n      ...req,\r\n      title: sanitizeStrict(validation.data.title),\r\n      description: sanitizeStrict(validation.data.description),\r\n      price: validation.data.price,\r\n      tags: validation.data.tags?.map(tag => sanitizeStrict(tag).slice(0, 30)) || [],\r\n      messageThreadId: req.messageThreadId || `${req.buyer}-${req.seller}`,\r\n      lastModifiedBy: req.lastModifiedBy || req.buyer,\r\n      originalMessageId: req.originalMessageId || req.id,\r\n      lastEditedBy: req.buyer,\r\n      pendingWith: req.seller\r\n    };\r\n    setRequests((prev) => [...prev, requestWithDefaults]);\r\n  };\r\n\r\n  const getRequestsForUser = (username: string, role: 'buyer' | 'seller') => {\r\n    return requests.filter((r) => r[role] === username);\r\n  };\r\n\r\n  const getRequestById = (id: string) => {\r\n    return requests.find((r) => r.id === id);\r\n  };\r\n\r\n  // Enhanced respond function that tracks who made the last modification\r\n  const respondToRequest = (\r\n    id: string,\r\n    status: RequestStatus,\r\n    response?: string,\r\n    updateFields?: Partial<Pick<CustomRequest, 'title' | 'price' | 'tags' | 'description'>>,\r\n    modifiedBy?: string\r\n  ) => {\r\n    // Validate response if provided\r\n    if (response) {\r\n      const responseValidation = responseSchema.safeParse(response);\r\n      if (!responseValidation.success) {\r\n        console.error('Invalid response:', responseValidation.error);\r\n        return;\r\n      }\r\n    }\r\n\r\n    // Validate update fields if provided\r\n    if (updateFields) {\r\n      const updateValidation = requestSchema.partial().safeParse(updateFields);\r\n      if (!updateValidation.success) {\r\n        console.error('Invalid update fields:', updateValidation.error);\r\n        return;\r\n      }\r\n    }\r\n\r\n    setRequests((prev) =>\r\n      prev.map((r) => {\r\n        if (r.id !== id) return r;\r\n        \r\n        // Determine who it's pending with based on who modified it\r\n        let pendingWith = r.pendingWith;\r\n        let lastEditedBy = r.lastEditedBy;\r\n        \r\n        if (status === 'edited' && modifiedBy) {\r\n          // If edited, it's pending with the other party\r\n          pendingWith = modifiedBy === r.buyer ? r.seller : r.buyer;\r\n          lastEditedBy = modifiedBy;\r\n        } else if (status === 'accepted' || status === 'rejected') {\r\n          // No longer pending with anyone\r\n          pendingWith = undefined;\r\n        }\r\n        \r\n        return {\r\n          ...r,\r\n          status,\r\n          response: response ? sanitizeStrict(response) : r.response,\r\n          lastModifiedBy: modifiedBy || r.lastModifiedBy,\r\n          lastEditedBy: status === 'edited' ? lastEditedBy : r.lastEditedBy,\r\n          pendingWith,\r\n          ...(updateFields ? {\r\n            title: updateFields.title ? sanitizeStrict(updateFields.title) : r.title,\r\n            description: updateFields.description ? sanitizeStrict(updateFields.description) : r.description,\r\n            price: updateFields.price ?? r.price,\r\n            tags: updateFields.tags?.map(tag => sanitizeStrict(tag).slice(0, 30)) || r.tags,\r\n          } : {}),\r\n        };\r\n      })\r\n    );\r\n  };\r\n\r\n  // Mark request as paid (when payment is processed)\r\n  const markRequestAsPaid = (id: string) => {\r\n    setRequests((prev) =>\r\n      prev.map((r) =>\r\n        r.id === id\r\n          ? {\r\n              ...r,\r\n              status: 'paid' as RequestStatus,\r\n              paid: true,\r\n              pendingWith: undefined\r\n            }\r\n          : r\r\n      )\r\n    );\r\n  };\r\n\r\n  // Get all active requests between two users\r\n  const getActiveRequestsForThread = (buyer: string, seller: string) => {\r\n    return requests.filter((r) => \r\n      r.buyer === buyer && \r\n      r.seller === seller && \r\n      r.status !== 'rejected' && \r\n      r.status !== 'paid'\r\n    );\r\n  };\r\n\r\n  // Get the most recent request in a conversation thread\r\n  const getLatestRequestInThread = (buyer: string, seller: string) => {\r\n    const threadRequests = requests\r\n      .filter((r) => r.buyer === buyer && r.seller === seller)\r\n      .sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());\r\n    \r\n    return threadRequests[0];\r\n  };\r\n\r\n  return (\r\n    <RequestContext.Provider\r\n      value={{\r\n        requests,\r\n        setRequests,\r\n        addRequest,\r\n        getRequestsForUser,\r\n        getRequestById,\r\n        respondToRequest,\r\n        markRequestAsPaid,\r\n        getActiveRequestsForThread,\r\n        getLatestRequestInThread,\r\n      }}\r\n    >\r\n      {children}\r\n    </RequestContext.Provider>\r\n  );\r\n};\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 6689, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/gerom/OneDrive/Documents/pantypost/src/context/LoadingContext.tsx"],"sourcesContent":["// src/context/LoadingContext.tsx\r\n'use client';\r\n\r\nimport React, { createContext, useContext, useState, useCallback, useRef } from 'react';\r\nimport { Loader2 } from 'lucide-react';\r\n\r\ninterface LoadingState {\r\n  isLoading: boolean;\r\n  message?: string;\r\n  progress?: number;\r\n}\r\n\r\ninterface LoadingContextType {\r\n  // Global loading state\r\n  globalLoading: LoadingState;\r\n  setGlobalLoading: (loading: boolean, message?: string, progress?: number) => void;\r\n  \r\n  // Named loading states (for specific features)\r\n  loadingStates: Map<string, LoadingState>;\r\n  setLoading: (key: string, loading: boolean, message?: string, progress?: number) => void;\r\n  isLoading: (key: string) => boolean;\r\n  \r\n  // Utilities\r\n  withLoading: <T>(\r\n    key: string,\r\n    fn: () => Promise<T>,\r\n    message?: string\r\n  ) => Promise<T>;\r\n  clearAllLoading: () => void;\r\n}\r\n\r\nconst LoadingContext = createContext<LoadingContextType | undefined>(undefined);\r\n\r\nexport function LoadingProvider({ children }: { children: React.ReactNode }) {\r\n  const [globalLoading, setGlobalLoadingState] = useState<LoadingState>({\r\n    isLoading: false,\r\n  });\r\n  \r\n  const [loadingStates] = useState<Map<string, LoadingState>>(new Map());\r\n  const [, forceUpdate] = useState({});\r\n  const loadingCountRef = useRef<Map<string, number>>(new Map());\r\n\r\n  // Set global loading\r\n  const setGlobalLoading = useCallback((\r\n    isLoading: boolean,\r\n    message?: string,\r\n    progress?: number\r\n  ) => {\r\n    setGlobalLoadingState({ isLoading, message, progress });\r\n  }, []);\r\n\r\n  // Set named loading state\r\n  const setLoading = useCallback((\r\n    key: string,\r\n    isLoading: boolean,\r\n    message?: string,\r\n    progress?: number\r\n  ) => {\r\n    if (isLoading) {\r\n      // Increment loading count for this key\r\n      const currentCount = loadingCountRef.current.get(key) || 0;\r\n      loadingCountRef.current.set(key, currentCount + 1);\r\n      \r\n      loadingStates.set(key, { isLoading: true, message, progress });\r\n    } else {\r\n      // Decrement loading count\r\n      const currentCount = loadingCountRef.current.get(key) || 0;\r\n      const newCount = Math.max(0, currentCount - 1);\r\n      \r\n      if (newCount === 0) {\r\n        loadingStates.delete(key);\r\n        loadingCountRef.current.delete(key);\r\n      } else {\r\n        loadingCountRef.current.set(key, newCount);\r\n      }\r\n    }\r\n    \r\n    forceUpdate({});\r\n  }, [loadingStates]);\r\n\r\n  // Check if specific key is loading\r\n  const isLoading = useCallback((key: string): boolean => {\r\n    return loadingStates.has(key);\r\n  }, [loadingStates]);\r\n\r\n  // Execute function with loading state\r\n  const withLoading = useCallback(async <T,>(\r\n    key: string,\r\n    fn: () => Promise<T>,\r\n    message?: string\r\n  ): Promise<T> => {\r\n    setLoading(key, true, message);\r\n    try {\r\n      return await fn();\r\n    } finally {\r\n      setLoading(key, false);\r\n    }\r\n  }, [setLoading]);\r\n\r\n  // Clear all loading states\r\n  const clearAllLoading = useCallback(() => {\r\n    loadingStates.clear();\r\n    loadingCountRef.current.clear();\r\n    setGlobalLoadingState({ isLoading: false });\r\n    forceUpdate({});\r\n  }, [loadingStates]);\r\n\r\n  const value: LoadingContextType = {\r\n    globalLoading,\r\n    setGlobalLoading,\r\n    loadingStates,\r\n    setLoading,\r\n    isLoading,\r\n    withLoading,\r\n    clearAllLoading,\r\n  };\r\n\r\n  return (\r\n    <LoadingContext.Provider value={value}>\r\n      {children}\r\n      {globalLoading.isLoading && <GlobalLoadingOverlay {...globalLoading} />}\r\n    </LoadingContext.Provider>\r\n  );\r\n}\r\n\r\n// Global Loading Overlay Component\r\nfunction GlobalLoadingOverlay({ message, progress }: LoadingState) {\r\n  return (\r\n    <div className=\"fixed inset-0 z-[60] flex items-center justify-center bg-black/50 backdrop-blur-sm\">\r\n      <div className=\"bg-[#1a1a1a] border border-gray-800 rounded-lg p-6 shadow-xl\">\r\n        <div className=\"flex flex-col items-center gap-4\">\r\n          <Loader2 className=\"w-10 h-10 text-[#ff950e] animate-spin\" />\r\n          \r\n          {message && (\r\n            <p className=\"text-white text-sm font-medium\">{message}</p>\r\n          )}\r\n          \r\n          {progress !== undefined && (\r\n            <div className=\"w-48\">\r\n              <div className=\"bg-gray-800 rounded-full h-2 overflow-hidden\">\r\n                <div\r\n                  className=\"bg-[#ff950e] h-full transition-all duration-300\"\r\n                  style={{ width: `${Math.min(100, Math.max(0, progress))}%` }}\r\n                />\r\n              </div>\r\n              <p className=\"text-gray-400 text-xs mt-1 text-center\">\r\n                {Math.round(progress)}%\r\n              </p>\r\n            </div>\r\n          )}\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\n// Hook to use loading\r\nexport function useLoading() {\r\n  const context = useContext(LoadingContext);\r\n  if (!context) {\r\n    throw new Error('useLoading must be used within a LoadingProvider');\r\n  }\r\n  return context;\r\n}\r\n\r\n// Loading Spinner Component\r\nexport function LoadingSpinner({ \r\n  size = 'md',\r\n  className = '' \r\n}: { \r\n  size?: 'sm' | 'md' | 'lg';\r\n  className?: string;\r\n}) {\r\n  const sizeClasses = {\r\n    sm: 'w-4 h-4',\r\n    md: 'w-6 h-6',\r\n    lg: 'w-8 h-8',\r\n  };\r\n\r\n  return (\r\n    <Loader2 className={`animate-spin text-[#ff950e] ${sizeClasses[size]} ${className}`} />\r\n  );\r\n}\r\n\r\n// Loading Button Component\r\nexport function LoadingButton({\r\n  isLoading,\r\n  children,\r\n  loadingText,\r\n  className = '',\r\n  ...props\r\n}: React.ButtonHTMLAttributes<HTMLButtonElement> & {\r\n  isLoading: boolean;\r\n  loadingText?: string;\r\n}) {\r\n  return (\r\n    <button\r\n      disabled={isLoading}\r\n      className={`relative ${className}`}\r\n      {...props}\r\n    >\r\n      {isLoading ? (\r\n        <span className=\"flex items-center justify-center gap-2\">\r\n          <LoadingSpinner size=\"sm\" />\r\n          {loadingText || 'Loading...'}\r\n        </span>\r\n      ) : (\r\n        children\r\n      )}\r\n    </button>\r\n  );\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 6931, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/gerom/OneDrive/Documents/pantypost/src/context/FavoritesContext.tsx"],"sourcesContent":["'use client';\r\n\r\nimport React, {\r\n  createContext,\r\n  useContext,\r\n  useState,\r\n  useEffect,\r\n  ReactNode,\r\n  useCallback,\r\n  useMemo,\r\n} from 'react';\r\nimport { useAuth } from './AuthContext';\r\nimport { storageService } from '@/services';\r\nimport { favoritesService } from '@/services/favorites.service';\r\nimport { sanitizeUsername, sanitizeStrict } from '@/utils/security/sanitization';\r\nimport { getRateLimiter } from '@/utils/security/rate-limiter';\r\nimport { FEATURES } from '@/services/api.config';\r\nimport { z } from 'zod';\r\n\r\n// ================= Types =================\r\n\r\nexport interface FavoriteSeller {\r\n  sellerId: string;\r\n  sellerUsername: string;\r\n  addedAt: string;\r\n  profilePicture?: string;\r\n  tier?: string;\r\n  isVerified: boolean;\r\n}\r\n\r\ninterface FavoritesContextType {\r\n  favorites: FavoriteSeller[];\r\n  favoriteCount: number;\r\n  isFavorited: (sellerId: string) => boolean;\r\n  toggleFavorite: (seller: {\r\n    id: string;\r\n    username: string;\r\n    profilePicture?: string;\r\n    tier?: string;\r\n    isVerified: boolean;\r\n  }) => Promise<boolean>;\r\n  loadingFavorites: boolean;\r\n  error: string | null;\r\n  clearError: () => void;\r\n  refreshFavorites: () => Promise<void>;\r\n}\r\n\r\nconst FavoritesContext = createContext<FavoritesContextType | undefined>(undefined);\r\n\r\n// ================ Validation Schemas ================\r\n\r\n// Very defensive; we only ensure minimal fields + types are correct.\r\n// URL validation for profilePicture is intentionally relaxed to avoid breaking existing data.\r\nconst StoredFavoriteSchema = z.object({\r\n  sellerId: z.string().min(1),\r\n  sellerUsername: z.string().min(1),\r\n  addedAt: z.string().min(1),\r\n  profilePicture: z.string().optional(),\r\n  tier: z.string().optional(),\r\n  isVerified: z.boolean().default(false),\r\n});\r\n\r\nconst SellerInputSchema = z.object({\r\n  id: z.string().min(1),\r\n  username: z.string().min(1),\r\n  profilePicture: z.string().optional(),\r\n  tier: z.string().optional(),\r\n  isVerified: z.boolean(),\r\n});\r\n\r\n// ================ Limits / Helpers ================\r\n\r\nconst FAV_LIMIT = {\r\n  maxAttempts: 30,\r\n  windowMs: 60_000, // 30 toggles per minute\r\n  blockDuration: 60_000, // optional cool-down\r\n};\r\n\r\nfunction dedupeBySellerId(list: FavoriteSeller[]): FavoriteSeller[] {\r\n  const seen = new Set<string>();\r\n  const out: FavoriteSeller[] = [];\r\n  for (const f of list) {\r\n    if (!seen.has(f.sellerId)) {\r\n      seen.add(f.sellerId);\r\n      out.push(f);\r\n    }\r\n  }\r\n  return out;\r\n}\r\n\r\n/**\r\n * Rate-limit wrapper that works whether limiter.check()\r\n * throws on limit OR returns { allowed, waitTime }.\r\n */\r\nfunction checkRateLimitSafe(\r\n  limiter: any,\r\n  key: string,\r\n  opts: { maxAttempts: number; windowMs: number; blockDuration?: number }\r\n): { allowed: boolean; waitTime?: number } {\r\n  try {\r\n    const res = limiter?.check?.(key, opts);\r\n    // If it returns an object\r\n    if (typeof res === 'object' && res !== null) {\r\n      if (res.allowed === false) {\r\n        // waitTime may be provided in seconds or ms; normalize to seconds\r\n        const waitSeconds =\r\n          typeof res.waitTime === 'number'\r\n            ? Math.max(1, Math.ceil(res.waitTime))\r\n            : undefined;\r\n        return { allowed: false, waitTime: waitSeconds };\r\n      }\r\n      return { allowed: true };\r\n    }\r\n    // If no return (assume not limited)\r\n    return { allowed: true };\r\n  } catch (e: any) {\r\n    // If it throws on limit, try to extract wait time\r\n    const ms =\r\n      e?.waitTimeMs ??\r\n      e?.retryAfterMs ??\r\n      (typeof e?.waitTime === 'number' && e.waitTime > 10 ? e.waitTime * 1000 : undefined);\r\n    const seconds = ms ? Math.max(1, Math.ceil(ms / 1000)) : undefined;\r\n    return { allowed: false, waitTime: seconds };\r\n  }\r\n}\r\n\r\nexport function FavoritesProvider({ children }: { children: ReactNode }) {\r\n  const { user } = useAuth();\r\n  const [favorites, setFavorites] = useState<FavoriteSeller[]>([]);\r\n  const [loadingFavorites, setLoadingFavorites] = useState(false);\r\n  const [error, setError] = useState<string | null>(null);\r\n\r\n  // Create limiter once; safe even under React strict mode\r\n  const rateLimiter = useMemo(() => getRateLimiter(), []);\r\n\r\n  // Storage key based on username (sanitized)\r\n  const getStorageKey = useCallback((username: string) => {\r\n    return `favorites_${sanitizeUsername(username)}`;\r\n  }, []);\r\n\r\n  // ------------- Load favorites (API or local) -------------\r\n  const loadFavorites = useCallback(async () => {\r\n    if (!user?.username) {\r\n      setFavorites([]);\r\n      return;\r\n    }\r\n\r\n    setLoadingFavorites(true);\r\n    try {\r\n      if (FEATURES.USE_API_USERS) {\r\n        // Load from API\r\n        const response = await favoritesService.getFavorites(user.username);\r\n\r\n        if (response.success && response.data) {\r\n          // Validate + sanitize response\r\n          const cleaned = (Array.isArray(response.data) ? response.data : [])\r\n            .map((f) => {\r\n              const parsed = StoredFavoriteSchema.safeParse(f);\r\n              if (!parsed.success) return null;\r\n              const v = parsed.data;\r\n              return {\r\n                sellerId: sanitizeStrict(v.sellerId),\r\n                sellerUsername: sanitizeUsername(v.sellerUsername),\r\n                addedAt: sanitizeStrict(v.addedAt),\r\n                profilePicture: v.profilePicture,\r\n                tier: v.tier,\r\n                isVerified: !!v.isVerified,\r\n              } as FavoriteSeller;\r\n            })\r\n            .filter(Boolean) as FavoriteSeller[];\r\n\r\n          const deduped = dedupeBySellerId(cleaned);\r\n          setFavorites(deduped);\r\n\r\n          // Cache for offline\r\n          const storageKey = getStorageKey(user.username);\r\n          await storageService.setItem(storageKey, deduped);\r\n        } else {\r\n          // API error → fallback to local\r\n          setError(response.error?.message || 'Failed to load favorites from server');\r\n          const storageKey = getStorageKey(user.username);\r\n          const stored = await storageService.getItem<FavoriteSeller[]>(storageKey, []);\r\n          const validated = (Array.isArray(stored) ? stored : [])\r\n            .map((f) => {\r\n              const parsed = StoredFavoriteSchema.safeParse(f);\r\n              if (!parsed.success) return null;\r\n              const v = parsed.data;\r\n              return {\r\n                sellerId: sanitizeStrict(v.sellerId),\r\n                sellerUsername: sanitizeUsername(v.sellerUsername),\r\n                addedAt: sanitizeStrict(v.addedAt),\r\n                profilePicture: v.profilePicture,\r\n                tier: v.tier,\r\n                isVerified: !!v.isVerified,\r\n              } as FavoriteSeller;\r\n            })\r\n            .filter(Boolean) as FavoriteSeller[];\r\n          setFavorites(dedupeBySellerId(validated));\r\n        }\r\n      } else {\r\n        // LocalStorage only\r\n        const storageKey = getStorageKey(user.username);\r\n        const stored = await storageService.getItem<FavoriteSeller[]>(storageKey, []);\r\n        const validated = (Array.isArray(stored) ? stored : [])\r\n          .map((f) => {\r\n            const parsed = StoredFavoriteSchema.safeParse(f);\r\n            if (!parsed.success) return null;\r\n            const v = parsed.data;\r\n            return {\r\n              sellerId: sanitizeStrict(v.sellerId),\r\n              sellerUsername: sanitizeUsername(v.sellerUsername),\r\n              addedAt: sanitizeStrict(v.addedAt),\r\n              profilePicture: v.profilePicture,\r\n              tier: v.tier,\r\n              isVerified: !!v.isVerified,\r\n            } as FavoriteSeller;\r\n          })\r\n          .filter(Boolean) as FavoriteSeller[];\r\n        setFavorites(dedupeBySellerId(validated));\r\n      }\r\n    } catch (err) {\r\n      console.error('Error loading favorites:', err);\r\n      setError('Failed to load favorites');\r\n      setFavorites([]);\r\n    } finally {\r\n      setLoadingFavorites(false);\r\n    }\r\n  }, [user?.username, getStorageKey]);\r\n\r\n  // Load favorites when user changes\r\n  useEffect(() => {\r\n    loadFavorites();\r\n  }, [loadFavorites]);\r\n\r\n  // ------------- Helpers -------------\r\n  const isFavorited = useCallback(\r\n    (sellerId: string): boolean => favorites.some((fav) => fav.sellerId === sellerId),\r\n    [favorites]\r\n  );\r\n\r\n  // ------------- Toggle favorite -------------\r\n  const toggleFavorite = useCallback(\r\n    async (seller: {\r\n      id: string;\r\n      username: string;\r\n      profilePicture?: string;\r\n      tier?: string;\r\n      isVerified: boolean;\r\n    }): Promise<boolean> => {\r\n      if (!user?.username) {\r\n        setError('Please log in to add favorites');\r\n        return false;\r\n      }\r\n\r\n      // Validate & sanitize seller input\r\n      const parsed = SellerInputSchema.safeParse(seller);\r\n      if (!parsed.success) {\r\n        setError('Invalid seller data');\r\n        return false;\r\n      }\r\n      const cleanSeller = {\r\n        id: sanitizeStrict(parsed.data.id),\r\n        username: sanitizeUsername(parsed.data.username),\r\n        profilePicture: parsed.data.profilePicture,\r\n        tier: parsed.data.tier,\r\n        isVerified: !!parsed.data.isVerified,\r\n      };\r\n\r\n      // Rate limiting (per-user key)\r\n      const rlKey = `favorites:toggle:${sanitizeUsername(user.username)}`;\r\n      const rl = checkRateLimitSafe(rateLimiter, rlKey, FAV_LIMIT);\r\n      if (!rl.allowed) {\r\n        const secs = rl.waitTime ?? Math.ceil(FAV_LIMIT.blockDuration / 1000);\r\n        setError(`Too many actions. Please wait ${secs} seconds.`);\r\n        return false;\r\n      }\r\n\r\n      try {\r\n        const storageKey = getStorageKey(user.username);\r\n        const current = [...favorites];\r\n        const existingIndex = current.findIndex((f) => f.sellerId === cleanSeller.id);\r\n\r\n        if (FEATURES.USE_API_USERS) {\r\n          if (existingIndex >= 0) {\r\n            // Remove via API\r\n            const response = await favoritesService.removeFavorite(cleanSeller.id);\r\n            if (response.success) {\r\n              const next = current.filter((f) => f.sellerId !== cleanSeller.id);\r\n              setFavorites(next);\r\n              await storageService.setItem(storageKey, next);\r\n              setError(null);\r\n              return true;\r\n            } else {\r\n              setError(response.error?.message || 'Failed to remove favorite');\r\n              return false;\r\n            }\r\n          } else {\r\n            // Add via API\r\n            const response = await favoritesService.addFavorite({\r\n              sellerId: cleanSeller.id,\r\n              sellerUsername: cleanSeller.username,\r\n              profilePicture: cleanSeller.profilePicture,\r\n              tier: cleanSeller.tier,\r\n              isVerified: cleanSeller.isVerified,\r\n            });\r\n\r\n            if (response.success && response.data) {\r\n              // Validate API response item before storing\r\n              const parsedItem = StoredFavoriteSchema.safeParse(response.data);\r\n              if (!parsedItem.success) {\r\n                setError('Invalid server response for favorite item');\r\n                return false;\r\n              }\r\n              const v = parsedItem.data;\r\n              const newFav: FavoriteSeller = {\r\n                sellerId: sanitizeStrict(v.sellerId),\r\n                sellerUsername: sanitizeUsername(v.sellerUsername),\r\n                addedAt: sanitizeStrict(v.addedAt || new Date().toISOString()),\r\n                profilePicture: v.profilePicture,\r\n                tier: v.tier,\r\n                isVerified: !!v.isVerified,\r\n              };\r\n              const next = dedupeBySellerId([...current, newFav]);\r\n              setFavorites(next);\r\n              await storageService.setItem(storageKey, next);\r\n              setError(null);\r\n              return true;\r\n            } else {\r\n              setError(response.error?.message || 'Failed to add favorite');\r\n              return false;\r\n            }\r\n          }\r\n        } else {\r\n          // Local only\r\n          let next: FavoriteSeller[];\r\n          if (existingIndex >= 0) {\r\n            // Remove locally\r\n            next = current.filter((f) => f.sellerId !== cleanSeller.id);\r\n          } else {\r\n            // Add locally\r\n            const newFav: FavoriteSeller = {\r\n              sellerId: cleanSeller.id,\r\n              sellerUsername: cleanSeller.username,\r\n              addedAt: new Date().toISOString(),\r\n              profilePicture: cleanSeller.profilePicture,\r\n              tier: cleanSeller.tier,\r\n              isVerified: cleanSeller.isVerified,\r\n            };\r\n            next = dedupeBySellerId([...current, newFav]);\r\n          }\r\n\r\n          const saved = await storageService.setItem(storageKey, next as any);\r\n          // Some storage services return void; treat undefined as success.\r\n          if (saved === false) {\r\n            setError('Failed to update favorites');\r\n            return false;\r\n          }\r\n          setFavorites(next);\r\n          setError(null);\r\n          return true;\r\n        }\r\n      } catch (err) {\r\n        console.error('Error toggling favorite:', err);\r\n        setError('Failed to update favorites');\r\n        return false;\r\n      }\r\n    },\r\n    [user?.username, favorites, getStorageKey, rateLimiter]\r\n  );\r\n\r\n  const clearError = useCallback(() => setError(null), []);\r\n\r\n  const refreshFavorites = useCallback(async () => {\r\n    await loadFavorites();\r\n  }, [loadFavorites]);\r\n\r\n  const contextValue: FavoritesContextType = {\r\n    favorites,\r\n    favoriteCount: favorites.length,\r\n    isFavorited,\r\n    toggleFavorite,\r\n    loadingFavorites,\r\n    error,\r\n    clearError,\r\n    refreshFavorites,\r\n  };\r\n\r\n  return <FavoritesContext.Provider value={contextValue}>{children}</FavoritesContext.Provider>;\r\n}\r\n\r\nexport function useFavorites() {\r\n  const context = useContext(FavoritesContext);\r\n  if (context === undefined) {\r\n    throw new Error('useFavorites must be used within a FavoritesProvider');\r\n  }\r\n  return context;\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 7291, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/gerom/OneDrive/Documents/pantypost/src/context/NotificationContext.tsx"],"sourcesContent":["'use client';\r\n\r\nimport React, { createContext, useContext, useState, useEffect, useCallback, useRef } from 'react';\r\nimport { useAuth } from './AuthContext';\r\nimport { useWebSocket } from './WebSocketContext';\r\nimport { notificationService } from '@/services/notification.service';\r\nimport type { Notification } from '@/types/notification';\r\nimport { WebSocketEvent } from '@/types/websocket';\r\n\r\ninterface NotificationContextType {\r\n  activeNotifications: Notification[];\r\n  clearedNotifications: Notification[];\r\n  unreadCount: number;\r\n  totalCount: number;\r\n  clearNotification: (notificationId: string) => Promise<void>;\r\n  clearAllNotifications: () => Promise<void>;\r\n  restoreNotification: (notificationId: string) => Promise<void>;\r\n  deleteNotification: (notificationId: string) => Promise<void>;\r\n  deleteAllCleared: () => Promise<void>;\r\n  markAsRead: (notificationId: string) => Promise<void>;\r\n  markAllAsRead: () => Promise<void>;\r\n  refreshNotifications: () => Promise<void>;\r\n  isLoading: boolean;\r\n  error: string | null;\r\n  addLocalNotification: (message: string, type?: string) => void;\r\n}\r\n\r\nconst NotificationContext = createContext<NotificationContextType | undefined>(undefined);\r\n\r\nexport const useNotifications = () => {\r\n  const ctx = useContext(NotificationContext);\r\n  if (!ctx) throw new Error('useNotifications must be used within NotificationProvider');\r\n  return ctx;\r\n};\r\n\r\nexport const NotificationProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {\r\n  const { user } = useAuth();\r\n  const ws = useWebSocket();\r\n  const subscribe = ws?.subscribe;\r\n\r\n  const [activeNotifications, setActiveNotifications] = useState<Notification[]>([]);\r\n  const [clearedNotifications, setClearedNotifications] = useState<Notification[]>([]);\r\n  const [unreadCount, setUnreadCount] = useState(0);\r\n  const [isLoading, setIsLoading] = useState(false);\r\n  const [error, setError] = useState<string | null>(null);\r\n\r\n  const isMountedRef = useRef(true);\r\n  const lastFetchRef = useRef<number>(0);\r\n  const FETCH_COOLDOWN = 1000;\r\n  \r\n  // Track processed notification IDs to prevent duplicates\r\n  const processedNotificationIds = useRef<Set<string>>(new Set());\r\n\r\n  const loadNotifications = useCallback(async () => {\r\n    if (!user || !isMountedRef.current) return;\r\n    const now = Date.now();\r\n    if (now - lastFetchRef.current < FETCH_COOLDOWN) return;\r\n    lastFetchRef.current = now;\r\n\r\n    setIsLoading(true);\r\n    setError(null);\r\n    try {\r\n      const activeRes = await notificationService.getActiveNotifications(50);\r\n      if (activeRes.success && Array.isArray(activeRes.data) && isMountedRef.current) {\r\n        setActiveNotifications(activeRes.data);\r\n        setUnreadCount(activeRes.data.filter(n => !n.read).length);\r\n        \r\n        // Track all loaded notification IDs\r\n        activeRes.data.forEach(n => {\r\n          const id = n._id || n.id;\r\n          if (id) processedNotificationIds.current.add(id);\r\n        });\r\n      }\r\n      const clearedRes = await notificationService.getClearedNotifications(50);\r\n      if (clearedRes.success && Array.isArray(clearedRes.data) && isMountedRef.current) {\r\n        setClearedNotifications(clearedRes.data);\r\n      }\r\n    } catch (e) {\r\n      if (isMountedRef.current) setError('Failed to load notifications');\r\n    } finally {\r\n      if (isMountedRef.current) setIsLoading(false);\r\n    }\r\n  }, [user]);\r\n\r\n  useEffect(() => {\r\n    isMountedRef.current = true;\r\n    if (user) {\r\n      loadNotifications();\r\n    } else {\r\n      setActiveNotifications([]);\r\n      setClearedNotifications([]);\r\n      setUnreadCount(0);\r\n    }\r\n    return () => { isMountedRef.current = false; };\r\n  }, [user, loadNotifications]);\r\n\r\n  // FIXED: Only listen to the primary notification:new event from backend\r\n  useEffect(() => {\r\n    if (!subscribe || !user) return;\r\n    const unsubs: Array<() => void> = [];\r\n\r\n    // PRIMARY: This is the ONLY source for tip notifications\r\n    // The backend's Notification.createTipNotification automatically emits this\r\n    unsubs.push(subscribe('notification:new' as WebSocketEvent, (data: any) => {\r\n      if (!isMountedRef.current) return;\r\n      \r\n      console.log('[NotificationContext] notification:new received', data);\r\n      \r\n      // Check if we've already processed this notification\r\n      const notificationId = data.id || data._id;\r\n      if (notificationId && processedNotificationIds.current.has(notificationId)) {\r\n        console.log('[NotificationContext] Skipping duplicate notification:', notificationId);\r\n        return;\r\n      }\r\n      \r\n      // Add to processed set\r\n      if (notificationId) {\r\n        processedNotificationIds.current.add(notificationId);\r\n        \r\n        // Clean up old IDs to prevent memory leak\r\n        if (processedNotificationIds.current.size > 200) {\r\n          const idsArray = Array.from(processedNotificationIds.current);\r\n          processedNotificationIds.current = new Set(idsArray.slice(-100));\r\n        }\r\n      }\r\n      \r\n      const n: Notification = {\r\n        id: notificationId,\r\n        _id: notificationId,\r\n        recipient: data.recipient || user.username,\r\n        type: data.type,\r\n        title: data.title,\r\n        message: data.message,\r\n        data: data.data,\r\n        read: false,\r\n        cleared: false,\r\n        priority: data.priority || 'normal',\r\n        createdAt: data.createdAt || new Date().toISOString()\r\n      };\r\n      \r\n      // Check if notification already exists in state\r\n      setActiveNotifications(prev => {\r\n        const exists = prev.some(existing => \r\n          (existing._id || existing.id) === notificationId\r\n        );\r\n        \r\n        if (exists) {\r\n          console.log('[NotificationContext] Notification already in state:', notificationId);\r\n          return prev;\r\n        }\r\n        \r\n        return [n, ...prev];\r\n      });\r\n      \r\n      setUnreadCount(c => c + 1);\r\n    }));\r\n\r\n    // REMOVED: Legacy tip_received listener - no longer needed\r\n    // REMOVED: message:new tip listener - no longer needed\r\n    \r\n    // Clear/restore/delete event handlers remain the same\r\n    unsubs.push(subscribe('notification:cleared' as WebSocketEvent, (data: any) => {\r\n      const id = data?.notificationId;\r\n      setActiveNotifications(prev => {\r\n        const found = prev.find(n => (n._id || n.id) === id);\r\n        if (found) {\r\n          setClearedNotifications(c => [found, ...c]);\r\n          if (!found.read) setUnreadCount(u => Math.max(0, u - 1));\r\n        }\r\n        return prev.filter(n => (n._id || n.id) !== id);\r\n      });\r\n    }));\r\n\r\n    unsubs.push(subscribe('notification:all_cleared' as WebSocketEvent, () => {\r\n      setActiveNotifications(prevActive => {\r\n        setClearedNotifications(prevCleared => [\r\n          ...prevActive.map(n => ({ ...n, cleared: true })),\r\n          ...prevCleared\r\n        ]);\r\n        setUnreadCount(0);\r\n        return [];\r\n      });\r\n    }));\r\n\r\n    unsubs.push(subscribe('notification:restored' as WebSocketEvent, (data: any) => {\r\n      const id = data?.notificationId;\r\n      setClearedNotifications(prev => {\r\n        const found = prev.find(n => (n._id || n.id) === id);\r\n        if (found) {\r\n          setActiveNotifications(active => {\r\n            // Check if already exists to prevent duplicates\r\n            const exists = active.some(n => (n._id || n.id) === id);\r\n            if (exists) return active;\r\n            return [found, ...active];\r\n          });\r\n          if (!found.read) setUnreadCount(c => c + 1);\r\n        }\r\n        return prev.filter(n => (n._id || n.id) !== id);\r\n      });\r\n    }));\r\n\r\n    unsubs.push(subscribe('notification:deleted' as WebSocketEvent, (data: any) => {\r\n      const id = data?.notificationId;\r\n      setClearedNotifications(prev => prev.filter(n => (n._id || n.id) !== id));\r\n    }));\r\n\r\n    return () => unsubs.forEach(fn => fn());\r\n  }, [subscribe, user]);\r\n\r\n  // Actions\r\n  const clearNotification = useCallback(async (id: string) => {\r\n    try {\r\n      const res = await notificationService.clearNotification(id);\r\n      if (res.success) {\r\n        setActiveNotifications(prev => {\r\n          const found = prev.find(n => (n._id || n.id) === id);\r\n          if (found) {\r\n            setClearedNotifications(c => [{ ...found, cleared: true }, ...c]);\r\n            if (!found.read) setUnreadCount(u => Math.max(0, u - 1));\r\n          }\r\n          return prev.filter(n => (n._id || n.id) !== id);\r\n        });\r\n      } else setError('Failed to clear notification');\r\n    } catch {\r\n      setError('Failed to clear notification');\r\n    }\r\n  }, []);\r\n\r\n  const clearAllNotifications = useCallback(async () => {\r\n    try {\r\n      const res = await notificationService.clearAll();\r\n      if (res.success) {\r\n        setActiveNotifications(prevActive => {\r\n          setClearedNotifications(prevCleared => [\r\n            ...prevActive.map(n => ({ ...n, cleared: true })),\r\n            ...prevCleared\r\n          ]);\r\n          setUnreadCount(0);\r\n          return [];\r\n        });\r\n      } else setError('Failed to clear all notifications');\r\n    } catch {\r\n      setError('Failed to clear all notifications');\r\n    }\r\n  }, []);\r\n\r\n  const restoreNotification = useCallback(async (id: string) => {\r\n    try {\r\n      const res = await notificationService.restoreNotification(id);\r\n      if (res.success) {\r\n        setClearedNotifications(prev => {\r\n          const found = prev.find(n => (n._id || n.id) === id);\r\n          if (found) {\r\n            setActiveNotifications(active => {\r\n              // Check if already exists to prevent duplicates\r\n              const exists = active.some(n => (n._id || n.id) === id);\r\n              if (exists) return active;\r\n              return [found, ...active];\r\n            });\r\n            if (!found.read) setUnreadCount(u => u + 1);\r\n          }\r\n          return prev.filter(n => (n._id || n.id) !== id);\r\n        });\r\n      } else setError('Failed to restore notification');\r\n    } catch {\r\n      setError('Failed to restore notification');\r\n    }\r\n  }, []);\r\n\r\n  const deleteNotification = useCallback(async (id: string) => {\r\n    try {\r\n      const res = await notificationService.deleteNotification(id);\r\n      if (res.success) {\r\n        setClearedNotifications(prev => prev.filter(n => (n._id || n.id) !== id));\r\n      } else setError('Failed to delete notification');\r\n    } catch {\r\n      setError('Failed to delete notification');\r\n    }\r\n  }, []);\r\n\r\n  const deleteAllCleared = useCallback(async () => {\r\n    try {\r\n      const res = await notificationService.deleteAllCleared();\r\n      if (res.success) {\r\n        setClearedNotifications([]);\r\n      } else setError('Failed to delete cleared notifications');\r\n    } catch {\r\n      setError('Failed to delete cleared notifications');\r\n    }\r\n  }, []);\r\n\r\n  const markAsRead = useCallback(async (id: string) => {\r\n    try {\r\n      const res = await notificationService.markAsRead(id);\r\n      if (res.success) {\r\n        setActiveNotifications(prev =>\r\n          prev.map(n => (n._id || n.id) === id ? { ...n, read: true } : n)\r\n        );\r\n        const found = activeNotifications.find(n => (n._id || n.id) === id);\r\n        if (found && !found.read) setUnreadCount(u => Math.max(0, u - 1));\r\n      }\r\n    } catch {}\r\n  }, [activeNotifications]);\r\n\r\n  const markAllAsRead = useCallback(async () => {\r\n    try {\r\n      const res = await notificationService.markAllAsRead();\r\n      if (res.success) {\r\n        setActiveNotifications(prev => prev.map(n => ({ ...n, read: true })));\r\n        setUnreadCount(0);\r\n      }\r\n    } catch {}\r\n  }, []);\r\n\r\n  const addLocalNotification = useCallback((message: string, type: string = 'system') => {\r\n    if (!user) return;\r\n    const n: Notification = {\r\n      id: `local_${Date.now()}`,\r\n      recipient: user.username,\r\n      type: type as any,\r\n      title: 'Notification',\r\n      message,\r\n      read: false,\r\n      cleared: false,\r\n      createdAt: new Date().toISOString(),\r\n      priority: 'normal'\r\n    };\r\n    setActiveNotifications(prev => [n, ...prev]);\r\n    setUnreadCount(c => c + 1);\r\n  }, [user]);\r\n\r\n  const value: NotificationContextType = {\r\n    activeNotifications,\r\n    clearedNotifications,\r\n    unreadCount,\r\n    totalCount: activeNotifications.length + clearedNotifications.length,\r\n    clearNotification,\r\n    clearAllNotifications,\r\n    restoreNotification,\r\n    deleteNotification,\r\n    deleteAllCleared,\r\n    markAsRead,\r\n    markAllAsRead,\r\n    refreshNotifications: loadNotifications,\r\n    isLoading,\r\n    error,\r\n    addLocalNotification\r\n  };\r\n\r\n  return (\r\n    <NotificationContext.Provider value={value}>\r\n      {children}\r\n    </NotificationContext.Provider>\r\n  );\r\n};\r\n"],"names":[],"mappings":"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","debugId":null}}]
}